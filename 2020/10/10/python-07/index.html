<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="Python 学习笔记 (零七) 篇，本篇介绍的是 Python 实现多进程与多线程。">
<meta property="og:type" content="article">
<meta property="og:title" content="Python学习笔记(零七)：Python实现多进程·多线程">
<meta property="og:url" content="http://yoursite.com/2020/10/10/python-07/index.html">
<meta property="og:site_name" content="Cross Code">
<meta property="og:description" content="Python 学习笔记 (零七) 篇，本篇介绍的是 Python 实现多进程与多线程。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/MyBlog/Python/python-07/A01.bmp">
<meta property="article:published_time" content="2020-10-10T06:22:44.000Z">
<meta property="article:modified_time" content="2023-04-11T12:41:33.977Z">
<meta property="article:author" content="Minwei Chen">
<meta property="article:tag" content="Python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/MyBlog/Python/python-07/A01.bmp">

<link rel="canonical" href="http://yoursite.com/2020/10/10/python-07/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Python学习笔记(零七)：Python实现多进程·多线程 | Cross Code</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cross Code</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">There is only one heroism in the world: to see the world as it is and to love it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E8%BF%9B%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-text">一. 进程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-text">(A) 理论基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E8%BF%9B%E7%A8%8B%E5%AE%9A%E4%B9%89"><span class="nav-text">(B) 进程定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89"><span class="nav-text">(a) 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E7%89%B9%E5%BE%81"><span class="nav-text">(b) 特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-text">(c) 并行与并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E4%BB%8B%E7%BB%8D"><span class="nav-text">(C) 进程状态介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%A6%82%E8%BF%B0"><span class="nav-text">(a) 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="nav-text">(b) 同步和异步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-text">(c) 阻塞与非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E5%90%8C%E6%AD%A5-%E5%BC%82%E6%AD%A5%E5%92%8C%E9%98%BB%E5%A1%9E-%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="nav-text">(d) 同步&#x2F;异步和阻塞&#x2F;非阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#D-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%93%E6%9D%9F"><span class="nav-text">(D) 进程的创建与结束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-text">(a) 进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%93%E6%9D%9F"><span class="nav-text">(b) 进程的结束</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-Python-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-text">二. Python 实现多进程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-multiprocessing-Process"><span class="nav-text">(A) multiprocessing.Process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%AF%AD%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">(a) 语法介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-text">(b) 方法介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="nav-text">(c) 属性介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F"><span class="nav-text">(d) 特别注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Process-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">(B) Process 类的使用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">(a) 通过函数创建子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E7%BB%A7%E6%89%BFProcess%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">(b) 继承Process类创建子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-join-%E5%9B%9E%E6%94%B6%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">(c) join 回收子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%8F%B7"><span class="nav-text">(d) 查看进程号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-%E8%BF%9B%E7%A8%8B%E5%90%8D%E4%B8%8E%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="nav-text">(e) 进程名与进程状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-terminate%E7%BB%93%E6%9D%9F%E5%AD%90%E8%BF%9B%E7%A8%8B"><span class="nav-text">(f) terminate结束子进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#g-Process%E4%B8%AD%E7%9A%84%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-text">(g) Process中的守护进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="nav-text">(C) 进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E9%94%81-Lock"><span class="nav-text">(a) 锁 Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E6%8B%9F%E6%8A%A2%E7%A5%A8"><span class="nav-text">(b) 多进程模拟抢票</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF"><span class="nav-text">(D) 进程间通讯</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D-multiprocessing-Queue"><span class="nav-text">(a) 概念介绍 multiprocessing.Queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D-1"><span class="nav-text">(b) 方法介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="nav-text">(c) 实例演示</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9E%E4%BE%8B-1"><span class="nav-text">(1) 实例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E7%BB%99%E7%88%B6%E8%BF%9B%E7%A8%8B"><span class="nav-text">(2) 子进程发送数据给父进程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-text">(d) 生产者消费者模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%9F%BA%E4%BA%8E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-text">(2) 基于队列实现生产者消费者模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-JoinableQueue-%E9%98%9F%E5%88%97"><span class="nav-text">(e) JoinableQueue 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-JoinableQueue-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">(1) JoinableQueue 的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%94%A8%E4%BA%8E%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-text">(2) 用于生产者消费者模型</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E7%BA%BF%E7%A8%8B%E4%BB%8B%E7%BB%8D"><span class="nav-text">三. 线程介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E5%BC%95%E5%85%A5%E8%83%8C%E6%99%AF"><span class="nav-text">(A) 线程概念引入背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%BA%BF%E7%A8%8B%E7%89%B9%E7%82%B9"><span class="nav-text">(B) 线程特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">(a) 进程和线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-text">(b) 线程的特点</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-Python-%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">四. Python 实现多线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-threading-Thread"><span class="nav-text">(A) threading.Thread</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span class="nav-text">(a) 创建线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-text">(1) 通过函数创建子线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%BB%A7%E6%89%BFThread%E7%B1%BB%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B"><span class="nav-text">(2) 继承Thread类创建子线程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AD%90%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="nav-text">(b) 子线程与子进程对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="nav-text">(c) 设置线程阻塞</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-text">(d) 线程间通信的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E9%94%81"><span class="nav-text">(1) 线程锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97-queue"><span class="nav-text">(2) 同步队列 queue</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-%E6%9D%80%E6%AD%BB%E7%BA%BF%E7%A8%8B"><span class="nav-text">(e) 杀死线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-text">(f) 守护线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A"><span class="nav-text">(1) 详细解释</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%E6%BC%94%E7%A4%BA"><span class="nav-text">(2) 守护线程演示</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#g-%E7%BA%BF%E7%A8%8B%E5%AE%9A%E6%97%B6%E5%99%A8-Timer"><span class="nav-text">(g) 线程定时器 Timer</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-GIL-%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"><span class="nav-text">(B) GIL 全局解释器锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-GIL-%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">(a) GIL 是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-GIL"><span class="nav-text">(b) 为什么会有 GIL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-GIL-%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="nav-text">(c) GIL 的副作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-GIL-%E5%B0%8F%E7%BB%93"><span class="nav-text">(d) GIL 小结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E8%BF%9B%E7%A8%8B%E6%B1%A0-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">五. 进程池&#x2F;线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E6%A6%82%E8%BF%B0"><span class="nav-text">(A) 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-multiprocess-Pool-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-text">(B) multiprocess.Pool 实现进程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%AF%AD%E6%B3%95"><span class="nav-text">(a) 语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-text">(b) 常用方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E4%BE%8B"><span class="nav-text">(C) 多进程&#x2F;多线程实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-text">(a) 使用进程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B"><span class="nav-text">(b) 使用多进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-text">(c) 使用多线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-concurrent-futures-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-text">(D) concurrent.futures 实现进程池和线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-Executor"><span class="nav-text">(a) Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-Future"><span class="nav-text">(b) Future</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-wait-%E5%92%8C-as-completed"><span class="nav-text">(c) wait 和 as_completed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E7%BB%8F%E9%AA%8C%E6%8A%80%E5%B7%A7"><span class="nav-text">(d) 经验技巧</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%AD%A3%E7%A1%AE%E5%9C%B0%E4%BD%BF%E7%94%A8-submit-%E5%92%8C-map"><span class="nav-text">(1) 正确地使用 submit 和 map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AF%BB%E6%89%BE%E5%90%88%E9%80%82%E7%9A%84-max-worker"><span class="nav-text">(2) 寻找合适的 max_worker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="nav-text">(3) 避免死锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-text">(e) 简单使用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-%E5%8D%8F%E7%A8%8B"><span class="nav-text">六. 协程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E6%A6%82%E8%BF%B0-1"><span class="nav-text">(A) 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-Gevent-%E6%A8%A1%E5%9D%97"><span class="nav-text">(B) Gevent 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%A6%82%E8%BF%B0-1"><span class="nav-text">(a) 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%BB%A3%E7%A0%81%E5%AE%9E%E4%BE%8B"><span class="nav-text">(b) 代码实例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9E%E4%BE%8B-1-1"><span class="nav-text">(1) 实例 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E4%BE%8B-2"><span class="nav-text">(2) 实例 2</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minwei Chen"
      src="/images/tuoqi.jpg">
  <p class="site-author-name" itemprop="name">Minwei Chen</p>
  <div class="site-description" itemprop="description">Cross the surface, get to the reality. Welcome to Cross Code!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AltriaChen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AltriaChen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mwchennju@foxmail.com" title="E-Mail → mailto:mwchennju@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/10/python-07/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tuoqi.jpg">
      <meta itemprop="name" content="Minwei Chen">
      <meta itemprop="description" content="Cross the surface, get to the reality. Welcome to Cross Code!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cross Code">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python学习笔记(零七)：Python实现多进程·多线程
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-10 14:22:44" itemprop="dateCreated datePublished" datetime="2020-10-10T14:22:44+08:00">2020-10-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-11 20:41:33" itemprop="dateModified" datetime="2023-04-11T20:41:33+08:00">2023-04-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Python%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">Python笔记</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Python 学习笔记 (零七) 篇，本篇介绍的是 Python 实现多进程与多线程。</p>
<a id="more"></a>

<h1 id="一-进程介绍"><a href="#一-进程介绍" class="headerlink" title="一. 进程介绍"></a>一. 进程介绍</h1><p>进程的概念起源于操作系统，是操作系统最核心的概念，也是操作系统提供的最古老亦</p>
<p>最重要的抽象概念之一。操作系统的其他所有内容都是围绕进程的概念展开的。</p>
<p>注：即使可以利用的 cpu 只有一个 (早期的计算机确实如此)，也能保证支持 (伪) 并发的能力。将一个单独的 cpu 变成多个虚拟的 cpu (多道技术：时间多路复用和空间多路复用+硬件上支持隔离)，没有进程的抽象，现代计算机将不复存在。</p>
<h2 id="A-理论基础"><a href="#A-理论基础" class="headerlink" title="(A) 理论基础"></a>(A) 理论基础</h2><ul>
<li>操作系统的作用</li>
</ul>
<ol>
<li>隐藏复杂的硬件接口，提供良好的抽象接口</li>
<li>管理、调度进程，并且将多个进程对硬件的竞争变得有序</li>
</ol>
<ul>
<li>多道技术</li>
</ul>
<p>产生背景：针对单核，实现并发</p>
<p>注：现在的主机一般是多核，那么每个核都会利用多道技术。有 4 个 cpu，运行于 cpu1 的某个程序遇到 io 阻塞，会等到 io 结束再重新调度，会被调度到 4 个 cpu 中的任意一个，具体由操作系统调度算法决定。</p>
<ol>
<li><p>空间上的复用：如内存中同时有多道程序</p>
</li>
<li><p>时间上的复用：复用一个 cpu 的时间片</p>
</li>
</ol>
<p>注：遇到 io 切，占用 cpu 时间过长也切，核心在于切之前将进程的状态保存下来，这样才能保证下次切换回来时，能基于上次切走的位置继续运行。</p>
<h2 id="B-进程定义"><a href="#B-进程定义" class="headerlink" title="(B) 进程定义"></a>(B) 进程定义</h2><h3 id="a-定义"><a href="#a-定义" class="headerlink" title="(a) 定义"></a>(a) 定义</h3><p>进程 (Process) 是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体。</p>
<p>狭义定义：进程是正在运行的程序的实例 (an instance of a computer program that is being executed)。</p>
<p>广义定义：进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动。它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的执行单元。</p>
<ul>
<li>解析</li>
</ul>
<p>进程是一个实体。每一个进程都有它自己的地址空间，一般情况下，包括文本区域 (text region)、数据区域 (data region) 和堆栈 (stack region)。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</p>
<p>进程是一个“执行中的程序”。程序是一个没有生命的实体，只有处理器赋予程序生命时 (操作系统执行之)，它才能成为一个活动的实体，我们称其为进程。</p>
<p>进程是操作系统中最基本、重要的概念。是多道程序系统出现后，为了刻画系统内部出现的动态情况，描述系统内部各道程序的活动规律引进的一个概念，所有多道程序设计操作系统都建立在进程的基础上。</p>
<ul>
<li>为何引入进程概念</li>
</ul>
<p>从理论角度看，是对正在运行的程序过程的抽象；</p>
<p>从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。</p>
<h3 id="b-特征"><a href="#b-特征" class="headerlink" title="(b) 特征"></a>(b) 特征</h3><p>进程具有以下特征：</p>
<ol>
<li><p>动态性：进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</p>
</li>
<li><p>并发性：任何进程都可以同其他进程一起并发执行</p>
</li>
<li><p>独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位；</p>
</li>
<li><p>异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进</p>
</li>
<li><p>结构特征：进程由程序、数据和进程控制块三部分组成。</p>
</li>
</ol>
<p>多个不同的进程可以包含相同的程序：一个程序在不同的数据集里就构成不同的进程，能得到不同的结果；但是执行过程中，程序不能发生改变。</p>
<ul>
<li>进程与程序区别</li>
</ul>
<p>程序是指令和数据的有序集合，其本身没有任何运行的含义，是一个静态的概念。而进程是程序在处理机上的一次执行过程，它是一个动态的概念。</p>
<p>程序可以作为一种软件资料长期存在，而进程是有一定生命期的。</p>
<p>程序是永久的，进程是暂时的。</p>
<p>注意：同一个程序执行两次，就会在操作系统中出现两个进程，所以我们可以同时运行一个软件，分别做不同的事情也不会混乱。</p>
<h3 id="c-并行与并发"><a href="#c-并行与并发" class="headerlink" title="(c) 并行与并发"></a>(c) 并行与并发</h3><p><strong>并行:</strong> 并行是指两者同时执行，比如赛跑，两个人都在不停的往前跑；(资源够用，比如三个线程，四核的 CPU)</p>
<p><strong>并发:</strong> 并发是指资源有限的情况下，两者交替轮流使用资源，比如一段路 (单核 CPU 资源) 同时只能过一个人，A 走一段后，让给 B，B 用完继续给 A ，交替使用，目的是提高效率。</p>
<p>并行是从微观上，也就是在一个精确的时间片刻，有不同的程序在执行，这就要求必须有多个处理器。并发是从宏观上，在一个时间段上可以看出是同时执行的，比如一个服务器同时处理多个 session。</p>
<h2 id="C-进程状态介绍"><a href="#C-进程状态介绍" class="headerlink" title="(C) 进程状态介绍"></a>(C) 进程状态介绍</h2><h3 id="a-概述"><a href="#a-概述" class="headerlink" title="(a) 概述"></a>(a) 概述</h3><p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/MyBlog/Python/python-07/A01.bmp"></p>
<p>在了解其他概念之前，我们首先要了解进程的几个状态。在程序运行的过程中，由于被操作系统的调度算法控制，程序会进入几个状态：<strong>就绪，运行和阻塞</strong>。</p>
<ol>
<li><strong>就绪 (Ready) 状态：</strong>当进程已分配到除 CPU 以外的所有必要的资源，只要获得处理机便可立即执行，这时的进程状态称为就绪状态。</li>
<li><strong>执行/运行 (Running) 状态</strong>：当进程已获得处理机，其程序正在处理机上执行，此时的进程状态称为执行状态。</li>
<li><strong>阻塞 (Blocked) 状态</strong>：正在执行的进程，由于等待某个事件发生而无法执行时，便放弃处理机而处于阻塞状态。引起进程阻塞的事件可有多种，例如，等待 I/O 完成、申请缓冲区不能满足、等待信件 (信号) 等。</li>
</ol>
<h3 id="b-同步和异步"><a href="#b-同步和异步" class="headerlink" title="(b) 同步和异步"></a>(b) 同步和异步</h3><p>所谓同步就是一个任务的完成需要依赖另外一个任务时，只有等待被依赖的任务完成后，依赖的任务才能算完成，这是一种可靠的任务序列。要么成功都成功，失败都失败，两个任务的状态可以保持一致。</p>
<p>所谓异步是不需要等待被依赖的任务完成，只是通知被依赖的任务要完成什么工作，依赖的任务也立即执行，只要自己完成了整个任务就算完成了。至于被依赖的任务最终是否真正完成，依赖它的任务无法确定，所以它是不可靠的任务序列。</p>
<ul>
<li>例子</li>
</ul>
<p>比如我去银行办理业务，可能会有两种方式：</p>
<ol>
<li>第一种 ：选择排队等候；</li>
<li>第二种 ：选择取一个小纸条上面有我的号码，等到排到我这一号时由柜台的人通知我轮到我去办理业务了；</li>
</ol>
<p>第一种：前者 (排队等候) 就是同步等待消息通知，也就是我要一直在等待银行办理业务情况；</p>
<p>第二种：后者 (等待别人通知) 就是异步等待消息通知。在异步消息处理中，等待消息通知者 (在这个例子中就是等待办理业务的人) 往往注册一个回调机制，在所等待的事件被触发时由触发机制 (在这里是柜台的人) 通过某种机制 (在这里是写在小纸条上的号码，喊号) 找到等待该事件的人。</p>
<h3 id="c-阻塞与非阻塞"><a href="#c-阻塞与非阻塞" class="headerlink" title="(c) 阻塞与非阻塞"></a>(c) 阻塞与非阻塞</h3><p>阻塞和非阻塞这两个概念与程序 (线程) 等待消息通知 (无所谓同步或者异步) 时的状态有关。也就是说阻塞与非阻塞主要是程序 (线程) 等待消息通知时的状态角度来说的。</p>
<ul>
<li>例子</li>
</ul>
<p>继续上面的那个例子，不论是排队还是使用号码等待通知，如果在这个等待的过程中，等待者除了等待消息通知之外不能做其它的事情，那么该机制就是阻塞的，表现在程序中，也就是该程序一直阻塞在该函数调用处不能继续往下执行。</p>
<p>相反，有的人喜欢在银行办理这些业务的时候一边打打电话发发短信一边等待，这样的状态就是非阻塞的，因为他 (等待者) 没有阻塞在这个消息通知上，而是一边做自己的事情一边等待。</p>
<p>注意：<strong>同步非阻塞形式实际上是效率低下的，想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有。如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的；而异步非阻塞形式却没有这样的问题，因为打电话是你 (等待者) 的事情，而通知你则是柜台 (消息触发机制) 的事情，程序没有在两种不同的操作中来回切换。</strong></p>
<h3 id="d-同步-异步和阻塞-非阻塞"><a href="#d-同步-异步和阻塞-非阻塞" class="headerlink" title="(d) 同步/异步和阻塞/非阻塞"></a>(d) 同步/异步和阻塞/非阻塞</h3><ul>
<li><p>同步阻塞形式</p>
<p>效率最低。拿上面的例子来说，就是你专心排队，什么别的事都不做。 </p>
</li>
<li><p>异步阻塞形式</p>
</li>
</ul>
<p>如果在银行等待办理业务的人采用的是异步的方式去等待消息被触发 (通知)，也就是领了一张小纸条，假如在这段时间里他不能离开银行做其它的事情，那么很显然，这个人被阻塞在了这个等待的操作上面。</p>
<p><strong>异步操作是可以被阻塞住的，只不过它不是在处理消息时阻塞，而是在等待消息通知时被阻塞。</strong></p>
<ul>
<li>同步非阻塞形式</li>
</ul>
<p>实际上是效率低下的。</p>
<p>想象一下你一边打着电话一边还需要抬头看到底队伍排到你了没有，如果把打电话和观察排队的位置看成是程序的两个操作的话，这个程序需要在这两种不同的行为之间来回的切换，效率可想而知是低下的。</p>
<ul>
<li>异步非阻塞形式</li>
</ul>
<p>因为打电话是你 (等待者) 的事情，而通知你则是柜台 (消息触发机制) 的事情，程序没有在两种不同的操作中来回切换。</p>
<p>比如说，这个人突然发觉自己烟瘾犯了，需要出去抽根烟，于是他告诉大堂经理说，排到我这个号码的时候麻烦到外面通知我一下，那么他就没有被阻塞在这个等待的操作上面，自然这个就是异步+非阻塞的方式了。</p>
<p><strong>很多人会把同步和阻塞混淆，是因为很多时候同步操作会以阻塞的形式表现出来，同样的，很多人也会把异步和非阻塞混淆，因为异步操作一般都不会在真正的 IO 操作处被阻塞。</strong></p>
<h3 id="D-进程的创建与结束"><a href="#D-进程的创建与结束" class="headerlink" title="(D) 进程的创建与结束"></a>(D) 进程的创建与结束</h3><h3 id="a-进程的创建"><a href="#a-进程的创建" class="headerlink" title="(a) 进程的创建"></a>(a) 进程的创建</h3><p>但凡是硬件，都需要有操作系统去管理，<strong>只要有操作系统，就有进程的概念，就需要有创建进程的方式</strong>，一些操作系统只为一个应用程序设计，比如微波炉中的控制器，一旦启动微波炉，所有的进程都已经存在。</p>
<p>而对于通用系统 (跑很多应用程序)，需要有系统运行过程中创建或撤销进程的能力，主要分为四种形式创建新的进程：</p>
<ol>
<li>系统初始化 (查看进程 linux 中用 ps 命令，windows 中用任务管理器，前台进程负责与用户交互，后台运行的进程与用户无关，运行在后台并且只在需要时才唤醒的进程，称为守护进程，如电子邮件、web 页面、新闻、打印)</li>
<li>一个进程在运行过程中开启了子进程 (如 nginx 开启多进程，os.fork，subprocess.Popen 等)</li>
<li>用户的交互式请求，而创建一个新进程 (如用户双击暴风影音)</li>
<li>一个批处理作业的初始化 (只在大型机的批处理系统中应用)</li>
</ol>
<p>无论哪一种，<strong>新进程的创建都是由一个已经存在的进程执行了一个用于创建进程的系统调用而创建的。</strong></p>
<ul>
<li>UNIX 和 Windows 创建进程</li>
</ul>
<ol>
<li>在UNIX中该系统调用是：fork，fork 会创建一个与父进程一模一样的副本，二者有相同的存储映像、同样的环境字符串和同样的打开文件 (在 shell 解释器进程中，执行一个命令就会创建一个子进程)</li>
<li>在 Windows 中该系统调用是：CreateProcess，CreateProcess 既处理进程的创建，也负责把正确的程序装入新进程。</li>
</ol>
<ul>
<li>关于创建子进程，UNIX 和 Windows </li>
</ul>
<ol>
<li>相同的是：进程创建后，**父进程和子进程有各自不同的地址空间 (多道技术要求物理层面实现进程之间内存的隔离)**，任何一个进程的在其地址空间中的修改都不会影响到另外一个进程。</li>
<li>不同的是：在 UNIX 中，子进程的初始地址空间是父进程的一个副本，提示：<strong>子进程和父进程是可以有只读的共享内存区的。但是对于 Windows 系统来说，从一开始父进程与子进程的地址空间就是不同的。</strong></li>
</ol>
<h3 id="b-进程的结束"><a href="#b-进程的结束" class="headerlink" title="(b) 进程的结束"></a>(b) 进程的结束</h3><ol>
<li>正常退出 (自愿，如用户点击交互式页面的叉号，或程序执行完毕调用发起系统调用正常退出，在 linux 中用 exit，在 windows 中用 ExitProcess)</li>
<li>出错退出 (自愿，python a.py 中 a.py 不存在)</li>
<li>严重错误 (非自愿，执行非法指令，如引用不存在的内存，1/0 等，可以捕捉异常，try…except…)</li>
<li>被其他进程杀死 (非自愿，如 kill -9)</li>
</ol>
<h1 id="二-Python-实现多进程"><a href="#二-Python-实现多进程" class="headerlink" title="二. Python 实现多进程"></a>二. Python 实现多进程</h1><p>运行中的程序就是一个进程。<strong>所有的进程都是通过它的父进程来创建的</strong>。因此，运行起来的 python 程序也是一个进程，那么我们也可以在程序中再创建进程。多个进程可以实现并发效果，当我们的程序中存在多个进程的时候，在某些时候，就会让程序的执行速度变快。</p>
<p>在 linux c 语言中创建进程使用的 fork 函数，而 Python 就需要借助响应的模块</p>
<h2 id="A-multiprocessing-Process"><a href="#A-multiprocessing-Process" class="headerlink" title="(A) multiprocessing.Process"></a>(A) multiprocessing.Process</h2><p>multiprocessing 模块中 process 类是一个创建进程的类，借助这个类，就可以完成进程的创建。 </p>
<h3 id="a-语法介绍"><a href="#a-语法介绍" class="headerlink" title="(a) 语法介绍"></a>(a) 语法介绍</h3><p><code>Process([group [, target [, name [, args [, kwargs]]]]])</code> ， 由该类实例化得到的对象，表示一个子进程中的任务(尚未启动)</p>
<p>强调：</p>
<ol>
<li>需要使用关键字的方式来指定参数</li>
<li>args 指定的为传给 target 函数的位置参数，是一个元组形式，必须有逗号</li>
</ol>
<p>参数介绍：</p>
<ol>
<li><p>group 参数未使用，值始终为 None</p>
</li>
<li><p>target 表示调用对象，即子进程要执行的任务</p>
</li>
<li><p>args 表示调用对象的位置参数元组，<code>args=(1,2,&#39;egon&#39;,)</code></p>
</li>
<li><p>kwargs 表示调用对象的字典，<code>kwargs=&#123;&#39;name&#39;:&#39;egon&#39;,&#39;age&#39;:18&#125;</code></p>
</li>
<li><p>name 为子进程的名称</p>
</li>
</ol>
<h3 id="b-方法介绍"><a href="#b-方法介绍" class="headerlink" title="(b) 方法介绍"></a>(b) 方法介绍</h3><ul>
<li><code>p.start()</code>：启动进程，并调用该子进程中的 p.run()</li>
<li><code>p.run()</code>：进程启动时运行的方法，正是它去调用 target 指定的函数，我们自定义类的类中一定要实现该方法</li>
<li><code>p.terminate()</code>：强制终止进程 p，不会进行任何清理操作，如果 p 创建了子进程，该子进程就成了僵尸进程，使用该方法需要特别小心这种情况。如果 p 还保存了一个锁那么也将不会被释放，进而导致死锁</li>
<li><code>p.is_alive()</code>：如果 p 仍然运行，返回 True</li>
<li><code>p.join([timeout])</code>：主线程等待 p 终止(强调：是主线程处于等的状态，而 p 是处于运行的状态)。timeout 是可选的超时时间，需要强调的是，p.join 只能 join 住 start 开启的进程，而不能 join 住 run 开启的进程</li>
</ul>
<h3 id="c-属性介绍"><a href="#c-属性介绍" class="headerlink" title="(c) 属性介绍"></a>(c) 属性介绍</h3><ul>
<li><code>p.daemon</code>：默认值为 False，如果设为 True，代表 p 为后台运行的守护进程，并且设定为 True 后，p 不能创建自己的新进程，必须在 <code>p.start()</code> 之前设置</li>
<li><code>p.name</code>：进程的名称</li>
<li><code>p.pid</code>：进程的 pid</li>
<li><code>p.exitcode</code>：进程在运行时为 None、如果为 –N，表示被信号 N 结束</li>
<li><code>p.authkey</code>：进程的身份验证键，默认是由 <code>os.urandom()</code> 随机生成的 32 字符的字符串。这个键的用途是为涉及网络连接的底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功</li>
</ul>
<h3 id="d-特别注意"><a href="#d-特别注意" class="headerlink" title="(d) 特别注意"></a>(d) 特别注意</h3><p>在 Windows 操作系统中由于没有 fork (linux 操作系统中创建进程的机制)，在创建子进程的时候会自动 import 启动它的这个文件，而在 import 的时候又执行了整个文件。因此如果将 process() 直接写在文件中就会无限递归创建子进程报错。所以必须把创建子进程的部分使用 <code>if __name__ ==&#39;__main__&#39;</code> 判断保护起来，import 的时候，就不会递归运行了。 </p>
<h2 id="B-Process-类的使用"><a href="#B-Process-类的使用" class="headerlink" title="(B) Process 类的使用"></a>(B) Process 类的使用</h2><h3 id="a-通过函数创建子进程"><a href="#a-通过函数创建子进程" class="headerlink" title="(a) 通过函数创建子进程"></a>(a) 通过函数创建子进程</h3><p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    print(<span class="string">&quot;进程&#123;%s&#125; start&quot;</span> % (name))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">f&quot;进程<span class="subst">&#123;name&#125;</span> end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = Process(target=task, args=(<span class="string">&quot;Process1&quot;</span>,))  <span class="comment"># args用于传参，是个元祖，必须加逗号</span></span><br><span class="line">    p1.start()  <span class="comment"># 告诉操作系统启动子进程，但一定是父进程先执行，子进程的执行顺序由操作系统调度决定的</span></span><br><span class="line">    print(<span class="string">&#x27;主进程/父进程&#x27;</span>)</span><br><span class="line">    p2 = Process(target=task, args=(<span class="string">&quot;Process2&quot;</span>,))</span><br><span class="line">    p2.start()  <span class="comment"># 告诉操作系统启动子进程，但一定是父进程先执行</span></span><br><span class="line">    print(<span class="string">&#x27;主进程/父进程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主进程/父进程</span><br><span class="line">主进程/父进程</span><br><span class="line">进程&#123;Process1&#125; start</span><br><span class="line">进程&#123;Process2&#125; start</span><br><span class="line">进程Process1 end进程Process2 end</span><br></pre></td></tr></table></figure>

<h3 id="b-继承Process类创建子进程"><a href="#b-继承Process类创建子进程" class="headerlink" title="(b) 继承Process类创建子进程"></a>(b) 继承Process类创建子进程</h3><p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="comment"># self.name = name #错误 ### 这样没有给对象添加属性name，而是在修改父类的进程名(name)</span></span><br><span class="line">        <span class="comment"># 父类Process的进程名也是name</span></span><br><span class="line">        super().__init__()  <span class="comment"># 调用父类super().init方法完成创建进程初始化，重新给name属性赋值了。</span></span><br><span class="line">        self.name = name  <span class="comment">## 在父类的init方法后设置name，才是为自己对象添加属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># super().__init__(name=name)  # 调用父类super().init,并设置进程名(name)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span>  <span class="comment"># 创建进程会默认调用run方法</span></span><br><span class="line">        print(<span class="string">&quot;进程%s start&quot;</span> % (self.name))</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">f&quot;进程<span class="subst">&#123;self.name&#125;</span> end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = myProcess(<span class="string">&quot;Process1&quot;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    print(<span class="string">&#x27;主进程/父进程&#x27;</span>)</span><br><span class="line">    p1 = myProcess(<span class="string">&quot;Process2&quot;</span>)</span><br><span class="line">    p1.start()</span><br><span class="line">    print(<span class="string">&#x27;主进程/父进程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">主进程/父进程</span><br><span class="line">主进程/父进程</span><br><span class="line">进程Process1 start</span><br><span class="line">进程Process2 start</span><br><span class="line">进程Process2 end进程Process1 end</span><br></pre></td></tr></table></figure>

<h3 id="c-join-回收子进程"><a href="#c-join-回收子进程" class="headerlink" title="(c) join 回收子进程"></a>(c) join 回收子进程</h3><p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;进程  start &#x27;</span>)</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(<span class="string">&#x27;进程  end &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 并发执行进程，并依次回收</span></span><br><span class="line">    p1 = Process(target=foo, args=(<span class="number">1</span>,))</span><br><span class="line">    p2 = Process(target=foo, args=(<span class="number">2</span>,))</span><br><span class="line">    p3 = Process(target=foo, args=(<span class="number">3</span>,))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 开启进程</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 回收进程</span></span><br><span class="line">    p1.join()  <span class="comment"># 阻塞住主进程再等待子进程结束，然后再往下执行</span></span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    print(<span class="string">&#x27;All end&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">进程  start </span><br><span class="line">进程  start </span><br><span class="line">进程  start </span><br><span class="line">进程  end </span><br><span class="line">进程  end </span><br><span class="line">进程  end </span><br><span class="line">All end</span><br></pre></td></tr></table></figure>

<h3 id="d-查看进程号"><a href="#d-查看进程号" class="headerlink" title="(d) 查看进程号"></a>(d) 查看进程号</h3><p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, current_process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">查看主进程和子进程的进程号</span></span><br><span class="line"><span class="string">1. 通过os.getpid()方法</span></span><br><span class="line"><span class="string">2. 通过multiprocessing模块中的current_process().pid</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name, x</span>):</span></span><br><span class="line">    print(<span class="string">&quot;当前进程pid：&quot;</span>, current_process().pid)</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> start&quot;</span>)</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(<span class="string">f&quot;<span class="subst">&#123;name&#125;</span> end&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task, args=(<span class="string">&quot;进程1&quot;</span>, <span class="number">1</span>))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="comment"># 方式一</span></span><br><span class="line">    print(<span class="string">&quot;子进程pid：&quot;</span>, p.pid)</span><br><span class="line">    <span class="comment"># 方式二</span></span><br><span class="line">    <span class="comment"># print(&quot;当前进程pid：&quot;,current_process().pid)</span></span><br><span class="line">    print(<span class="string">&quot;当前进程pid&quot;</span>, os.getpid())</span><br><span class="line">    print(<span class="string">&quot;主进程的父进程pid&quot;</span>, os.getppid())  <span class="comment"># 实际上是pycharm的进程号</span></span><br><span class="line">    print()</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">子进程pid： <span class="number">17016</span></span><br><span class="line">当前进程pid <span class="number">10612</span></span><br><span class="line">主进程的父进程pid <span class="number">8836</span></span><br><span class="line"></span><br><span class="line">当前进程pid： <span class="number">17016</span></span><br><span class="line">进程<span class="number">1</span> start</span><br><span class="line">进程<span class="number">1</span> end</span><br></pre></td></tr></table></figure>

<h3 id="e-进程名与进程状态"><a href="#e-进程名与进程状态" class="headerlink" title="(e) 进程名与进程状态"></a>(e) 进程名与进程状态</h3><p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">process设置名字: name属性</span></span><br><span class="line"><span class="string">process判断进程是否存在：is_alive</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">x</span>):</span></span><br><span class="line">      print(<span class="string">&quot;进程 start&quot;</span>)</span><br><span class="line">      time.sleep(x)</span><br><span class="line">      print(<span class="string">&quot;进程 end&quot;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">      p = Process(target=task,args=(<span class="number">1</span>,))</span><br><span class="line">      p.start()</span><br><span class="line">      p.name = <span class="string">&quot;进程1&quot;</span></span><br><span class="line">      print(p.name)</span><br><span class="line">  </span><br><span class="line">      print(<span class="string">&quot;子进程是否存在：&quot;</span>, p.is_alive()) <span class="comment"># True</span></span><br><span class="line">      time.sleep(<span class="number">2</span>)   <span class="comment"># 延时2秒等待子进程结束</span></span><br><span class="line">      print(<span class="string">&quot;子进程是否存在：&quot;</span>, p.is_alive()) <span class="comment"># False</span></span><br><span class="line">  </span><br><span class="line">      print(<span class="string">&quot;主进程&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">进程<span class="number">1</span></span><br><span class="line">子进程是否存在： <span class="literal">True</span></span><br><span class="line">进程 start</span><br><span class="line">进程 end</span><br><span class="line">子进程是否存在： <span class="literal">False</span></span><br><span class="line">主进程</span><br></pre></td></tr></table></figure>

<h3 id="f-terminate结束子进程"><a href="#f-terminate结束子进程" class="headerlink" title="(f) terminate结束子进程"></a>(f) terminate结束子进程</h3><p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">terminate()</span></span><br><span class="line"><span class="string">告诉子进程让他结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&quot;进程 start&quot;</span>)</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(<span class="string">&quot;进程 end&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task, args=(<span class="number">10</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.terminate()   <span class="comment"># 告诉子进程让他提前结束</span></span><br><span class="line"></span><br><span class="line">    p.name = <span class="string">&quot;进程1&quot;</span></span><br><span class="line">    print(p.name)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;子进程是否存在：&quot;</span>, p.is_alive()) <span class="comment"># True</span></span><br><span class="line">    p.join()</span><br><span class="line">    print(<span class="string">&quot;子进程是否存在：&quot;</span>, p.is_alive()) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;主进程&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">进程<span class="number">1</span></span><br><span class="line">子进程是否存在： <span class="literal">True</span></span><br><span class="line">子进程是否存在： <span class="literal">False</span></span><br><span class="line">主进程</span><br></pre></td></tr></table></figure>

<h3 id="g-Process中的守护进程"><a href="#g-Process中的守护进程" class="headerlink" title="(g) Process中的守护进程"></a>(g) Process中的守护进程</h3><p>注，博主自己测试，实验。Process 中守护进程的部分和真正的守护进程概念并不一样，因此只需要知道 Process 的守护进程即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">daemon = True 把子进程变为守护进程</span></span><br><span class="line"><span class="string">主进程的代码执行完毕守护进程直接结束。但如果子进程代码结束也会结束</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">x</span>):</span></span><br><span class="line">    print(<span class="string">&quot;进程 start&quot;</span>)</span><br><span class="line">    time.sleep(x)</span><br><span class="line">    print(<span class="string">&quot;进程 end&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task,args=(<span class="number">2</span>,))</span><br><span class="line">    p.daemon = <span class="literal">True</span>  <span class="comment"># 把子进程变为守护进程</span></span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    p.name = <span class="string">&quot;进程1&quot;</span></span><br><span class="line">    print(p.name)</span><br><span class="line">    print(<span class="string">&quot;子进程pid：&quot;</span>, p.pid) <span class="comment">#</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;子进程是否存在：&quot;</span>, p.is_alive()) <span class="comment"># True</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;子进程是否存在：&quot;</span>, p.is_alive()) <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;主进程&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;子进程是否存在：&quot;</span>, p.is_alive())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进程<span class="number">1</span></span><br><span class="line">子进程pid： <span class="number">6968</span></span><br><span class="line">子进程是否存在： <span class="literal">True</span></span><br><span class="line">进程 start</span><br><span class="line">进程 end</span><br><span class="line">子进程是否存在： <span class="literal">False</span></span><br><span class="line">主进程</span><br><span class="line">子进程是否存在： <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="C-进程同步"><a href="#C-进程同步" class="headerlink" title="(C) 进程同步"></a>(C) 进程同步</h2><p>尽管并发编程让我们能更加充分的利用 IO 资源，但是也给我们带来了新的问题：<strong>当多个进程使用同一份数据资源的时候，就会引发数据安全或顺序混乱问题。</strong> </p>
<p>多进程会引发抢占资源的问题，为了解决这个问题就需要各进程之间相互同步，控制进程对关键资源的访问。 在 C语言中实现进程同步的方式有很多，比如：信号量，锁机制等。  </p>
<h3 id="a-锁-Lock"><a href="#a-锁-Lock" class="headerlink" title="(a) 锁 Lock"></a>(a) 锁 Lock</h3><p>Python 中可使用锁机制实现进程同步，过程如下</p>
<ol>
<li>首先 <code>from multiprocessing import Lock</code></li>
<li>在主进程中，实例化得到锁，<code>lock = Lock()</code>，并传给子进程</li>
<li>在子进程中通过上锁和解锁实现对多进程对资源的控制。<code>lock.acquire()</code> 上锁，<code>lock.release()</code> 解锁</li>
</ol>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">lock,n</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;等待开锁 进程<span class="subst">&#123;n&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 上锁</span></span><br><span class="line">    lock.acquire()     <span class="comment"># 当上锁之后别的进程无法访问，会阻塞住</span></span><br><span class="line">    print(<span class="string">f&#x27;进程<span class="subst">&#123;n&#125;</span> pid: %s is running&#x27;</span> % (os.getpid()))</span><br><span class="line">    time.sleep(random.random())</span><br><span class="line">    print(<span class="string">f&#x27;进程<span class="subst">&#123;n&#125;</span> pid: %s is done&#x27;</span> % (os.getpid()))</span><br><span class="line">    <span class="comment"># 开锁</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock() <span class="comment"># 实例化得到锁</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p = Process(target=work,args=(lock,i))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">等待开锁 进程<span class="number">0</span></span><br><span class="line">进程<span class="number">0</span> pid: <span class="number">7880</span> <span class="keyword">is</span> running</span><br><span class="line">等待开锁 进程<span class="number">1</span></span><br><span class="line">等待开锁 进程<span class="number">2</span></span><br><span class="line">进程<span class="number">0</span> pid: <span class="number">7880</span> <span class="keyword">is</span> done</span><br><span class="line">进程<span class="number">1</span> pid: <span class="number">18364</span> <span class="keyword">is</span> running</span><br><span class="line">进程<span class="number">1</span> pid: <span class="number">18364</span> <span class="keyword">is</span> done</span><br><span class="line">进程<span class="number">2</span> pid: <span class="number">5628</span> <span class="keyword">is</span> running</span><br><span class="line">进程<span class="number">2</span> pid: <span class="number">5628</span> <span class="keyword">is</span> done</span><br></pre></td></tr></table></figure>

<p>根据结果可以发现，在上锁之前的代码。多进程是并发访问的，但上锁之后，直到解锁后才能有第二个人访问。以此类推。<strong>就好像上厕所排队一样，进去一个人关上门锁上，第二个人等着。</strong></p>
<p><strong>但是看完你会有个疑问，那被锁上的代码，每个进程在访问的时候不就是串行地依次在访问嘛。</strong></p>
<p><strong>确实，锁机制 保证了数据的安全,但牺牲掉效率.</strong></p>
<h3 id="b-多进程模拟抢票"><a href="#b-多进程模拟抢票" class="headerlink" title="(b) 多进程模拟抢票"></a>(b) 多进程模拟抢票</h3><p>代码实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文件db的内容为：&#123;&quot;count&quot;:1&#125;</span></span><br><span class="line"><span class="comment"># 注意一定要用双引号，不然json无法识别</span></span><br><span class="line"><span class="comment"># 并发运行，效率高，但竞争写同一文件，数据写入错乱</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process,Lock</span><br><span class="line"><span class="keyword">import</span> time,json,os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>():</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&quot;db&quot;</span>,<span class="string">&quot;w&quot;</span>,encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = json.load(f)</span><br><span class="line">        print(<span class="string">f&#x27;还剩<span class="subst">&#123;data[<span class="string">&quot;count&quot;</span>]&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;db&#x27;</span>,<span class="string">&#x27;rt&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        res = json.load(f)</span><br><span class="line">    time.sleep(<span class="number">1</span>)  <span class="comment"># 模拟网络io</span></span><br><span class="line">    <span class="keyword">if</span> res[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        res[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">&#x27;db&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(res, f)</span><br><span class="line">            print(<span class="string">f&#x27;进程<span class="subst">&#123;os.getpid()&#125;</span> 抢票成功&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">1.5</span>)  <span class="comment"># 模拟网络io</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">&#x27;票已经售空啦!!!!!!!!!!!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">lock</span>):</span></span><br><span class="line">    print(<span class="string">f&quot;进程：<span class="subst">&#123;os.getpid()&#125;</span>  正在抢票中。。。&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 上锁     每个进程都会访问一遍，所以加锁就等于上锁到解锁这段代码是串行的</span></span><br><span class="line">    lock.acquire()  <span class="comment"># 当上锁之后别的进程无法访问，会阻塞住</span></span><br><span class="line">    get()</span><br><span class="line">    <span class="comment"># 开锁</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 创建锁</span></span><br><span class="line">    lock = Lock()</span><br><span class="line"></span><br><span class="line">    pro_list = []</span><br><span class="line">    <span class="comment"># 创建进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br><span class="line">        pro_list.append(p)</span><br><span class="line">    <span class="comment"># 回收进程</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        pro_list[i].join()</span><br></pre></td></tr></table></figure>

<p>小结：进程同步理论上应该是进程间通讯中的一部分，是一个大话题，每个语言也都有实现进程同步的需求。需要将各个进程对资源的访问加以限制。在各个语言中也都有限制。这里目前只介绍了这一种进程同步的方法。</p>
<p><strong>锁机制 是把锁住的代码变成了串行，保证了数据的安全,但牺牲掉效率。</strong></p>
<h2 id="D-进程间通讯"><a href="#D-进程间通讯" class="headerlink" title="(D) 进程间通讯"></a>(D) 进程间通讯</h2><p>IPC，就是多个进程间相互通讯。进程间通讯并不只是单个语言的问题，而是每个语言都有的。实现进程间通讯有很多，C语言中有 管道：pipe (匿名管道)，有名管道、信号、共享内存、消息队列、信号量等等</p>
<p>Python 中这里通过队列实现进程间通讯</p>
<h3 id="a-概念介绍-multiprocessing-Queue"><a href="#a-概念介绍-multiprocessing-Queue" class="headerlink" title="(a) 概念介绍 multiprocessing.Queue"></a>(a) 概念介绍 multiprocessing.Queue</h3><p>创建共享的进程队列，Queue 是多进程安全的队列，可以使用 Queue 实现多进程之间的数据传递。</p>
<p><code>Queue([maxsize])</code> 创建共享的进程队列。<br>参数 ：maxsize 是队列中允许的最大项数。如果省略此参数，则无大小限制。</p>
<p>底层队列使用管道和锁定实现</p>
<h3 id="b-方法介绍-1"><a href="#b-方法介绍-1" class="headerlink" title="(b) 方法介绍"></a>(b) 方法介绍</h3><p><code>Queue([maxsize])</code>：创建共享的进程队列。maxsize 是队列中允许的最大项数。如果省略此参数，则无大小限制。底层队列使用管道和锁定实现。另外，还需要运行支持进程以便队列中的数据传输到底层管道中。<br>Queue 的实例 q 具有以下方法：</p>
<p><code>q.get( [ block [ ,timeout ] ] )</code>：返回 q 中的一个项目。如果 q 为空，此方法将阻塞，直到队列中有项目可用为止。block 用于控制阻塞行为，默认为 True. 如果设置为 False，将引发 Queue.Empty 异常 (定义在 Queue 模块中)。timeout 是可选超时时间，用在阻塞模式中。如果在制定的时间间隔内没有项目变为可用，将引发 Queue.Empty 异常。</p>
<p><code>q.get_nowait()</code> ：同 <code>q.get(False)</code> 方法。</p>
<p><code>q.put(item [, block [,timeout ] ] )</code> ：将 item 放入队列。如果队列已满，此方法将阻塞至有空间可用为止。block 控制阻塞行为，默认为 True。如果设置为 False，将引发 Queue.Empty 异常 (定义在 Queue 库模块中)。timeout 指定在阻塞模式中等待可用空间的时间长短。超时后将引发 Queue.Full 异常。</p>
<p><code>q.qsize()</code> ：返回队列中目前项目的正确数量。此函数的结果并不可靠，因为在返回结果和在稍后程序中使用结果之间，队列中可能添加或删除了项目。在某些系统上，此方法可能引发 NotImplementedError 异常。</p>
<p><code>q.empty()</code> ：如果调用此方法时 q 为空，返回 True。如果其他进程或进程正在往队列中添加项目，结果是不可靠的。也就是说，在返回和使用结果之间，队列中可能已经加入新的项目。</p>
<p><code>q.full()</code> ：如果 q 已满，返回为 True. 由于进程的存在，结果也可能是不可靠的 (参考 <code>q.empty()</code> 方法)。</p>
<p><code>q.close()</code> ：关闭队列，防止队列中加入更多数据。调用此方法时，后台进程将继续写入那些已入队列但尚未写入的数据，但将在此方法完成时马上关闭。如果 q 被垃圾收集，将自动调用此方法。关闭队列不会在队列使用者中生成任何类型的数据结束信号或异常。例如，如果某个使用者正被阻塞在 <code>get()</code> 操作上，关闭生产者中的队列不会导致 <code>get()</code> 方法返回错误。</p>
<p><code>q.cancel_join_thread()</code> ：不会再进程退出时自动连接后台进程。这可以防止 <code>join_thread()</code> 方法阻塞。</p>
<p><code>q.join_thread()</code> ：连接队列的后台进程。此方法用于在调用 <code>q.close()</code> 方法后，等待所有队列项被消耗。默认情况下，此方法由不是q的原始创建者的所有进程调用。调用 <code>q.cancel_join_thread()</code> 方法可以禁止这种行为。</p>
<h3 id="c-实例演示"><a href="#c-实例演示" class="headerlink" title="(c) 实例演示"></a>(c) 实例演示</h3><h4 id="1-实例-1"><a href="#1-实例-1" class="headerlink" title="(1) 实例 1"></a>(1) 实例 1</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ipc 进程间通讯。使用队列实现</span></span><br><span class="line"><span class="string">管道:pipe 基于共享的内存空间</span></span><br><span class="line"><span class="string">队列:pipe+锁 Queue</span></span><br><span class="line"><span class="string">put：放（可以设置阻塞非阻塞，和等待时间）</span></span><br><span class="line"><span class="string">get：取（可以设置阻塞非阻塞，和等待时间）</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span>  Queue</span><br><span class="line"></span><br><span class="line"><span class="comment">### 语法</span></span><br><span class="line">q = Queue(<span class="number">3</span>) <span class="comment"># 创建队列, 可以设置最大值</span></span><br><span class="line"><span class="comment">## put 放</span></span><br><span class="line">q.put(<span class="string">&#x27;你好&#x27;</span>)     <span class="comment"># 往队列中放入值，可以设置阻塞和等待时间，默认：满了再放就会阻塞等待</span></span><br><span class="line">q.put([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line">q.put(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## get 拿</span></span><br><span class="line">print(q.get())  <span class="comment"># 获取队列中的内容，可以设置阻塞和等待时间，默认：拿不到内容就会阻塞等待</span></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"></span><br><span class="line"><span class="comment">### 全都设置非阻塞模式</span></span><br><span class="line">q = Queue(<span class="number">3</span>) <span class="comment"># 创建队列, 可以设置最大值</span></span><br><span class="line">q.put(<span class="string">&#x27;你好&#x27;</span>, block=<span class="literal">False</span>)     <span class="comment"># 设置非阻塞，如果满了再放就会报错</span></span><br><span class="line">q.put([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>], block=<span class="literal">False</span>)</span><br><span class="line">q.put(<span class="number">2</span>, block=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你好</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-子进程发送数据给父进程"><a href="#2-子进程发送数据给父进程" class="headerlink" title="(2) 子进程发送数据给父进程"></a>(2) 子进程发送数据给父进程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">q</span>):</span></span><br><span class="line">    q.put([time.asctime(), <span class="string">&#x27;from Eva&#x27;</span>, <span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line">    <span class="comment">#调用主函数中p进程传递过来的进程参数 put函数为向队列中添加一条数据。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue() <span class="comment">#创建一个Queue对象</span></span><br><span class="line">    p = Process(target=f, args=(q,)) <span class="comment">#创建一个进程</span></span><br><span class="line">    p.start()</span><br><span class="line">    print(q.get())</span><br><span class="line">    p.join()</span><br></pre></td></tr></table></figure>

<p> 上面是一个 queue 的简单应用，使用队列 q 对象调用 get 函数来取得队列中最先进入的数据。 </p>
<h3 id="d-生产者消费者模型"><a href="#d-生产者消费者模型" class="headerlink" title="(d) 生产者消费者模型"></a>(d) 生产者消费者模型</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1) 概述"></a>(1) 概述</h4><p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产进程和消费进程的工作能力来提高程序的整体处理数据的速度。</p>
<ul>
<li>为什么要使用生产者和消费者模式</li>
</ul>
<p>在进程世界里，生产者就是生产数据的进程，消费者就是消费数据的进程。在多进程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式。 </p>
<ul>
<li>什么是生产者消费者模式</li>
</ul>
<p>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。</p>
<h4 id="2-基于队列实现生产者消费者模型"><a href="#2-基于队列实现生产者消费者模型" class="headerlink" title="(2) 基于队列实现生产者消费者模型"></a>(2) 基于队列实现生产者消费者模型</h4><p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q,name,food</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;生产者&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>生产了<span class="subst">&#123;food&#125;</span><span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        res = <span class="string">f&#x27;<span class="subst">&#123;food&#125;</span><span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">        q.put(res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q,name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;消费者&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>买了<span class="subst">&#123;res&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()   <span class="comment"># 使用队列</span></span><br><span class="line">    p1 = Process(target=producer,args=(q,<span class="string">&quot;xc&quot;</span>,<span class="string">&quot;意大利面&quot;</span>))</span><br><span class="line">    c1 = Process(target=consumer,args=(q,<span class="string">&quot;haha&quot;</span>))</span><br><span class="line">    p2 = Process(target=producer, args=(q, <span class="string">&quot;xc&quot;</span>, <span class="string">&quot;牛肉&quot;</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q, <span class="string">&quot;xixi&quot;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&quot;xc&quot;</span>, <span class="string">&quot;可乐&quot;</span>))</span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    c2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    p1.join()   <span class="comment"># 等待生产者结束</span></span><br><span class="line">    p2.join()   <span class="comment"># 等待生产者结束</span></span><br><span class="line">    p3.join()   <span class="comment"># 等待生产者结束</span></span><br><span class="line"></span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment"># 有几个消费者就要发几个None，让 子进程收到None就结束</span></span><br><span class="line">    q.put(<span class="literal">None</span>) <span class="comment"># 有几个消费者就要发几个None，让 子进程收到None就结束</span></span><br></pre></td></tr></table></figure>

<p><strong>结束信号 None，不一定要由生产者发，主进程里同样可以发，但主进程需要等生产者结束后才应该发送该信号。 有几个消费者就要发几个 None，让子进程收到 None 就结束</strong> </p>
<h3 id="e-JoinableQueue-队列"><a href="#e-JoinableQueue-队列" class="headerlink" title="(e) JoinableQueue 队列"></a>(e) JoinableQueue 队列</h3><p> JoinableQueue 队列就对 Queue 队列的改良版，加入了类似信号量的机制。 </p>
<h4 id="1-JoinableQueue-的使用"><a href="#1-JoinableQueue-的使用" class="headerlink" title="(1) JoinableQueue 的使用"></a>(1) JoinableQueue 的使用</h4><p><strong>语法：</strong></p>
<ol>
<li>实例化对象：<code>q = JoinableQueue()</code></li>
<li>向队列中放入内容，相当于信号量 +1 操作: <code>q.put(xxx)</code></li>
<li>从队列中取出内容：<code>q.get()</code></li>
<li>任务结束，相当于 信号量 -1 操作: <code>q.task_done()</code></li>
<li>当这个信号量不为 0 时，会阻塞等待，计数器为 0 后通过。</li>
</ol>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> JoinableQueue</span><br><span class="line"></span><br><span class="line"><span class="comment"># JoinableQueue的使用</span></span><br><span class="line">q = JoinableQueue()</span><br><span class="line"></span><br><span class="line">q.put(<span class="string">&#x27;1&#x27;</span>)  <span class="comment"># +1</span></span><br><span class="line">q.put(<span class="string">&#x27;2&#x27;</span>)  <span class="comment"># +1</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()   <span class="comment"># -1</span></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()  <span class="comment"># -1</span></span><br><span class="line">q.join() <span class="comment">#计数器不为0会阻塞等待 计数器为0后通过</span></span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-用于生产者消费者模型"><a href="#2-用于生产者消费者模型" class="headerlink" title="(2) 用于生产者消费者模型"></a>(2) 用于生产者消费者模型</h4><p>通过 JoinableQueue 队列实现生产者消费者模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> JoinableQueue, Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q, name, food</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;生产者&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>生产了<span class="subst">&#123;food&#125;</span><span class="subst">&#123;i&#125;</span>&#x27;</span>)</span><br><span class="line">        res = <span class="string">f&#x27;<span class="subst">&#123;food&#125;</span><span class="subst">&#123;i&#125;</span>&#x27;</span></span><br><span class="line">        q.put(res)  <span class="comment"># +1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q, name</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;消费者&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">f&#x27;<span class="subst">&#123;name&#125;</span>买了<span class="subst">&#123;res&#125;</span>&#x27;</span>)</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = JoinableQueue()     <span class="comment"># 使用加了join的队列</span></span><br><span class="line">    p1 = Process(target=producer, args=(q, <span class="string">&quot;xc&quot;</span>, <span class="string">&quot;意大利面&quot;</span>))</span><br><span class="line">    c1 = Process(target=consumer, args=(q, <span class="string">&quot;haha&quot;</span>))</span><br><span class="line">    p2 = Process(target=producer, args=(q, <span class="string">&quot;xc&quot;</span>, <span class="string">&quot;牛肉&quot;</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q, <span class="string">&quot;xixi&quot;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&quot;xc&quot;</span>, <span class="string">&quot;可乐&quot;</span>))</span><br><span class="line">    <span class="comment"># 把消费者变成守护进程，主进程结束，子进程就结束</span></span><br><span class="line">    c1.daemon = <span class="literal">True</span>    <span class="comment"># 进程结束，子进程就结束</span></span><br><span class="line">    c2.daemon = <span class="literal">True</span>    <span class="comment"># 进程结束，子进程就结束</span></span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    c1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    c2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    p1.join()  <span class="comment"># 等待生产者结束</span></span><br><span class="line">    p2.join()  <span class="comment"># 等待生产者结束</span></span><br><span class="line">    p3.join()  <span class="comment"># 等待生产者结束</span></span><br></pre></td></tr></table></figure>

<p>上述代码中，是<strong>通过将子进程变为守护进程</strong>，在消费者的子进程中<strong>每次收到消息都 task_done</strong>，然后<strong>等待主进程结束，直接结束子进程</strong>。 </p>
<h1 id="三-线程介绍"><a href="#三-线程介绍" class="headerlink" title="三. 线程介绍"></a>三. 线程介绍</h1><h2 id="A-线程概念引入背景"><a href="#A-线程概念引入背景" class="headerlink" title="(A) 线程概念引入背景"></a>(A) 线程概念引入背景</h2><ul>
<li>进程</li>
</ul>
<p>之前我们已经了解了操作系统中进程的概念，程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了 CPU 的利用率。进程的出现让每个用户感觉到自己独享 CPU，因此，进程就是为了在 CPU 上实现多道编程而提出的。 </p>
<ul>
<li>有了进程为什么要有线程</li>
</ul>
<ol>
<li><p>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</p>
</li>
<li><p>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</p>
</li>
</ol>
<p>如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p>
<p>现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制 —— 线程。</p>
<ul>
<li>线程的出现</li>
</ul>
<p>60 年代，在 OS 中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机 (SMP) 出现，可以满足多个运行单位，而多个进程并行开销过大。</p>
<p>因此在 80 年代，出现了能独立运行的基本单位 —— 线程 (Threads)。</p>
<p>注意：<strong>进程是资源分配的最小单位，线程是 CPU 调度的最小单位。每一个进程中至少有一个线程。</strong></p>
<h2 id="B-线程特点"><a href="#B-线程特点" class="headerlink" title="(B) 线程特点"></a>(B) 线程特点</h2><h3 id="a-进程和线程的区别"><a href="#a-进程和线程的区别" class="headerlink" title="(a) 进程和线程的区别"></a>(a) 进程和线程的区别</h3><p><strong>线程与进程的区别</strong>可以归纳为<strong>以下 4 点</strong>：</p>
<ol>
<li>地址空间和其它资源 (如打开文件)：进程间相互独立，但同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li>
<li>通信：进程间通信 IPC，线程间可以直接读写进程数据段 (如全局变量) 来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li>
<li>在多线程操作系统中，进程不是一个可执行的实体。</li>
</ol>
<h3 id="b-线程的特点"><a href="#b-线程的特点" class="headerlink" title="(b) 线程的特点"></a>(b) 线程的特点</h3><p>在多线程 OS 中，<strong>一个进程可以包含多个线程，线程是 OS 运行调度的基本单位</strong></p>
<ol>
<li><strong>资源共享</strong></li>
</ol>
<p>线程在同一进程中的各个线程，<strong>都可以共享该进程所拥有的资源</strong>，这首先表现在：所有线程都具有相同的进程 id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p>
<ol start="2">
<li><strong>可并发执行</strong></li>
</ol>
<p>在一个进程中的多个线程之间，可以<strong>并发执行</strong>，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</p>
<ol start="3">
<li><strong>线程的调度比进程的调度快</strong></li>
</ol>
<p>线程上下文切换比进程上下文切换要快得多。</p>
<h1 id="四-Python-实现多线程"><a href="#四-Python-实现多线程" class="headerlink" title="四. Python 实现多线程"></a>四. Python 实现多线程</h1><h2 id="A-threading-Thread"><a href="#A-threading-Thread" class="headerlink" title="(A) threading.Thread"></a>(A) threading.Thread</h2><p> multiprocess 模块的完全模仿了 threading 模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍 </p>
<h3 id="a-创建线程"><a href="#a-创建线程" class="headerlink" title="(a) 创建线程"></a>(a) 创建线程</h3><h4 id="1-通过函数创建子线程"><a href="#1-通过函数创建子线程" class="headerlink" title="(1) 通过函数创建子线程"></a>(1) 通过函数创建子线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s say hello&#x27;</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">&#x27;test&#x27;</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主线程</span><br><span class="line">test say hello</span><br></pre></td></tr></table></figure>

<h4 id="2-继承Thread类创建子线程"><a href="#2-继承Thread类创建子线程" class="headerlink" title="(2) 继承Thread类创建子线程"></a>(2) 继承Thread类创建子线程</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sayhi</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">&#x27;%s say hello&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Sayhi(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主线程</span><br><span class="line">test say hello</span><br></pre></td></tr></table></figure>

<h3 id="b-子线程与子进程对比"><a href="#b-子线程与子进程对比" class="headerlink" title="(b) 子线程与子进程对比"></a>(b) 子线程与子进程对比</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程/主进程&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#在主进程下开启子进程</span></span><br><span class="line">    t=Process(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程/主进程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">主线程/主进程</span><br><span class="line"></span><br><span class="line">主线程/主进程</span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>以上结果说明，在主进程下开启线程时，先执行了 <code>t.start()</code>，后执行 <code>print(&#39;主线程/主进程&#39;)</code>，而在主进程下开启子进程时，二者执行顺序反之。</p>
<h3 id="c-设置线程阻塞"><a href="#c-设置线程阻塞" class="headerlink" title="(c) 设置线程阻塞"></a>(c) 设置线程阻塞</h3><p>我们可以用 join() 方法使主线程陷入阻塞，以等待某个线程执行完毕。因此这也是实现线程同步的一种方式。参数 timeout 可以用来设置主线程陷入阻塞的时间，如果线程不是守护线程，即没有设置 daemon 为 True，那么参数  timeout 是无效的，主线程会一直阻塞，直到子线程执行结束。<br>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span>():</span></span><br><span class="line">    <span class="keyword">if</span> current_thread().name == <span class="string">&quot;1&quot;</span>:</span><br><span class="line">        time.sleep(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        time.sleep(<span class="number">6</span>)</span><br><span class="line">    print(<span class="string">&quot;线程&#123;&#125;已退出&quot;</span>.format(current_thread().name))</span><br><span class="line"></span><br><span class="line">thread01 = Thread(target=target, daemon=<span class="literal">True</span>, name=<span class="string">&quot;1&quot;</span>)</span><br><span class="line">thread02 = Thread(target=target, daemon=<span class="literal">True</span>, name=<span class="string">&quot;2&quot;</span>)</span><br><span class="line"></span><br><span class="line">thread01.start()</span><br><span class="line">thread02.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;程序因线程1陷入阻塞&quot;</span>)</span><br><span class="line">thread01.join(timeout=<span class="number">3</span>)</span><br><span class="line">print(<span class="string">&quot;程序因线程2陷入阻塞&quot;</span>)</span><br><span class="line">thread02.join(timeout=<span class="number">3</span>)</span><br><span class="line">print(<span class="string">&quot;主线程已退出&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">程序因线程<span class="number">1</span>陷入阻塞</span><br><span class="line">程序因线程<span class="number">2</span>陷入阻塞</span><br><span class="line">线程<span class="number">1</span>已退出</span><br><span class="line">线程<span class="number">2</span>已退出</span><br><span class="line">主线程已退出</span><br></pre></td></tr></table></figure>

<h3 id="d-线程间通信的方式"><a href="#d-线程间通信的方式" class="headerlink" title="(d) 线程间通信的方式"></a>(d) 线程间通信的方式</h3><p>我们知道，线程之间共享同一块内存。子线程虽然可以通过指定 target 来执行一个函数，但是这个函数的返回值是没有办法直接传回主线程的。我们使用多线程一般是用于并行执行一些其他任务，因此获取子线程的执行结果十分有必要。</p>
<p>直接使用全局变量虽然可行，但是资源的并发读写会引来线程安全问题。下面给出常用的两种处理方式：</p>
<h4 id="1-线程锁"><a href="#1-线程锁" class="headerlink" title="(1) 线程锁"></a>(1) 线程锁</h4><p>其一是可以考虑使用锁来处理，当多个线程对同一份资源进行读写操作时，我们可以通过加锁来确保数据安全。 Python 中给出了多种锁的实现，例如：同步锁 Lock，递归锁 RLock，条件锁 Condition，事件锁 Event，信号量锁 Semaphore，这里只给出 Lock 的使用方式，其余的大家感兴趣可以自己查阅。</p>
<p>可以通过 threading.lock 类来创建锁对象，一旦一个线程获得一个锁，会阻塞之后所有尝试获得该锁对象的线程，直到它被重新释放。这里举一个例子，通过加锁来确保两个线程在对同一个全局变量进行读写时的数据安全。</p>
<p>实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">book_num = <span class="number">100</span>  <span class="comment"># 图书馆最开始有100本图书</span></span><br><span class="line">bookLock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">books_return</span>():</span></span><br><span class="line">    <span class="keyword">global</span> book_num</span><br><span class="line">    <span class="keyword">while</span> book_num &lt;= <span class="number">106</span>:</span><br><span class="line">        bookLock.acquire()</span><br><span class="line">        book_num += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;归还1本，现有图书&#123;&#125;本&quot;</span>.format(book_num))</span><br><span class="line">        bookLock.release()</span><br><span class="line">        sleep(<span class="number">1</span>)  <span class="comment"># 模拟事件发生周期</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">books_lease</span>():</span></span><br><span class="line">    <span class="keyword">global</span> book_num</span><br><span class="line">    <span class="keyword">while</span> book_num &lt;= <span class="number">106</span>:</span><br><span class="line">        bookLock.acquire()</span><br><span class="line">        book_num -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;借走1本，现有图书&#123;&#125;本&quot;</span>.format(book_num))</span><br><span class="line">        bookLock.release()</span><br><span class="line">        sleep(<span class="number">2</span>)  <span class="comment"># 模拟事件发生周期</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    thread_lease = Thread(target=books_lease)</span><br><span class="line">    thread_return = Thread(target=books_return)</span><br><span class="line">    thread_lease.start()</span><br><span class="line">    thread_return.start()</span><br></pre></td></tr></table></figure>

<h4 id="2-同步队列-queue"><a href="#2-同步队列-queue" class="headerlink" title="(2) 同步队列 queue"></a>(2) 同步队列 queue</h4><ul>
<li><p>先进先出 (FIFO)</p>
<p><code>class queue.Queue(maxsize=0) </code>，我们以此为例，介绍 queue 的主要方法</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Queue(maxsize=<span class="number">5</span>)  <span class="comment"># 创建一个FIFO队列，并制定队列大小，若maxsize被指定为小于等于0，则队列无限大</span></span><br><span class="line"></span><br><span class="line">Queue.qsize() <span class="comment"># 返回队列的大致大小，注意并不是确切值，所以不能被用来当做后续线程是否会被阻塞的依据</span></span><br><span class="line"></span><br><span class="line">Queue.empty() <span class="comment"># 判断队列为空是否成立，同样不能作为阻塞依据</span></span><br><span class="line"></span><br><span class="line">Queue.full()  <span class="comment"># 判断队列为满是否成立，同样不能作为阻塞依据</span></span><br><span class="line"></span><br><span class="line">Queue.put(item, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>) <span class="comment"># 投放元素进入队列，block为True表示如果队列满了投放失败，将阻塞该线程，timeout可用来设置线程阻塞的时间长短（秒）；</span></span><br><span class="line"><span class="comment"># 注意，如果block为False，如果队列为满，则将直接引发Full异常，timeout将被忽略（在外界用try处理异常即可）</span></span><br><span class="line">Queue.put_nowait(item) <span class="comment"># 相当于put(item, block=False)</span></span><br><span class="line"></span><br><span class="line">Queue.get(block=<span class="literal">True</span>, timeout=<span class="literal">False</span>) <span class="comment"># 从队列中取出元素，block为False而队列为空时，会引发Empty异常</span></span><br><span class="line">Queue.get_nowait() <span class="comment"># 相当于get(block=False)</span></span><br><span class="line"></span><br><span class="line">Queue.task_done() <span class="comment"># 每个线程使用get方法从队列中获取一个元素，该线程通过调用task_done()表示该元素已处理完成。</span></span><br><span class="line"></span><br><span class="line">Queue.join() <span class="comment"># 阻塞至队列中所有元素都被处理完成，即队列中所有元素都已被接收，且接收线程全已调用task_done()</span></span><br></pre></td></tr></table></figure>

<p>(1) 实例 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment">### 普通队列</span></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 没有计数器进行阻塞  FIFO</span></span><br><span class="line">q.put(<span class="string">&quot;first&quot;</span>)</span><br><span class="line">q.put(<span class="string">&quot;second&quot;</span>)</span><br><span class="line">q.put(<span class="string">&quot;third&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">first</span><br><span class="line">second</span><br><span class="line">third</span><br></pre></td></tr></table></figure>

<p>(2) 实例 2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment">### 普通队列</span></span><br><span class="line">q = queue.Queue()</span><br><span class="line"></span><br><span class="line"><span class="comment">### 加了计数器进行阻塞的队列  FIFO</span></span><br><span class="line">q.put(<span class="number">1</span>)    <span class="comment"># +1</span></span><br><span class="line">q.put(<span class="number">2</span>)    <span class="comment"># +1</span></span><br><span class="line">q.put(<span class="number">3</span>)    <span class="comment"># +1</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()   <span class="comment"># -1</span></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()   <span class="comment"># -1</span></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()   <span class="comment"># -1</span></span><br><span class="line">q.join()    <span class="comment"># 判断计数器是否为0，不为零则会阻塞</span></span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<ul>
<li>后进先出 (LIFO)</li>
</ul>
<p><code>class queue.LifoQueue(maxsize=0)</code></p>
<p>(1) 实例 1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment"># 栈</span></span><br><span class="line">q = queue.LifoQueue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有计数器进行阻塞  LIFO</span></span><br><span class="line">q.put(<span class="number">1</span>)    <span class="comment"># +1</span></span><br><span class="line">q.put(<span class="number">2</span>)    <span class="comment"># +1</span></span><br><span class="line">q.put(<span class="number">3</span>)    <span class="comment"># +1</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>(2) 实例 2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment"># 栈</span></span><br><span class="line">q = queue.LifoQueue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了计数器进行阻塞的队列  LIFO</span></span><br><span class="line">q.put(<span class="number">1</span>)    <span class="comment"># +1</span></span><br><span class="line">q.put(<span class="number">2</span>)    <span class="comment"># +1</span></span><br><span class="line">q.put(<span class="number">3</span>)    <span class="comment"># +1</span></span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()   <span class="comment"># -1</span></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()   <span class="comment"># -1</span></span><br><span class="line">print(q.get())</span><br><span class="line">q.task_done()   <span class="comment"># -1</span></span><br><span class="line">q.join()    <span class="comment"># 判断计数器是否为0，不为零则会阻塞</span></span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>优先级队列</li>
</ul>
<p><code>class queue.PriorityQueue(maxsize=0)</code></p>
<p> <strong>数字越小优先级越高</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="comment"># 设置优先级的队列</span></span><br><span class="line">q = queue.PriorityQueue()</span><br><span class="line"></span><br><span class="line"><span class="comment"># put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高</span></span><br><span class="line">q.put((<span class="number">20</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">q.put((<span class="number">10</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">q.put((<span class="number">30</span>,<span class="string">&#x27;c&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="comment"># 数字越小优先级越高</span></span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">10</span>, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">(<span class="number">20</span>, <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="e-杀死线程"><a href="#e-杀死线程" class="headerlink" title="(e) 杀死线程"></a>(e) 杀死线程</h3><p>在一些场景下，我们可能需要杀死某个线程，但是在这之前，请仔细的考量代码的上下文环境。强制杀死线程可能会带来一些意想不到的结果，并且从程序设计来讲，这本身就是不合理的。而且，锁资源并不会因为当前线程的退出而释放，这在程序运行过程中，可能会成为典型的死锁场景。所以杀死线程之前，请一定慎重。杀死线程的方法网上有好几种，这里给出一种比较稳妥的方式。</p>
<p>前面我们提到过如何做线程通信，这里可以用全局变量给出一个 flag，线程任务采用循环形式进行，每次循环都会检查该 flag，外界可以通过修改这一 flag 来通知这一线程退出循环，结束任务，从而起到杀死线程的目的，但请注意，为了线程安全，退出前一定要释放这一线程所占用的资源。下面给出一个示例程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock, Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line">lock = Lock()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tar</span>():</span></span><br><span class="line">    <span class="keyword">global</span> flag, lock</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="string">&quot;线程任务逻辑&quot;</span></span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        lock.release()</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    thread = Thread(target=tar)</span><br><span class="line">    thread.start()</span><br><span class="line">    print(<span class="string">&quot;3秒后线程会被杀死&quot;</span>)</span><br><span class="line">    sleep(<span class="number">3</span>)</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    print(<span class="string">&quot;线程已被杀死&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>秒后线程会被杀死</span><br><span class="line">线程已被杀死</span><br></pre></td></tr></table></figure>

<h3 id="f-守护线程"><a href="#f-守护线程" class="headerlink" title="(f) 守护线程"></a>(f) 守护线程</h3><p>无论是进程还是线程，都遵循这样的规则：守护 xx 会等待主 xx 运行完毕后被销毁。需要强调的是：运行完毕并非终止运行。</p>
<ol>
<li>对主进程来说，运行完毕指的是主进程代码运行完毕</li>
<li>对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</li>
</ol>
<h4 id="1-详细解释"><a href="#1-详细解释" class="headerlink" title="(1) 详细解释"></a>(1) 详细解释</h4><ol>
<li>主进程在其代码结束后就已经算运行完毕了 (守护进程在此时就被回收)，然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源 (否则会产生僵尸进程)，才会结束。</li>
<li>主线程在其他非守护线程运行完毕后才算运行完毕 (守护线程在此时就被回收)。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</li>
</ol>
<h4 id="2-守护线程演示"><a href="#2-守护线程演示" class="headerlink" title="(2) 守护线程演示"></a>(2) 守护线程演示</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,enumerate,current_thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">守护线程:</span></span><br><span class="line"><span class="string"> 守护的是进程的运行周期,只要当前进程中一个线程在运行就会守护</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;守护线程开始&#x27;</span>)</span><br><span class="line">    print(current_thread())</span><br><span class="line">    time.sleep(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;子线程 start&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(enumerate())  <span class="comment"># 主线程结束了,但是 守护进程并没有死掉</span></span><br><span class="line">    print(<span class="string">&#x27;子线程 end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=task)</span><br><span class="line">    t2 = Thread(target=task2)</span><br><span class="line">    t1.name = <span class="string">&quot;守护线程&quot;</span></span><br><span class="line">    t2.name = <span class="string">&quot;子线程&quot;</span></span><br><span class="line">    t1.daemon = <span class="literal">True</span>    <span class="comment"># 守护线程</span></span><br><span class="line">    t2.start()</span><br><span class="line">    t1.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">子线程 start</span><br><span class="line">守护线程开始</span><br><span class="line">主线程&lt;Thread(守护线程, started daemon <span class="number">12784</span>)&gt;</span><br><span class="line"></span><br><span class="line">[&lt;_MainThread(MainThread, stopped <span class="number">16096</span>)&gt;, &lt;Thread(子线程, started <span class="number">268</span>)&gt;, &lt;Thread(守护线程, started daemon <span class="number">12784</span>)&gt;]</span><br><span class="line">子线程 end</span><br></pre></td></tr></table></figure>

<h3 id="g-线程定时器-Timer"><a href="#g-线程定时器-Timer" class="headerlink" title="(g) 线程定时器 Timer"></a>(g) 线程定时器 Timer</h3><p>线程定时器就是定时之后开启一条线程，实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">线程定时器,就是规定时间后开启一条线程</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;线程执行了&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;线程结束了&#x27;</span>)</span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">4</span>,task)   <span class="comment"># 间隔时间, 功能函数</span></span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程执行了</span><br><span class="line">线程结束了</span><br></pre></td></tr></table></figure>

<h2 id="B-GIL-全局解释器锁"><a href="#B-GIL-全局解释器锁" class="headerlink" title="(B) GIL 全局解释器锁"></a>(B) GIL 全局解释器锁</h2><h3 id="a-GIL-是什么"><a href="#a-GIL-是什么" class="headerlink" title="(a) GIL 是什么"></a>(a) GIL 是什么</h3><p> GIL 的全称是 Global Interpreter Lock，<strong>全局解释器锁</strong>。 作用就是限制多线程同时执行，保证同一时间内只有一个线程在执行。线程非独立的，所以同一进程里线程是数据共享，当各个线程访问数据资源时会出现“竞争”状态，即数据可能会同时被多个线程占用，造成数据混乱，这就是线程的不安全。所以引进了互斥锁，确保某段关键代码、共享数据只能由一个线程从头到尾完整地执行。</p>
<p> <strong>GIL 并不是 Python 的特性，Python 完全可以不依赖于 GIL。</strong> </p>
<p>那么在这里就反映出一个问题：在我们的 Python 语言中多线程其实是假的多线程，它只会在一个 CPU 上运行。这又是为什么呢？因为在 Python 上开启多个线程，由于 GIL 的存在，每个单独线程都会在竞争到 GIL 后才运行，这样就干预 OS 内部的进程 (线程) 调度，结果在多核 CPU 上：Python 的多线程实际是串行执行的，并不会同一时间多个线程分布在多个 CPU 上运行。</p>
<h3 id="b-为什么会有-GIL"><a href="#b-为什么会有-GIL" class="headerlink" title="(b) 为什么会有 GIL"></a>(b) 为什么会有 GIL</h3><p>Python 为了利用多核 CPU，开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁，于是有了 GIL 这把超级大锁。因为有了 GIL，所以我们的 Python 可以实现多进程，但是这是一个假的多进程，虽然它会利用多个 CPU 共同协作，但实则是利用一个 CPU 的资源。</p>
<p>但是这种 GIL 导致我们的多进程并不是真正的多进程，所以它的效率很低。但当大家试图去拆分和去除 GIL 的时候，发现大量库代码开发者已经重度依赖 GIL 而非常难以去除了。如果推倒重来，多线程的问题依然还是要面对，但是至少会比目前 GIL 这种方式会更优雅。所以简单的说：GIL 的存在更多的是历史原因。</p>
<h3 id="c-GIL-的副作用"><a href="#c-GIL-的副作用" class="headerlink" title="(c) GIL 的副作用"></a>(c) GIL 的副作用</h3><p>Python 的多线程在多核 CPU 上，只对于 IO 密集型计算产生正面效果；而当有至少有一个 CPU 密集型线程存在，那么多线程效率会由于 GIL 而大幅下降。正因为有了 GIL 的存在，我们 Python 的多线程效率才会比较低，毕竟它不是真正的多线程。那么此时，我们就可以考虑使用多进程去实现，因为多进程是可以利用多核的 CPU 资源的。但是又有一个问题，多进程需要的资源较大，明显不是最好的解决办法，那么如何高效的解决这一问题呢？</p>
<p>我们都知道 Python 它其实是一个“胶水”语言，它除了可以调用自己的模块。类库之外，还可以调用 C、C++ 等语言的很多模块、类库。此时，我们只需加载动态库，把多进程这块，换成利用 C 语言去实现就可以了.</p>
<h3 id="d-GIL-小结"><a href="#d-GIL-小结" class="headerlink" title="(d) GIL 小结"></a>(d) GIL 小结</h3><ol>
<li>因为 GIL 的存在，只有 IO Bound 场景下的多线程会得到较好的性能。</li>
<li>如果对并行计算性能较高的程序可以考虑把核心部分也成 C 模块，或者索性用其他语言实现。</li>
<li>GIL 在较长一段时间内将会继续存在，但是会不断对其进行改进。</li>
</ol>
<ul>
<li>经典面试题</li>
</ul>
<p>描述 Python GIL 的概念， 以及它对 Python 多线程的影响？编写一个多线程抓取网页的程序，并阐明多线程抓取程序是否可比单线程性能有提升，并解释原因。 </p>
<p>参考答案：</p>
<ol>
<li>Python 语言和 GIL 没有任何关系。仅仅是由于历史原因在 Cpython 虚拟机 (解释器) 中难以移除 GIL。</li>
<li>GIL：全局解释器锁。每个线程在执行的过程都需要先获取 GIL，保证同一时刻只有一个线程可以执行代码。</li>
<li>线程释放 GIL 锁的情况： 在 IO 操作等可能会引起阻塞的 system call 之前,可以暂时释放 GIL，但在执行完毕后，必须重新获取GIL。Python 3.x 使用计时器 (执行时间达到阈值后，当前线程释放 GIL) 或 Python 2.x tickets 计数达到 100。</li>
<li>Python 使用多进程是可以利用多核的 CPU 资源的。</li>
<li>多线程爬取比单线程性能有提升，因为遇到 IO 阻塞会自动释放 GIL 锁。</li>
</ol>
<h1 id="五-进程池-线程池"><a href="#五-进程池-线程池" class="headerlink" title="五. 进程池/线程池"></a>五. 进程池/线程池</h1><h2 id="A-概述"><a href="#A-概述" class="headerlink" title="(A) 概述"></a>(A) 概述</h2><ul>
<li>池</li>
</ul>
<p>池：池的目的是为了限制进程数和线程数。</p>
<p>何时该用进程池/线程池：当 Python 程序是计算密集型且并发的任务量远大于计算机所能承受的范围，无法一次性开启过多的任务数量就应该考虑使用进程池和线程池。</p>
<ul>
<li>理解同步和异步</li>
</ul>
<p>同步：提交了一个任务，必须等任务执行完了，才能执行下一个。无论该任务是否存在阻塞，同步调用都会原地等待，相当于串行。<br>异步：提交了一个任务，可以不用等任务的执行结果，直接执行下一个，并发地去执行。 </p>
<h2 id="B-multiprocess-Pool-实现进程池"><a href="#B-multiprocess-Pool-实现进程池" class="headerlink" title="(B) multiprocess.Pool 实现进程池"></a>(B) multiprocess.Pool 实现进程池</h2><h3 id="a-语法"><a href="#a-语法" class="headerlink" title="(a) 语法"></a>(a) 语法</h3><p>当被操作对象数目不大时，可以直接利用 multiprocessing 中的 Process 动态生成多个进程，十几个还好，但如果是上百个，上千个目标，手动的去限制进程数量却又太过繁琐，此时可以发挥进程池的功效。</p>
<p>Pool 可以提供指定数量的进程供用户调用，当有新的请求提交到 pool 中时，如果进程池还没有满，那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它。</p>
<p>Python multiprocessing 模块提供了 Pool( ) 函数，专门用来创建一个进程池，该函数的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiprocessing.Pool(processes)</span><br></pre></td></tr></table></figure>

<p>其中，processes 参数用于指定该进程池中包含的进程数。</p>
<p>如果进程是 None，则默认使用 os.cpu_count( ) 返回的数字 (根据本地的 cpu 个数决定，processes 小于等于本地的 cpu 个数)。</p>
<p>请看下面的实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span>(<span class="params">msg</span>):</span></span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">&quot;%s开始执行,进程号为%d&quot;</span> % (msg, os.getpid()))</span><br><span class="line">    <span class="comment"># random.random()随机生成0~1之间的浮点数</span></span><br><span class="line">    time.sleep(random.random()*<span class="number">2</span>)</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(msg, <span class="string">&quot;执行完毕，耗时%0.2f&quot;</span> % (t_stop-t_start))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    po = Pool(<span class="number">3</span>)  <span class="comment"># 定义一个进程池，最大进程数3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">8</span>):</span><br><span class="line">        <span class="comment"># Pool().apply_async(要调用的目标,(传递给目标的参数元祖,))</span></span><br><span class="line">        <span class="comment"># 每次循环将会用空闲出来的子进程去调用目标</span></span><br><span class="line">        po.apply_async(worker, (i,))</span><br><span class="line">    print(<span class="string">&quot;----start----&quot;</span>)</span><br><span class="line">    <span class="comment"># 关闭进程池，关闭后po不再接收新的请求</span></span><br><span class="line">    po.close()</span><br><span class="line">    <span class="comment"># 等待po中所有子进程执行完成，必须放在close语句之后</span></span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">&quot;-----end-----&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">----start----</span><br><span class="line"><span class="number">0</span>开始执行,进程号为<span class="number">5132</span></span><br><span class="line"><span class="number">1</span>开始执行,进程号为<span class="number">14536</span></span><br><span class="line"><span class="number">2</span>开始执行,进程号为<span class="number">13428</span></span><br><span class="line"><span class="number">0</span> 执行完毕，耗时<span class="number">1.03</span></span><br><span class="line"><span class="number">3</span>开始执行,进程号为<span class="number">5132</span></span><br><span class="line"><span class="number">2</span> 执行完毕，耗时<span class="number">1.61</span></span><br><span class="line"><span class="number">4</span>开始执行,进程号为<span class="number">13428</span></span><br><span class="line"><span class="number">1</span> 执行完毕，耗时<span class="number">1.70</span></span><br><span class="line"><span class="number">5</span>开始执行,进程号为<span class="number">14536</span></span><br><span class="line"><span class="number">5</span> 执行完毕，耗时<span class="number">0.50</span></span><br><span class="line"><span class="number">6</span>开始执行,进程号为<span class="number">14536</span></span><br><span class="line"><span class="number">3</span> 执行完毕，耗时<span class="number">1.21</span></span><br><span class="line"><span class="number">7</span>开始执行,进程号为<span class="number">5132</span></span><br><span class="line"><span class="number">4</span> 执行完毕，耗时<span class="number">0.75</span></span><br><span class="line"><span class="number">6</span> 执行完毕，耗时<span class="number">1.40</span></span><br><span class="line"><span class="number">7</span> 执行完毕，耗时<span class="number">1.54</span></span><br><span class="line">-----end-----</span><br></pre></td></tr></table></figure>

<h3 id="b-常用方法"><a href="#b-常用方法" class="headerlink" title="(b) 常用方法"></a>(b) 常用方法</h3><ul>
<li>multiprocessing.Pool 常用方法说明</li>
</ul>
<p><code>apply_async(func[, args[, kwds]])</code> ：使用非阻塞方式调用 func (并行执行，堵塞方式必须等待上一个进程退出才能执行下一个进程)，args 为传递给 func 的参数列表，kwds 为传递给 func 的关键字参数列表。</p>
<p><code>close()</code>：关闭 Pool，使其不再接受新的任务。</p>
<p><code>terminate()</code>：不管任务是否完成，立即终止。</p>
<p><code>join()</code>：主进程阻塞，等待子进程的退出， 必须在 close 或 terminate 之后使用。</p>
<ul>
<li>进程池中的 Queue</li>
</ul>
<p>如果要使用 Pool 创建进程，就需要使用 multiprocessing.Manager( ) 中的 Queue( )，而不是 multiprocessing.Queue( )，否则会得到一条如下的错误信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RuntimeError: Queue objects should only be shared between processes through inheritance.</span><br></pre></td></tr></table></figure>

<p> 下面的实例演示了进程池中的进程如何通信： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager, Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span>(<span class="params">q</span>):</span></span><br><span class="line">    print(<span class="string">&quot;writer启动(%s),父进程为(%s)&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&quot;xiaoming&quot;</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span>(<span class="params">q</span>):</span></span><br><span class="line">    print(<span class="string">&quot;reader启动(%s),父进程为(%s)&quot;</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q.qsize()):</span><br><span class="line">        print(<span class="string">&quot;reader从Queue获取到消息：%s&quot;</span> % q.get(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    print(<span class="string">&quot;(%s) start&quot;</span> % os.getpid())</span><br><span class="line">    <span class="comment"># 使用Manager中的Queue</span></span><br><span class="line">    q = Manager().Queue()</span><br><span class="line">    po = Pool()</span><br><span class="line">    po.apply_async(writer, (q,))</span><br><span class="line">    <span class="comment"># 先让上面的任务向Queue存入数据，然后再让下面的任务开始从中取数据</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    po.apply_async(reader, (q,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">&quot;(%s) End&quot;</span> % os.getpid())</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1080</span>) start</span><br><span class="line">writer启动(<span class="number">14132</span>),父进程为(<span class="number">1080</span>)</span><br><span class="line">reader启动(<span class="number">13916</span>),父进程为(<span class="number">1080</span>)</span><br><span class="line">reader从Queue获取到消息：x</span><br><span class="line">reader从Queue获取到消息：i</span><br><span class="line">reader从Queue获取到消息：a</span><br><span class="line">reader从Queue获取到消息：o</span><br><span class="line">reader从Queue获取到消息：m</span><br><span class="line">reader从Queue获取到消息：i</span><br><span class="line">reader从Queue获取到消息：n</span><br><span class="line">reader从Queue获取到消息：g</span><br><span class="line">(<span class="number">1080</span>) End</span><br></pre></td></tr></table></figure>

<h2 id="C-多进程-多线程实例"><a href="#C-多进程-多线程实例" class="headerlink" title="(C) 多进程/多线程实例"></a>(C) 多进程/多线程实例</h2><p>这里给出了同时往多个文本文件中写入信息的代码实例参考。</p>
<h3 id="a-使用进程池"><a href="#a-使用进程池" class="headerlink" title="(a) 使用进程池"></a>(a) 使用进程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDir</span>():</span></span><br><span class="line">    main_path = <span class="string">r&#x27;E:\testInfo&#x27;</span></span><br><span class="line">    isExists = os.path.exists(main_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(main_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeText</span>(<span class="params">msg, name</span>):</span></span><br><span class="line">    test_info_text_path = <span class="string">r&#x27;E:\testInfo\test_info_&#x27;</span> + name + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> open(test_info_text_path, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        msg_a = msg + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        f1.write(msg_a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myWrite</span>(<span class="params">msg,nums</span>):</span></span><br><span class="line">    po = multiprocessing.Pool()</span><br><span class="line">    names = [<span class="string">&#x27;Xiao_1&#x27;</span>,<span class="string">&#x27;Xiao_2&#x27;</span>,<span class="string">&quot;Xiao_3&quot;</span>,<span class="string">&quot;Xiao_4&quot;</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> names:</span><br><span class="line">        po.apply_async(writeText, args = (msg,i,))</span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line">    print(<span class="string">f&quot;test time <span class="subst">&#123;nums&#125;</span> is finished&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    msg = <span class="string">&#x27;message&#x27;</span></span><br><span class="line">    createDir()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        myWrite(msg,(i+<span class="number">1</span>))</span><br></pre></td></tr></table></figure>

<h3 id="b-使用多进程"><a href="#b-使用多进程" class="headerlink" title="(b) 使用多进程"></a>(b) 使用多进程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDir</span>():</span></span><br><span class="line">    main_path = <span class="string">r&#x27;E:\testInfo&#x27;</span></span><br><span class="line">    isExists = os.path.exists(main_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(main_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeText</span>(<span class="params">msg, name</span>):</span></span><br><span class="line">    test_info_text_path = <span class="string">r&#x27;E:\testInfo\test_info_&#x27;</span> + name + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> open(test_info_text_path, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        msg_a = msg + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        f1.write(msg_a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myWrite</span>(<span class="params">msg</span>):</span></span><br><span class="line">    names = [<span class="string">&#x27;Xiao_1&#x27;</span>,<span class="string">&#x27;Xiao_2&#x27;</span>,<span class="string">&quot;Xiao_3&quot;</span>,<span class="string">&quot;Xiao_4&quot;</span>]</span><br><span class="line">    nums = len(names)</span><br><span class="line">    pro_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nums):</span><br><span class="line">        p = multiprocessing.Process(target=writeText, args=(msg, names[i],))</span><br><span class="line">        p.start()</span><br><span class="line">        pro_list.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nums):</span><br><span class="line">        pro_list[i].join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    msg = <span class="string">&#x27;message&#x27;</span></span><br><span class="line">    createDir()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        myWrite(msg)</span><br><span class="line">        print(<span class="string">f&quot;test time <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> is finished&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="c-使用多线程"><a href="#c-使用多线程" class="headerlink" title="(c) 使用多线程"></a>(c) 使用多线程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time, os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createDir</span>():</span></span><br><span class="line">    main_path = <span class="string">r&#x27;E:\testInfo&#x27;</span></span><br><span class="line">    isExists = os.path.exists(main_path)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        os.makedirs(main_path)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeText</span>(<span class="params">msg, name</span>):</span></span><br><span class="line">    test_info_text_path = <span class="string">r&#x27;E:\testInfo\test_info_&#x27;</span> + name + <span class="string">&#x27;.txt&#x27;</span></span><br><span class="line">    <span class="keyword">with</span> open(test_info_text_path, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">        msg_a = msg + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">        f1.write(msg_a)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myWrite</span>(<span class="params">msg</span>):</span></span><br><span class="line">    names = [<span class="string">&#x27;Xiao_1&#x27;</span>,<span class="string">&#x27;Xiao_2&#x27;</span>,<span class="string">&quot;Xiao_3&quot;</span>,<span class="string">&quot;Xiao_4&quot;</span>]</span><br><span class="line">    nums = len(names)</span><br><span class="line">    pro_list = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nums):</span><br><span class="line">        p = threading.Thread(target=writeText, args=(msg, names[i],))</span><br><span class="line">        p.start()</span><br><span class="line">        pro_list.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nums):</span><br><span class="line">        pro_list[i].join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    msg = <span class="string">&#x27;message&#x27;</span></span><br><span class="line">    createDir()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        myWrite(msg)</span><br><span class="line">        print(<span class="string">f&quot;test time <span class="subst">&#123;i+<span class="number">1</span>&#125;</span> is finished&quot;</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="D-concurrent-futures-实现进程池和线程池"><a href="#D-concurrent-futures-实现进程池和线程池" class="headerlink" title="(D) concurrent.futures 实现进程池和线程池"></a>(D) concurrent.futures 实现进程池和线程池</h2><p>从 Python 3.2 开始，标准库提供了 concurrent.futures 模块，它在 threading 和 multiprocessing 之上的一个通用抽象层，提供了 ThreadPoolExecutor 和 ProcessPoolExecutor 两个类，以便使用线程池/进程池并发/并行地执行任务。</p>
<p>concurrent.futures 模块对外提供了以下常量、函数或类： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">__all__ = (</span><br><span class="line">    <span class="string">&#x27;FIRST_COMPLETED&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;FIRST_EXCEPTION&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ALL_COMPLETED&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;CancelledError&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;TimeoutError&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;BrokenExecutor&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Future&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Executor&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;wait&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;as_completed&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ProcessPoolExecutor&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;ThreadPoolExecutor&#x27;</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="a-Executor"><a href="#a-Executor" class="headerlink" title="(a) Executor"></a>(a) Executor</h3><p><strong>Executor的重要方法</strong><br>ProcessPoolExecutor 和 ThreadPoolExecutor 类中最重要的几个方法如下：</p>
<ul>
<li><code>submit(fn,*args, **kwargs)</code>：提交异步任务 (一般是阻塞的可调用函数)，并返回表示可调用对象执行的 Future 对象 (原文：returns a <code>Future</code> object representing the execution of the callable)；此方法不保存与原始任务相关的任何上下文，如果想把结果和原始任务对应起来，需要自己去追踪它们，比如使用字典推导式；</li>
<li><code>map(fn, *iterables, timeout=None, chunksize=1)</code>：和标准的 map 函数功能类似，同样返回一个迭代器，只不过是以异步的方式把函数依次作用在可迭代对象的每个元素上，注意：如果函数调用引发异常，当从迭代器检索其值时将引发异常，并且不会继续执行；</li>
<li><code>shutdown(wait=True)</code>：通知执行器，当<strong>所有</strong>挂起的 Future 对象执行完成时，释放正在使用的任何资源；在抽象基类中实现了上下文管理器协议，<code>__exit__</code> 方法中调用了 shutdown 方法；</li>
</ul>
<h3 id="b-Future"><a href="#b-Future" class="headerlink" title="(b) Future"></a>(b) Future</h3><p>Futute 类封装可调用对象的异步执行，应由 Executor.submit() 方法创建，可以理解为一个在未来完成的操作。比如说在写爬虫代码时会用到 requests.get ，在等待服务器返回结果之前的这段时间会产生 I/O 阻塞，CPU 不能让出来做其他的事情，Future 的引入就是帮助我们在等待的这段时间可以完成其他的操作。</p>
<p>Futute 类中最重要的几个方法如下：</p>
<ul>
<li><code>result(timeout=None)</code>：返回可调用对象的实际返回值；</li>
<li><code>cancel()</code>：尝试取消 future，如果它正在运行或已经完成，则不能取消，返回 False，若取消成功则返回 True；</li>
<li><code>cancelled()</code>：如果 future 已被取消，则返回 True;</li>
<li><code>running()</code>：如果 future 当前正在运行，则返回 True；</li>
<li><code>done()</code>：如果 future 已被取消或执行完成，则返回 True;</li>
<li><code>add_done_callback(fn)</code>：future 执行完成后，添加回调；</li>
<li><code>exception(timeout=None)</code>：返回 future 执行时所引发的异常；</li>
</ul>
<h3 id="c-wait-和-as-completed"><a href="#c-wait-和-as-completed" class="headerlink" title="(c) wait 和 as_completed"></a>(c) wait 和 as_completed</h3><p>模块下有 2 个重要函数 <code>wait</code> 和 <code>as_completed</code>。</p>
<ul>
<li><p><code>wait(fs, timeout=None, return_when=ALL_COMPLETED)</code></p>
<p>遍历 fs 提供的 future (可能由不同的 Executor 实例创建)，并等待执行完成 (包含已取消)，如果未设置 timeout 参数，则代表不限制等待时间，return_when 参数则用于设置次函数应该在何时返回，支持的选项如下：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>Constant</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>FIRST_COMPLETED</td>
<td>在当有任何future执行完成 (包括已取消) 时返回结果</td>
</tr>
<tr>
<td>FIRST_EXCEPTION</td>
<td>当有任何 future 执行引发异常时返回结果，若没有任何 future 引发异常则等同于 ALL_COMPLETED</td>
</tr>
<tr>
<td>ALL_COMPLETED</td>
<td>当所有 future 执行完成 (包括已取消) 时返回结果</td>
</tr>
</tbody></table>
<p> 该函数返回一个包含两个元素的 namedtuple，定义如下： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DoneAndNotDoneFutures = collections.namedtuple(<span class="string">&#x27;DoneAndNotDoneFutures&#x27;</span>, <span class="string">&#x27;done not_done&#x27;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>as_completed(fs, timeout=None)</code></li>
</ul>
<p>返回一个迭代器，遍历 fs 给出的 future 实例 (可能由不同的执行器实例创建)，在它们执行完成 (包含已取消) 时  yield future。</p>
<h3 id="d-经验技巧"><a href="#d-经验技巧" class="headerlink" title="(d) 经验技巧"></a>(d) 经验技巧</h3><h4 id="1-正确地使用-submit-和-map"><a href="#1-正确地使用-submit-和-map" class="headerlink" title="(1) 正确地使用 submit 和 map"></a>(1) 正确地使用 submit 和 map</h4><p> submit 方法返回的是 Future 对象， map 方法则返回迭代器，如果没有调用 future 对象的 result 方法，即使执行过程中有异常用户也是不知道的，如下所示： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">100</span> // x</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    future1 = executor.submit(f, <span class="number">0</span>)</span><br><span class="line">    future2 = executor.submit(f, <span class="number">10</span>)</span><br><span class="line">    future3 = executor.submit(f, <span class="number">20</span>)</span><br><span class="line">print(future1, future2, future3, sep=<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    futures = executor.map(f, [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>])</span><br><span class="line">print(futures)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Future at <span class="number">0x269d2c8cf40</span> state=finished raised ZeroDivisionError&gt;</span><br><span class="line">&lt;Future at <span class="number">0x269d2f0b700</span> state=finished returned int&gt;</span><br><span class="line">&lt;Future at <span class="number">0x269d2f0be20</span> state=finished returned int&gt;</span><br><span class="line">&lt;generator object Executor.map.&lt;locals&gt;.result_iterator at <span class="number">0x00000269D2EAE7A0</span>&gt;</span><br></pre></td></tr></table></figure>

<p> 所以通常需要调用其 result 方法并且捕捉异常： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">100</span> // x</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line">    future1 = executor.submit(f, <span class="number">0</span>)</span><br><span class="line">    future2 = executor.submit(f, <span class="number">0</span>)</span><br><span class="line">    future3 = executor.submit(f, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">todos = [future1, future2, future3]</span><br><span class="line"><span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(todos):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(future.result())</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        print(e.__repr__())</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">ZeroDivisionError(<span class="string">&#x27;integer division or modulo by zero&#x27;</span>)</span><br><span class="line">ZeroDivisionError(<span class="string">&#x27;integer division or modulo by zero&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>相对于 submit，map 方法的结果就比较难获取了，这是因为 map 方法以异步的方式把函数依次作用在可迭代对象的每个元素上，如果在函数调用时引发了一些异常，当从迭代器检索其值时就将引发异常，因此需要使用下面的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"></span><br><span class="line">f = <span class="keyword">lambda</span> x: <span class="number">100</span> // x</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">3</span>) <span class="keyword">as</span> executor:</span><br><span class="line"><span class="comment"># If a func call raises an exception, then that exception will be raised when its value is retrieved from the iterator.</span></span><br><span class="line">    futures = executor.map(f, [<span class="number">0</span>, <span class="number">10</span>, <span class="number">20</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        future = futures.__next__()</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError <span class="keyword">as</span> e:</span><br><span class="line">        print(e.__repr__())</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZeroDivisionError(<span class="string">&#x27;integer division or modulo by zero&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，当第一次错误发生后生成器迭代就结束了，所以一批任务中可能会出现异常时是不合适用 map 方法的，最好的方式还是使用 submit+as_completed。在一些较为简单的场景下，如果不需要关心任务的返回值，则可以考虑使用 map 方法。</p>
<h4 id="2-寻找合适的-max-worker"><a href="#2-寻找合适的-max-worker" class="headerlink" title="(2) 寻找合适的 max_worker"></a>(2) 寻找合适的 max_worker</h4><p>使用 ThreadPoolExecutor，虽然线程的数量可以自定义，但并不是越多越好，因为线程的创建、维护和删除也会有一定的开销。所以如果设置的很大，反而可能会导致速度变慢，比如下面的例子，把线程数从 5 改为 10，运行程序会发现耗时反而增多了。所以在实际开发过程中，往往需要根据实际的需要去做一些测试，在任务不影响到全局的情况下，寻找最优的线程数量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_all</span>(<span class="params">urls: list</span>):</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        executor.map(download_one, urls)</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br><span class="line">    </span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">...</span><br><span class="line">Download <span class="number">30</span> urls <span class="keyword">in</span> <span class="number">0.9526623</span> seconds</span><br></pre></td></tr></table></figure>

<p>注，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max_workers有默认值，等于：min(<span class="number">32</span>, (os.cpu_count() <span class="keyword">or</span> <span class="number">1</span>) + <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<h4 id="3-避免死锁"><a href="#3-避免死锁" class="headerlink" title="(3) 避免死锁"></a>(3) 避免死锁</h4><p>使用 ThreadPoolExecutor 时可能出现的死锁情况，当与 Future 关联的可调用函数等待另一个 Future 的结果时，它们可能永远不会释放对线程的控制并导致死锁，官网的示例如下： </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_b</span>():</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(b.result())  <span class="comment"># b will never complete because it is waiting on a.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">wait_on_a</span>():</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(a.result())  <span class="comment"># a will never complete because it is waiting on b.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">6</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">executor = ThreadPoolExecutor(max_workers=<span class="number">2</span>)</span><br><span class="line">a = executor.submit(wait_on_b)</span><br><span class="line">b = executor.submit(wait_on_a)</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，函数 wait_on_b 依赖于函数 wait_on_a 的结果 (Future 对象的结果)，同时后一个函数的结果依赖于前一个函数的结果。因此，上下文管理器中的代码块永远不会执行，因为它具有相互依赖性，这就造成了死锁。</p>
<h3 id="e-简单使用场景"><a href="#e-简单使用场景" class="headerlink" title="(e) 简单使用场景"></a>(e) 简单使用场景</h3><p>使用多线程从 url 下载和保存文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> concurrent.futures</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"><span class="keyword">import</span> requests, time</span><br><span class="line"></span><br><span class="line">htmls_dir = Path(__file__).parent.joinpath(<span class="string">&#x27;htmls&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> htmls_dir.exists():</span><br><span class="line">    os.makedirs(htmls_dir)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">for</span> html <span class="keyword">in</span> htmls_dir.glob(<span class="string">&quot;*.html&quot;</span>):</span><br><span class="line">        os.remove(html)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_one</span>(<span class="params">url</span>):</span></span><br><span class="line">    resp = requests.get(url)</span><br><span class="line">    resp.encoding = <span class="string">&#x27;utf-8&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> resp.text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save</span>(<span class="params">source, html, chunk=<span class="number">8</span> * <span class="number">1024</span></span>):</span></span><br><span class="line">    <span class="keyword">with</span> open(source, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&quot;utf-8&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">        <span class="keyword">for</span> text <span class="keyword">in</span> (html[i:chunk + i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(html), chunk)):</span><br><span class="line">            fp.write(text)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_all</span>(<span class="params">urls</span>):</span></span><br><span class="line">    <span class="keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="number">5</span>) <span class="keyword">as</span> executor:</span><br><span class="line">        futures = &#123;executor.submit(download_one, url): url[<span class="number">-7</span>:] <span class="keyword">for</span> url <span class="keyword">in</span> urls&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> concurrent.futures.as_completed(futures):</span><br><span class="line">        source = htmls_dir.joinpath(futures[future]).with_suffix(<span class="string">&#x27;.html&#x27;</span>)</span><br><span class="line">        save(source, future.result())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>():</span></span><br><span class="line">    urls = [<span class="string">f&quot;https://www.sogou.com/web?query=<span class="subst">&#123;i&#125;</span>&quot;</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>)]</span><br><span class="line">    start_time = time.perf_counter()</span><br><span class="line">    download_all(urls)</span><br><span class="line">    end_time = time.perf_counter()</span><br><span class="line">    elapsed_time = end_time - start_time</span><br><span class="line">    print(<span class="string">f&#x27;Download <span class="subst">&#123;len(urls)&#125;</span> urls in <span class="subst">&#123;elapsed_time&#125;</span> seconds&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h1 id="六-协程"><a href="#六-协程" class="headerlink" title="六. 协程"></a>六. 协程</h1><h2 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="(A) 概述"></a>(A) 概述</h2><ul>
<li>什么是协程</li>
</ul>
<p><strong>协程:</strong> 就是<strong>单线程</strong>下<strong>实现并发</strong></p>
<p>协程概念本质是程序员抽象出来的，是人为的控制通过程序的 IO 去进行切换任务的执行</p>
<p>并发：任务切换+保存状态</p>
<ul>
<li><p>为什么要有协程</p>
<p>自己控制切换要比操作系统切换快的多，降低了单个线程的 IO 堵塞时间，也就是实现了单线程下效率最高.。</p>
</li>
<li><p>协程的优缺点</p>
</li>
</ul>
<p>优点： 自己控制切换要比操作系统切换快的多 </p>
<p>缺点：需要自己要检测所有的 IO，但凡有一个阻塞整体都跟着阻塞；无法利用多核优势。</p>
<ul>
<li>如何实现协程</li>
</ul>
<p>其实协程的本质就是在单线程下实现并发，也就是通过生成器 yield 和 next 进行迭代生成器，实现切换任务和保存任务。在 Python 中我们可以使用 gevent 模块来实现协程。</p>
<h2 id="B-Gevent-模块"><a href="#B-Gevent-模块" class="headerlink" title="(B) Gevent 模块"></a>(B) Gevent 模块</h2><h3 id="a-概述-1"><a href="#a-概述-1" class="headerlink" title="(a) 概述"></a>(a) 概述</h3><p>Gevent 是一个第三方库，可以轻松通过 gevent 实现并发同步或异步编程，在 gevent 中用到的主要模式是 Greenlet，它是以 C 扩展模块形式接入 Python 的轻量级协程。 Greenlet 全部运行在主程序操作系统进程的内部，但它们被协作式地调度。 </p>
<p><code>g1=gevent.spawn(func,1,,2,3,x=4,y=5)</code>：创建一个协程对象 g1，spawn 括号内第一个参数是函数名，如 eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数 eat 的 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g1=gevent.spawn(func,<span class="number">1</span>,,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>)</span><br><span class="line">g2=gevent.spawn(func2)</span><br></pre></td></tr></table></figure>

<p><code>g1.join()</code>：等待 g1 结束</p>
<p><code>g2.join()</code>：等待 g2 结束</p>
<p>上述两步合作一步：<code>gevent.joinall([g1,g2])</code></p>
<p><code>g1.value</code>：拿到 func1 的返回值</p>
<h3 id="b-代码实例"><a href="#b-代码实例" class="headerlink" title="(b) 代码实例"></a>(b) 代码实例</h3><h4 id="1-实例-1-1"><a href="#1-实例-1-1" class="headerlink" title="(1) 实例 1"></a>(1) 实例 1</h4><p>通过 <strong>from gevent import monkey;</strong> <strong>monkey.patch_all()</strong> 去补丁，捕获所有 IO，<code>from gevent import monkey;monkey.patch_all()</code> 必须放到被打补丁者的前面，如 time，socket 模块之前。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;打了一个补丁,它可以实现捕获非gevent的所有io&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;eat 1&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># gevent.sleep(2)   # 可以这样单独捕捉阻塞，但是太麻烦，所以直接打补丁，捕捉运行期间的全部IO</span></span><br><span class="line">    print(<span class="string">&#x27;eat 2&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;play 1&#x27;</span>)</span><br><span class="line">    <span class="comment"># 疯狂的计算呢没有io</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># gevent.sleep(3)   # 可以这样单独捕捉阻塞，但是太麻烦，所以直接打补丁，捕捉运行期间的全部IO</span></span><br><span class="line">    print(<span class="string">&#x27;play 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">gevent实现协程的模块，它可以捕获单线程中的io并去切换任务</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 把本该串行的代码通过协程完成单线程并行</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    g1 = gevent.spawn(eat)      <span class="comment"># 创建一个协程对象</span></span><br><span class="line">    g2 = gevent.spawn(play)</span><br><span class="line">    <span class="comment"># g1.join() # 等待回收协程对象</span></span><br><span class="line">    <span class="comment"># g2.join()</span></span><br><span class="line">    gevent.joinall([g1,g2])     <span class="comment"># 把上面两步并一步</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    print(end-start)</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eat <span class="number">1</span></span><br><span class="line">play <span class="number">1</span></span><br><span class="line">eat <span class="number">2</span></span><br><span class="line">play <span class="number">2</span></span><br><span class="line"><span class="number">3.0253946781158447</span></span><br></pre></td></tr></table></figure>

<h4 id="2-实例-2"><a href="#2-实例-2" class="headerlink" title="(2) 实例 2"></a>(2) 实例 2</h4><p>通过 gevent 实现单线程下的 socket 并发</p>
<p>注意：<strong>from gevent import monkey;monkey.patch_all() 一定要放到导入 socket 模块之前，否则 gevent 无法识别 socket 的阻塞。</strong></p>
<p>服务器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey; monkey.patch_all()   <span class="comment"># 打补丁</span></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">基于协程的socket通讯</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">协程：单线程下实现并发</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connec_interface</span>(<span class="params">conn,addr</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            print(<span class="string">f&quot;来自<span class="subst">&#123;addr&#125;</span>的消息：&quot;</span>,data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">            data = input(<span class="string">f&quot;与<span class="subst">&#123;addr&#125;</span>聊天&quot;</span>)</span><br><span class="line">            conn.send(data.encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">    server.bind((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>))</span><br><span class="line">    server.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">&quot;等待连接。。。&quot;</span>)</span><br><span class="line">        conn,addr = server.accept()</span><br><span class="line">        print(<span class="string">&quot;连接成功&quot;</span>)</span><br><span class="line">        gevent.spawn(connec_interface, conn, addr)  <span class="comment"># 创建一个协程对象</span></span><br></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    msg = input(<span class="string">&quot;请输入内容&quot;</span>)</span><br><span class="line">    client.send(msg.encode(<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    data = client.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(data.decode(<span class="string">&quot;utf8&quot;</span>))</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/28/python-06/" rel="prev" title="Python学习笔记(零六)：Tkinter的简单实例">
      <i class="fa fa-chevron-left"></i> Python学习笔记(零六)：Tkinter的简单实例
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/10/30/data-structure-01/" rel="next" title="数据结构和算法(零一)：数据结构·算法·复杂度">
      数据结构和算法(零一)：数据结构·算法·复杂度 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minwei Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
