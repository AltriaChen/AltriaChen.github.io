<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="本篇介绍了树，包括普通树，二叉树，线索二叉树，Huffman 树的相关定义及算法。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构和算法(零六)：树">
<meta property="og:url" content="http://yoursite.com/2020/11/22/data-structure-06/index.html">
<meta property="og:site_name" content="Cross Code">
<meta property="og:description" content="本篇介绍了树，包括普通树，二叉树，线索二叉树，Huffman 树的相关定义及算法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2101.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2102.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2103.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2104.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2105.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2106.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2107.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2108.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2109.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2109.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2110.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2111.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2112.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2118.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2113.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2114.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2115.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2116.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2117.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2119.jpg">
<meta property="article:published_time" content="2020-11-22T01:45:32.000Z">
<meta property="article:modified_time" content="2021-05-30T15:05:56.136Z">
<meta property="article:author" content="Minwei Chen">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2101.jpg">

<link rel="canonical" href="http://yoursite.com/2020/11/22/data-structure-06/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构和算法(零六)：树 | Cross Code</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cross Code</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">There is only one heroism in the world: to see the world as it is and to love it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E6%A0%91"><span class="nav-text">一. 树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%AE%80%E4%BB%8B"><span class="nav-text">(A) 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89"><span class="nav-text">(a) 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E7%BB%93%E7%82%B9"><span class="nav-text">(b) 结点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">(B) 树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">(a) 双亲表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="nav-text">(1) 基本结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%94%B9%E8%BF%9B%EF%BC%9A%E6%96%B9%E4%BE%BF%E5%AF%BB%E6%89%BE%E5%AD%A9%E5%AD%90%E7%BB%93%E7%82%B9"><span class="nav-text">(2) 改进：方便寻找孩子结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%94%B9%E8%BF%9B%EF%BC%9A%E6%96%B9%E4%BE%BF%E5%AF%BB%E6%89%BE%E5%85%84%E5%BC%9F%E7%BB%93%E7%82%B9"><span class="nav-text">(3) 改进：方便寻找兄弟结点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">(b) 孩子表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%8F%8C%E4%BA%B2%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">(c) 双亲孩子表示法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">(d) 代码实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8F%8C%E4%BA%B2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">(1) 双亲表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%8C%E4%BA%B2%E5%AD%A9%E5%AD%90%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-text">(2) 双亲孩子表示法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">二. 二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%AE%80%E4%BB%8B-1"><span class="nav-text">(A) 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%89%B9%E6%AE%8A%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">(B) 特殊二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">(a) 满二叉树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">(b) 完全二叉树</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">(C) 二叉树的性质</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-text">(D) 二叉树的存储结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-text">(a) 顺序存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-text">(b) 链式存储</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">(E) 二叉树的遍历</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E9%81%8D%E5%8E%86%E6%96%B9%E5%BC%8F"><span class="nav-text">(a) 遍历方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">(1) 前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">(2) 中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">(3) 后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">(4) 层序遍历</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%9E%E4%BE%8B"><span class="nav-text">(b) 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#F-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-text">(F) 二叉树的建立和遍历算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G-%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-text">(G) 树与森林的遍历</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">三. 线索二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%AE%80%E4%BB%8B-2"><span class="nav-text">(A) 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">(B) 代码实现</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="nav-text">四. 树的转换</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E6%99%AE%E9%80%9A%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">(A) 普通树转换为二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%A3%AE%E6%9E%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-text">(B) 森林转换为二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91"><span class="nav-text">(C) 二叉树转换为树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A3%AE%E6%9E%97"><span class="nav-text">(D) 二叉树转换为森林</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-Huffman-Tree"><span class="nav-text">五. Huffman Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%AE%80%E4%BB%8B-3"><span class="nav-text">(A) 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%9E%84%E9%80%A0-Huffman-Tree"><span class="nav-text">(B) 构造 Huffman Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E7%AE%97%E6%B3%95%E8%BF%87%E7%A8%8B"><span class="nav-text">(a) 算法过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%9E%E4%BE%8B-1"><span class="nav-text">(b) 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">(c) 代码实现</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minwei Chen"
      src="/images/tuoqi.jpg">
  <p class="site-author-name" itemprop="name">Minwei Chen</p>
  <div class="site-description" itemprop="description">Cross the surface, get to the reality. Welcome to Cross Code!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AltriaChen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AltriaChen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mwchennju@foxmail.com" title="E-Mail → mailto:mwchennju@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/11/22/data-structure-06/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tuoqi.jpg">
      <meta itemprop="name" content="Minwei Chen">
      <meta itemprop="description" content="Cross the surface, get to the reality. Welcome to Cross Code!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cross Code">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构和算法(零六)：树
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-22 09:45:32" itemprop="dateCreated datePublished" datetime="2020-11-22T09:45:32+08:00">2020-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-30 23:05:56" itemprop="dateModified" datetime="2021-05-30T23:05:56+08:00">2021-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇介绍了树，包括普通树，二叉树，线索二叉树，Huffman 树的相关定义及算法。</p>
<a id="more"></a>

<h1 id="一-树"><a href="#一-树" class="headerlink" title="一. 树"></a>一. 树</h1><h2 id="A-简介"><a href="#A-简介" class="headerlink" title="(A) 简介"></a>(A) 简介</h2><h3 id="a-定义"><a href="#a-定义" class="headerlink" title="(a) 定义"></a>(a) 定义</h3><ul>
<li><p>树 (Tree) 是 n(n&gt;=0) 个结点的有限集。当 n=0 时成为空树，在任意一棵非空树中：<br>– 有且仅有一个特定的称为根 (Root) 的结点；<br>– 当 n&gt;1 时，其余结点可分为 m(m&gt;0) 个互不相交的有限集 T1，T2，···，Tm，其中每一个集合本身又是一棵树，并且称为根的子树 (SubTree)。<br><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2101.jpg"></p>
</li>
<li><p>虽然从概念上很容易理解树，但是有两点还是需要注意下：<br>– n&gt;0 时，根结点是唯一的，坚决不可能存在多个根节点。<br>– m&gt;0 时，子树的个数是没有限制的，但它们互相是一定不会相交的。</p>
</li>
</ul>
<h3 id="b-结点"><a href="#b-结点" class="headerlink" title="(b) 结点"></a>(b) 结点</h3><ul>
<li>(1) 上面的树的示意图中，每一个圈圈我们就称为树的一个结点。结点拥有的子树数称为结点的度 (Degree)，树的度取树内各结点的度的最大值。<br>– 度为 0 的结点称为叶结点 (Leaf) 或终端结点；<br>– 度不为 0 的结点称为分支结点或非终端结点，除根结点外，分支结点也称为内部结点。<br>(2) 结点的子树的根称为结点的孩子 (Child)，相应的，该结点称为孩子的双亲 (Parent)，同一双亲的孩子之间互称为兄弟 (Sibling)。<br>(3) 结点的祖先是从根到该结点所经分支上的所有结点。</li>
<li>(1) 结点的层次 (Level) 从根开始算起，根为第一层，根的孩子为第二层。其双亲在同一层的结点互为堂兄弟。<br>(2) 树中结点的最大层次称为树的深度 (Depth) 或高度。<br>(3) 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。<br>(4) 森林 (Forest) 是 m(m&gt;0) 棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。</li>
</ul>
<h2 id="B-树的存储结构"><a href="#B-树的存储结构" class="headerlink" title="(B) 树的存储结构"></a>(B) 树的存储结构</h2><p>要存储树，简单的顺序存储结构和链式存储结构是不能滴！不过如果充分利用它们各自的特点，完全可以间接地来实现。这里要介绍三种不同的表示法：双亲表示法，孩子表示法，孩子兄弟表示法。</p>
<h3 id="a-双亲表示法"><a href="#a-双亲表示法" class="headerlink" title="(a) 双亲表示法"></a>(a) 双亲表示法</h3><h4 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="(1) 基本结构"></a>(1) 基本结构</h4><ul>
<li><p>双亲表示法，就是以双亲作为索引的关键词的一种存储方式。我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示其双亲结点在数组中位置的元素。<br>图解为<br><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2102.jpg">另有，根的位置 r=0，结点数目 n=11。</p>
</li>
<li><p>这样的存储结构，我们可以根据某结点的 parent 指针找到他的双亲结点，所用的时间复杂度是 O(1)，索引到 parent 的值为 -1 时，表示找到了树结点的根。但是，如果我们想知道某结点的孩子是什么，就要遍历整个树结构，比较麻烦。</p>
</li>
</ul>
<h4 id="2-改进：方便寻找孩子结点"><a href="#2-改进：方便寻找孩子结点" class="headerlink" title="(2) 改进：方便寻找孩子结点"></a>(2) 改进：方便寻找孩子结点</h4><p>为方便寻找孩子结点，在结构中加入两个 int 索引 child1 和 child2</p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2103.jpg"></p>
<h4 id="3-改进：方便寻找兄弟结点"><a href="#3-改进：方便寻找兄弟结点" class="headerlink" title="(3) 改进：方便寻找兄弟结点"></a>(3) 改进：方便寻找兄弟结点</h4><p>为方便寻找兄弟结点，在结构设计时，加入 int 索引 rightSib<br><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2104.jpg"></p>
<h3 id="b-孩子表示法"><a href="#b-孩子表示法" class="headerlink" title="(b) 孩子表示法"></a>(b) 孩子表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表来实现，这里我们给出三个参考方案。</p>
<ul>
<li>方案一<br>根据树的度，声明足够空间存放子树指针的结点。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2105.jpg"></p>
<p>缺点十分明显，就是造成了浪费。</p>
<ul>
<li>方案二<br>针对方案一的缺点，我们在 data 后添加一个 int 索引指示存放的地址数。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2106.jpg"></p>
<ul>
<li>方案三<br>进一步改进</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2107.jpg"></p>
<h3 id="c-双亲孩子表示法"><a href="#c-双亲孩子表示法" class="headerlink" title="(c) 双亲孩子表示法"></a>(c) 双亲孩子表示法</h3><p>结合双亲表示法和孩子表示法，图解为</p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2108.jpg"></p>
<h3 id="d-代码实现"><a href="#d-代码实现" class="headerlink" title="(d) 代码实现"></a>(d) 代码实现</h3><h4 id="1-双亲表示法"><a href="#1-双亲表示法" class="headerlink" title="(1) 双亲表示法"></a>(1) 双亲表示法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的双亲表示法 结点结构定义</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//双亲结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span> //定义树中的一个结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r;                <span class="comment">//根的位置索引</span></span><br><span class="line">    <span class="keyword">int</span> n;                <span class="comment">//树中结点的总数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure>

<h4 id="2-双亲孩子表示法"><a href="#2-双亲孩子表示法" class="headerlink" title="(2) 双亲孩子表示法"></a>(2) 双亲孩子表示法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的双亲孩子表示法 结点结构定义</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElemType;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//孩子结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span>     //定义树中的一个结点</span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">int</span> child;            <span class="comment">//孩子结点的下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个孩子结点的指针</span></span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//表头结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;        <span class="comment">//存放树中结点的数据</span></span><br><span class="line">    <span class="keyword">int</span> parent;           <span class="comment">//存放双亲下标</span></span><br><span class="line">    ChildPtr firstchild;  <span class="comment">//指向第一个孩子的指针</span></span><br><span class="line">&#125;CTBox;</span><br><span class="line"></span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CTBox nodes[MAX_TREE_SIZE];</span><br><span class="line">    <span class="keyword">int</span> r;                <span class="comment">//根的位置索引</span></span><br><span class="line">    <span class="keyword">int</span> n;                <span class="comment">//树中结点的总数</span></span><br><span class="line">&#125;PCTree;</span><br></pre></td></tr></table></figure>

<h1 id="二-二叉树"><a href="#二-二叉树" class="headerlink" title="二. 二叉树"></a>二. 二叉树</h1><h2 id="A-简介-1"><a href="#A-简介-1" class="headerlink" title="(A) 简介"></a>(A) 简介</h2><ul>
<li>定义<br>二叉树 (Binary Tree) 是 n(n&gt;=0) 个结点的有限集合，该集合或者为空集(空二叉树)，或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</li>
<li>特点<br>(1) 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。<br>(2) 左子树和右子树是有顺序的，次序不能颠倒。<br>(3) 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</li>
<li>二叉树的五种基本形态<br>空二叉树，只有一个根结点，根结点只有左子树，根结点只有右子树，根结点既有左子树又有右子树</li>
</ul>
<h2 id="B-特殊二叉树"><a href="#B-特殊二叉树" class="headerlink" title="(B) 特殊二叉树"></a>(B) 特殊二叉树</h2><h3 id="a-满二叉树"><a href="#a-满二叉树" class="headerlink" title="(a) 满二叉树"></a>(a) 满二叉树</h3><ul>
<li>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2109.jpg"></p>
<ul>
<li>满二叉树的特点有：<br>– 叶子只能出现在最下一层。<br>– 非叶子结点的度一定是 2。<br>– 在同样深度的二叉树中，满二叉树的结点个数一定最多，同时叶子也是最多。</li>
</ul>
<h3 id="b-完全二叉树"><a href="#b-完全二叉树" class="headerlink" title="(b) 完全二叉树"></a>(b) 完全二叉树</h3><ul>
<li>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i(1&lt;=i&lt;=n) 的结点与同样深度的满二叉树中编号为 i 的结点位置完全相同，则这棵二叉树称为完全二叉树。</li>
<li>完全二叉树的特点有：<br>– 叶子结点只能出现在最下两层。<br>– 最下层的叶子一定集中在左部连续位置。<br>– 倒数第二层，若有叶子结点，一定都在右部连续位置。<br>– 如果结点度为1，则该结点只有左孩子。<br>– 同样结点树的二叉树，完全二叉树的深度最小。</li>
<li>注意：满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树。</li>
</ul>
<h2 id="C-二叉树的性质"><a href="#C-二叉树的性质" class="headerlink" title="(C) 二叉树的性质"></a>(C) 二叉树的性质</h2><ul>
<li>二叉树的性质一：在二叉树的第 <code>i</code> 层上至多有 <code>2^(i-1)</code> 个结点 <code>(i&gt;=1)</code></li>
<li>二叉树的性质二：深度为 <code>k</code> 的二叉树至多有 <code>2^k - 1</code> 个结点</li>
<li>二叉树的性质三：对任何一棵二叉树 T，如果其终端结点数为 <code>n0</code>，度为 2 的结点数为 <code>n2</code>，则 <code>n0=n2+1</code>。证明过程为：<br>– 首先我们再假设度为 1 的结点数为 <code>n1</code>，则二叉树 T 的结点总数 <code>n=n0+n1+n2</code><br>– 其次我们发现连接数总是等于总结点数 <code>n-1</code>，并且等于 <code>n1+2*n2</code><br>– 所以 <code>n-1=n1+2*n2</code><br>– 所以 <code>n0+n1+n2-1=n1+n2+n2</code><br>– 最后 <code>n0=n2+1</code></li>
<li>二叉树的性质四：具有 <code>n</code> 个结点的完全二叉树的深度 <code>k</code> 满足 <code>k-1&lt;=log2(n)&lt;k</code>  (log 以 2 为底 n 的对数)。证明过程为：<br>– 由满二叉树的定义结合性质二可知，深度为 <code>k</code> 的满二叉树的结点数 <code>n</code> 一定是 <code>2^k - 1</code><br>– 那么对于满二叉树我们可以通过 <code>n=2^k - 1</code> 倒推得到满二叉树的深度为 <code>k=log2(n+1)</code><br>– 由于完全二叉树前边我们已经提到，它的叶子结点只会出现在最下面的两层，可以同样如下推导。对于倒数第二层的满二叉树我们同样很容易回推出它的结点数为 <code>n=2^(k-1)-1</code><br>– 所以完全二叉树的结点数的取值范围是：<code>2^(k-1)-1&lt;n&lt;=2^k-1</code><br>– 由于 <code>n</code> 是整数，<code>n&lt;=2^k-1</code> 可以看成 <code>n&lt;2^k</code><br>– 同理 <code>2^(k-1)-1&lt;n</code> 可以看成 <code>2^(k-1)&lt;=n</code><br>– 所以 <code>2^(k-1)&lt;=n&lt;2^k</code><br>– 最后不等式两边同时取对数，得到 <code>k-1&lt;=log2(n)&lt;k</code></li>
<li>二叉树的性质五：如果对一棵有 <code>n</code> 个结点的完全二叉树(其深度 <code>k</code> 满足 <code>k-1&lt;=log2(n)&lt;k</code>)的结点按层序编号，对任一结点 <code>i</code>(<code>1&lt;=i&lt;=n</code>)有以下性质：<br>– 如果 <code>i=1</code>，则结点 <code>i</code> 是二叉树的根，无双亲；如果 <code>i&gt;1</code>，则其双亲结点是 <code>i/2 取下限</code>。<br>– 如果 <code>2i&gt;n</code>，则结点 <code>i</code> 无左孩子(结点 <code>i</code> 为叶子结点)；否则其左孩子是结点 <code>2i</code>。<br>– 如果 <code>2i+1&gt;n</code>，则结点 <code>i</code> 无右孩子；否则其右孩子是结点 <code>2i+1</code>。</li>
</ul>
<h2 id="D-二叉树的存储结构"><a href="#D-二叉树的存储结构" class="headerlink" title="(D) 二叉树的存储结构"></a>(D) 二叉树的存储结构</h2><h3 id="a-顺序存储"><a href="#a-顺序存储" class="headerlink" title="(a) 顺序存储"></a>(a) 顺序存储</h3><ul>
<li>二叉树的顺序存储，就是用一组连续的存储单元存放二叉树中的结点。因此，必须把二叉树的所有结点安排成为一个恰当的序列，结点在这个序列中的相互位置能反映出结点之间的逻辑关系，用编号的方法从树根起，自上层至下层，每层自左至右地给所有结点编号，缺点是有可能对存储空间造成极大的浪费，在最坏的情况下，一个深度为 k 且只有 k 个结点的右单支树需要 2k-1 个结点存储空间。</li>
<li>依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中结点的序号可以唯一地反映出结点之间的逻辑关系，这样既能够最大可能地节省存储空间，又可以利用数组元素的下标值确定结点在二叉树中的位置，以及结点之间的关系。</li>
<li>对于一般的二叉树，如果仍按从上至下和从左至右的顺序将树中的结点顺序存储在一维数组中，则数组元素下标之间的关系不能够反映二叉树中结点之间的逻辑关系，只有增添一些并不存在的空结点，使之成为一棵完全二叉树的形式，然后再用一维数组顺序存储。显然，这种存储对于需增加许多空结点才能将一棵二叉树改造成为一棵完全二叉树的存储时，会造成空间的大量浪费，不宜采用顺序存储结构。最坏的情况是右单支树，只有 k 个结点，却需分配 2k-1 个存储单元。</li>
</ul>
<p>例<br><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2109.jpg"></p>
<table>
<thead>
<tr>
<th>元素</th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>F</th>
<th>G</th>
</tr>
</thead>
<tbody><tr>
<td>下标</td>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody></table>
<h3 id="b-链式存储"><a href="#b-链式存储" class="headerlink" title="(b) 链式存储"></a>(b) 链式存储</h3><ul>
<li>既然顺序存储方式的适用性不强，那么我们就要考虑链式存储结构啦。<br>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。通常的方法是链表中每个结点由三个域组成，数据域和左右指针域，左右指针分别用来给出该结点左孩子和右孩子所在的链结点的存储位置。其结点结构为：</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2110.jpg"></p>
<p>其中，data 域存放某结点的数据信息，lchild 和 rchild 分别存放指向左孩子和右孩子的指针，当左孩子或右孩子不存在时，相应指针域值为空(用符号 ^ 或 NULL 表示)。利用这样的结点结构表示的二叉树的链式存储结构被称为二叉链表。</p>
<ul>
<li>以下是我们的二叉链表结点结构的定义代码</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>

<h2 id="E-二叉树的遍历"><a href="#E-二叉树的遍历" class="headerlink" title="(E) 二叉树的遍历"></a>(E) 二叉树的遍历</h2><p>二叉树的遍历 (traversing binary tree) 是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。<br>二叉树的遍历方式可以很多，如果我们限制了从左到右的习惯方式，那么主要就分为以下四种：前序遍历，中序遍历，后序遍历，层序遍历。</p>
<h3 id="a-遍历方式"><a href="#a-遍历方式" class="headerlink" title="(a) 遍历方式"></a>(a) 遍历方式</h3><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="(1) 前序遍历"></a>(1) 前序遍历</h4><p>前序遍历首先访问根结点，然后遍历左子树，最后遍历右子树。在遍历左、右子树时，仍然先访问根结点，然后遍历左子树，最后遍历右子树。<br>算法流程为，若二叉树为空则结束返回，否则：<br>(1) 访问根结点；(2) 前序遍历左子树；(3) 前序遍历右子树。<br>需要注意的是，遍历左右子树时仍然采用前序遍历方法。</p>
<h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="(2) 中序遍历"></a>(2) 中序遍历</h4><p>中序遍历首先遍历左子树，然后访问根结点，最后遍历右子树。<br>算法流程为，若二叉树为空则结束返回，否则：<br>(1) 中序遍历左子树；(2) 访问根结点；(3) 中序遍历右子树。</p>
<h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="(3) 后序遍历"></a>(3) 后序遍历</h4><p>后序遍历首先遍历左子树，然后遍历右子树，最后访问根结点。在遍历左、右子树时，仍然先遍历左子树，然后遍历右子树，最后访问根结点。<br>算法流程为，若二叉树为空则结束返回，否则：<br>(1) 后序遍历左子树；(2) 后序遍历右子树；(3) 访问根结点。</p>
<h4 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="(4) 层序遍历"></a>(4) 层序遍历</h4><p>若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
<h3 id="b-实例"><a href="#b-实例" class="headerlink" title="(b) 实例"></a>(b) 实例</h3><p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2111.jpg"></p>
<p>前序遍历顺序为：ABDHIEJCFKG<br>中序遍历顺序为：HDIBEJAFKCG<br>后序遍历顺序为：HIDJEBKFGCA<br>层序遍历顺序为：ABCDEFGHIJK</p>
<h2 id="F-二叉树的建立和遍历算法"><a href="#F-二叉树的建立和遍历算法" class="headerlink" title="(F) 二叉树的建立和遍历算法"></a>(F) 二叉树的建立和遍历算法</h2><ul>
<li>题目要求：建立二叉树并输出每个字符所在的层数。如下图要求输出<br>A 在第一层，B、C 在第二层，D、E 在第三层。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2112.jpg"></p>
<ul>
<li>代码实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Biltreenode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Biltreenode</span> *<span class="title">ltree</span>, *<span class="title">rtree</span>;</span></span><br><span class="line">&#125;Biltreenode, *Biltree;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createtree</span><span class="params">(Biltree *T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">&#x27; &#x27;</span>)       <span class="comment">//空格作为叶子结点 </span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T = (Biltreenode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Biltreenode));</span><br><span class="line">        (*T)-&gt;data = c;</span><br><span class="line">        createtree(&amp;(*T)-&gt;ltree);</span><br><span class="line">        createtree(&amp;(*T)-&gt;rtree);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c 在第 %d 层\n&quot;</span>, c, l);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preordervisit</span><span class="params">(Biltree T, <span class="keyword">int</span> level)</span>  <span class="comment">//前序遍历方式 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        visit(level, T-&gt;data);</span><br><span class="line">        preordervisit(T-&gt;ltree, level + <span class="number">1</span>);</span><br><span class="line">        preordervisit(T-&gt;rtree, level + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    Biltree M;</span><br><span class="line">    M = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">    createtree(&amp;M);</span><br><span class="line">    preordervisit(M, level);</span><br><span class="line"> </span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入 AB0D00CE000 (0 代表空格)，结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A 在第 <span class="number">1</span> 层</span><br><span class="line">B 在第 <span class="number">2</span> 层</span><br><span class="line">D 在第 <span class="number">3</span> 层</span><br><span class="line">C 在第 <span class="number">2</span> 层</span><br><span class="line">E 在第 <span class="number">3</span> 层</span><br></pre></td></tr></table></figure>

<h2 id="G-树与森林的遍历"><a href="#G-树与森林的遍历" class="headerlink" title="(G) 树与森林的遍历"></a>(G) 树与森林的遍历</h2><ul>
<li>树的遍历分为两种方式：一种是先根遍历，另一种是后根遍历。<br>– 先根遍历：先访问树的根结点，然后再依次先根遍历根的每棵子树。<br>– 后根遍历：先依次遍历每棵子树，然后再访问根结点。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2118.jpg"></p>
<p>先根遍历结果：ABEFCGDHIJ<br>后根遍历结果：EFBGCHIJDA</p>
<ul>
<li>森林的遍历也分为前序遍历和后序遍历，其实就是按照树的先根遍历和后根遍历依次访问森林的每一棵树。<br>我们发现：树、森林的前根(序)遍历和二叉树的前序遍历结果相同；树、森林的后根(序)遍历和二叉树的中序遍历结果相同。</li>
</ul>
<h1 id="三-线索二叉树"><a href="#三-线索二叉树" class="headerlink" title="三. 线索二叉树"></a>三. 线索二叉树</h1><h2 id="A-简介-2"><a href="#A-简介-2" class="headerlink" title="(A) 简介"></a>(A) 简介</h2><ul>
<li>二叉树的遍历本质上是将一个复杂的非线性结构转换为线性结构，使每个结点都有了唯一前驱和后继(第一个结点无前驱，最后一个结点无后继)。对于二叉树的一个结点，查找其左右孩子是方便的，但其前驱后继只有在遍历中得到。为了容易找到前驱和后继，有两种方法。一是在结点结构中增加向前和向后的指针，不过这种方法增加了存储开销，不可取；二是利用二叉树的空链指针。</li>
<li>对于 n 个结点的二叉树，在二叉链存储结构中有 n+1 个空链域，利用这些空链域存放在某种遍历次序下该结点的前驱结点和后继结点的指针，这些指针称为线索，加上线索的二叉树称为线索二叉树。<br>线索二叉树解决了无法直接找到结点在某种遍历序列中的前驱和后继结点的问题。</li>
<li>线索二叉树的结点结构如下</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2113.jpg"></p>
<p>– ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱。<br>– rtag 为 0 时指向该结点的右孩子，为 1 时指向该结点的后继。</p>
<h2 id="B-代码实现"><a href="#B-代码实现" class="headerlink" title="(B) 代码实现"></a>(B) 代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span>    //线索二叉树结构</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">Lchild</span>, *<span class="title">Rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> LTag, RTag;</span><br><span class="line">&#125;BiThrNode, *BiThrTree;</span><br><span class="line"></span><br><span class="line">BiThrTree pre;    <span class="comment">//全局变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiThrTree &amp;T)</span>  <span class="comment">//先序递归创建一般二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">        T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));</span><br><span class="line">        T-&gt;data = ch;</span><br><span class="line">        CreateBiTree(T-&gt;Lchild);</span><br><span class="line">        CreateBiTree(T-&gt;Rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThreading</span><span class="params">(BiThrTree p)</span>  <span class="comment">//以p结点为根的子树中序线索化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;Lchild);    <span class="comment">//递归左子树线索化</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;Lchild)            <span class="comment">//左子结点存在</span></span><br><span class="line">            p-&gt;LTag = <span class="number">0</span>;        <span class="comment">//代表该结点的左子结点存在</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag = <span class="number">1</span>;        <span class="comment">//代表该结点的左子节点为空</span></span><br><span class="line">            p-&gt;Lchild = pre;    <span class="comment">//左指针按中序指向上一个结点(若上一个结点不存在则指向头结点)</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(pre-&gt;Rchild)            <span class="comment">//按中序的上一个结点的右子结点存在</span></span><br><span class="line">            p-&gt;RTag = <span class="number">0</span>;        <span class="comment">//代表该结点的右子结点存在</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag = <span class="number">1</span>;        <span class="comment">//代表该结点的右子结点为空</span></span><br><span class="line">            pre-&gt;Rchild = p;    <span class="comment">//右指针按中序指向下一个结点(若下一个结点不存在则指向头结点)</span></span><br><span class="line">        &#125;</span><br><span class="line">        pre = p;                <span class="comment">//按中序顺序，使pre始终指向p的上一个结点</span></span><br><span class="line">        InThreading(p-&gt;Rchild);    <span class="comment">//递归右子树线索化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderThreading</span><span class="params">(BiThrTree &amp;Head, BiThrTree T)</span><span class="comment">//带头结点的二叉树中序线索化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//初始化头结点</span></span><br><span class="line">    Head = (BiThrNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiThrNode));<span class="comment">//为头结点分配空间</span></span><br><span class="line">    Head-&gt;LTag = <span class="number">0</span>;        <span class="comment">//初始化左子结点存在</span></span><br><span class="line">    Head-&gt;RTag = <span class="number">1</span>;        <span class="comment">//初始化右子结点为空</span></span><br><span class="line">    Head-&gt;Rchild = Head;<span class="comment">//初始化右指针指向自己</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//线索化</span></span><br><span class="line">    <span class="keyword">if</span>(!T)                        <span class="comment">//如果二叉树为空</span></span><br><span class="line">        Head-&gt;Lchild = Head;    <span class="comment">//左指针也指向自己</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Head-&gt;Lchild = T;        <span class="comment">//左指针指向二叉树的根结点</span></span><br><span class="line">        pre = Head;                <span class="comment">//初始化前驱结点pre为头结点</span></span><br><span class="line">        </span><br><span class="line">        InThreading(T);            <span class="comment">//线索化以T为根结点的二叉树</span></span><br><span class="line"></span><br><span class="line">        pre-&gt;Rchild = Head;        <span class="comment">//最后的右子结点为空，则指向头结点</span></span><br><span class="line">        pre-&gt;RTag = <span class="number">1</span>;            <span class="comment">//代表右子结点为空</span></span><br><span class="line">    </span><br><span class="line">        Head-&gt;Rchild = pre;        <span class="comment">//头结点的右指针指向最后的右子结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiThrTree &amp;Head)</span><span class="comment">//非递归遍历线索二叉树</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiThrTree p = Head-&gt;Lchild;</span><br><span class="line">    <span class="keyword">while</span>(p != Head)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;LTag == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;Lchild;<span class="comment">//遍历左子结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);<span class="comment">//输出左子结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(p-&gt;RTag == <span class="number">1</span> &amp;&amp; p-&gt;Rchild != Head)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;Rchild;            <span class="comment">//遍历根结点和右子结点</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, p-&gt;data);    <span class="comment">//输出根结点和右子结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p-&gt;Rchild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiThrTree Head, T;</span><br><span class="line">    <span class="comment">//测试用例:ABC##DE##FG##H##IJ##K##</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入结点数据(&#x27;#&#x27;为空):&quot;</span>);</span><br><span class="line">    CreateBiTree(T);</span><br><span class="line"></span><br><span class="line">    InOrderThreading(Head, T);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;非递归遍历中序线索二叉树:&quot;</span>);</span><br><span class="line">    InOrderTraverse(Head);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入结点数据(<span class="string">&#x27;#&#x27;</span>为空):ABC##DE##FG##H##IJ##K##</span><br><span class="line">非递归遍历中序线索二叉树:C B E D G F H A J I K</span><br></pre></td></tr></table></figure>

<h1 id="四-树的转换"><a href="#四-树的转换" class="headerlink" title="四. 树的转换"></a>四. 树的转换</h1><h2 id="A-普通树转换为二叉树"><a href="#A-普通树转换为二叉树" class="headerlink" title="(A) 普通树转换为二叉树"></a>(A) 普通树转换为二叉树</h2><ul>
<li>步骤如下：<br>– 加线，在所有兄弟结点之间加一条连线。<br>– 去线，对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。<br>– 层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2114.jpg"></p>
<h2 id="B-森林转换为二叉树"><a href="#B-森林转换为二叉树" class="headerlink" title="(B) 森林转换为二叉树"></a>(B) 森林转换为二叉树</h2><ul>
<li>步骤如下：<br>– 把每棵树转换为二叉树。<br>– 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2115.jpg"></p>
<h2 id="C-二叉树转换为树"><a href="#C-二叉树转换为树" class="headerlink" title="(C) 二叉树转换为树"></a>(C) 二叉树转换为树</h2><ul>
<li>是树转换为二叉树的逆过程<br>– 加线，若某结点 X 的左孩子结点存在，则将这个左孩子的右孩子结点、右孩子的右孩子结点、右孩子的右孩子的右孩子结点 ······，都作为结点 X 的孩子。将结点 X 与这些右孩子结点用线连接起来。<br>– 去线，删除原二叉树中所有结点与其右孩子结点的连线。<br>– 层次调整</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2116.jpg"></p>
<h2 id="D-二叉树转换为森林"><a href="#D-二叉树转换为森林" class="headerlink" title="(D) 二叉树转换为森林"></a>(D) 二叉树转换为森林</h2><ul>
<li>假如一棵二叉树的根结点有右孩子，则这棵二叉树能够转换为森林，否则将转换为一棵树。<br>– 从根结点开始，若右孩子存在，则把与右孩子结点的连线删除。再查看分离后的二叉树，若其根结点的右孩子存在，则连线删除 ······。直至所有这些根结点与右孩子的连线都删除为止。<br>– 将每棵分离后的二叉树转换为树。</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2117.jpg"></p>
<h1 id="五-Huffman-Tree"><a href="#五-Huffman-Tree" class="headerlink" title="五. Huffman Tree"></a>五. Huffman Tree</h1><h2 id="A-简介-3"><a href="#A-简介-3" class="headerlink" title="(A) 简介"></a>(A) 简介</h2><ul>
<li><p>(1) 权：树结点间的连线相关的数叫做权。<br>(2) 结点的路径长度：从根结点到该结点的路径上的连接数。<br>(3) 树的路径长度：树中每个叶子结点的路径长度之和。<br>(4) 结点带权路径长度：结点的路径长度与结点权值的乘积。<br>(5) 树的带权路径长度：WPL (Weighted Path Length) 是树中所有叶子结点的带权路径长度之和</p>
</li>
<li><p>给定 N 个权值作为 N 个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为 Huffman Tree。Huffman Tree 是带权路径长度最短的树，权值较大的结点离根较近。</p>
</li>
</ul>
<h2 id="B-构造-Huffman-Tree"><a href="#B-构造-Huffman-Tree" class="headerlink" title="(B) 构造 Huffman Tree"></a>(B) 构造 Huffman Tree</h2><h3 id="a-算法过程"><a href="#a-算法过程" class="headerlink" title="(a) 算法过程"></a>(a) 算法过程</h3><p>假设有 n 个权值，则构造出的 Huffman Tree 有 n 个叶子结点。n 个权值分别设为 w1、w2、···、wn，则 Huffman Tree 的构造规则为：<br>(1) 将 w1、w2、···，wn 看成是有 n 棵树的森林(每棵树仅有一个结点)；<br>(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；<br>(3) 从森林中删除选取的两棵树，并将新树加入森林；<br>(4) 重复 (2)、(3) 步骤，直到森林中只剩一棵树为止，该树即为所求得的 Huffman Tree。</p>
<h3 id="b-实例-1"><a href="#b-实例-1" class="headerlink" title="(b) 实例"></a>(b) 实例</h3><p>由给定结点构造 Huffman Tree 并进行 Huffman 编码。8 个结点的权值大小如下：<br>A-19，B-21，C-2，D-3，E-6，F-7，G-10，H-32<br>结果如下<br><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A2119.jpg"></p>
<p>对于每个结点，经过左边的路径为0，经过右边的路径为1，则可写出 Huffman 编码：<br>A-00，B-01，C-10000，D-10001，E-1001，F-1010，G-1011，H-11</p>
<h3 id="c-代码实现"><a href="#c-代码实现" class="headerlink" title="(c) 代码实现"></a>(c) 代码实现</h3><p>Huffman 编码代码示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">int</span> weight ;</span><br><span class="line">        <span class="keyword">int</span> parent;</span><br><span class="line">        <span class="keyword">int</span> left;</span><br><span class="line">        <span class="keyword">int</span> right;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HuffmanTree</span><span class="params">(HuffmanTreeNode tree[] , <span class="keyword">int</span> w[] ,<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">select</span><span class="params">(HuffmanTreeNode tree[],<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;i1,<span class="keyword">int</span> &amp;i2)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">HuffmanCode</span><span class="params">(HuffmanTreeNode tree[],<span class="built_in">string</span> huffmanCode[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTreeNode::HuffmanTree</span><span class="params">(HuffmanTreeNode tree[] , <span class="keyword">int</span> w[] ,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i2 = <span class="number">0</span>; </span><br><span class="line">    <span class="comment">//初始化结点为-1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i].parent = <span class="number">-1</span>;</span><br><span class="line">        tree[i].left = <span class="number">-1</span>;</span><br><span class="line">        tree[i].right = <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//初始化前n个结点的权值</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[i].weight = w[i];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//开始构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=n;k&lt;<span class="number">2</span>*n<span class="number">-1</span>;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//首先找到parent==-1的最小和次小的结点</span></span><br><span class="line"></span><br><span class="line">        select(tree,k,i1,i2);</span><br><span class="line">        tree[k].weight = tree[i1].weight+tree[i2].weight;</span><br><span class="line">        tree[i1].parent = k;</span><br><span class="line">        tree[i2].parent = k;</span><br><span class="line">        tree[k].left = i1;</span><br><span class="line">        tree[k].right = i2; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTreeNode::select</span><span class="params">(HuffmanTreeNode tree[],<span class="keyword">int</span> k,<span class="keyword">int</span> &amp;i1,<span class="keyword">int</span> &amp;i2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    i1 = <span class="number">0</span>;</span><br><span class="line">    i2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;tree[i].weight&amp;&amp;tree[i].parent==<span class="number">-1</span>)</span><br><span class="line">            temp = tree[i].weight;</span><br><span class="line">            i1 = i ;</span><br><span class="line">    &#125;</span><br><span class="line">    temp = <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp&gt;tree[i].weight&amp;&amp;tree[i].parent==<span class="number">-1</span>&amp;&amp;i!=i1)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = tree[i].weight;</span><br><span class="line">            i2 = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HuffmanTreeNode::HuffmanCode</span><span class="params">(HuffmanTreeNode tree[] , <span class="built_in">string</span> huffmanCode[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//设置一个临时存储空间</span></span><br><span class="line">    <span class="keyword">int</span> cur; </span><br><span class="line">    <span class="keyword">int</span> parent; </span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="comment">//遍历哈夫曼树，生成哈夫曼编码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cur = i ;<span class="comment">//记录当前处理位置</span></span><br><span class="line">        parent = tree[i].parent;<span class="comment">//找到当前结点的父节点</span></span><br><span class="line">        <span class="keyword">while</span>(parent!=<span class="number">-1</span>)</span><br><span class="line">        &#123;<span class="comment">//父节点不等于-1指的就是当前</span></span><br><span class="line">            <span class="keyword">if</span>(tree[parent].left==cur)</span><br><span class="line">                huffmanCode[i] = <span class="string">&#x27;0&#x27;</span> + huffmanCode[i];<span class="comment">//当前为左子树则编码0</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                huffmanCode[i] = <span class="string">&#x27;1&#x27;</span> + huffmanCode[i];</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//改变当前结点与父节点位置向上上搜索 </span></span><br><span class="line">        cur = parent;</span><br><span class="line">        parent = tree[parent].parent; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count ;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入结点个数: &quot;</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;count;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入&quot;</span>&lt;&lt;count&lt;&lt;<span class="string">&quot;个权值：&quot;</span>;</span><br><span class="line">    <span class="keyword">int</span> *w = <span class="keyword">new</span> <span class="keyword">int</span>[count];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i &lt; count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i];</span><br><span class="line">    &#125; </span><br><span class="line">    HuffmanTreeNode *tree = <span class="keyword">new</span> HuffmanTreeNode[<span class="number">2</span>*count<span class="number">-1</span>];</span><br><span class="line">    <span class="built_in">string</span> huffmanCode[<span class="number">4</span>];</span><br><span class="line">    tree-&gt;HuffmanTree(tree,w,count);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;weight\t\tparent\t\tleft\t\tright&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">2</span>*count<span class="number">-1</span>;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;tree[i].weight&lt;&lt;<span class="string">&quot;\t\t&quot;</span>&lt;&lt;tree[i].parent</span><br><span class="line">        &lt;&lt;<span class="string">&quot;\t\t&quot;</span>&lt;&lt;tree[i].left&lt;&lt;<span class="string">&quot;\t\t&quot;</span>&lt;&lt;tree[i].right&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;哈夫曼编码为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    tree-&gt;HuffmanCode(tree,huffmanCode,count);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;count;i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;huffmanCode[i]&lt;&lt;<span class="string">&quot; &quot;</span>; </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">请输入结点个数: <span class="number">4</span></span><br><span class="line">请输入<span class="number">4</span>个权值：<span class="number">2</span> <span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line">weight          parent          left            right</span><br><span class="line"><span class="number">2</span>               <span class="number">4</span>               <span class="number">-1</span>              <span class="number">-1</span></span><br><span class="line"><span class="number">4</span>               <span class="number">5</span>               <span class="number">-1</span>              <span class="number">-1</span></span><br><span class="line"><span class="number">5</span>               <span class="number">6</span>               <span class="number">-1</span>              <span class="number">-1</span></span><br><span class="line"><span class="number">3</span>               <span class="number">4</span>               <span class="number">-1</span>              <span class="number">-1</span></span><br><span class="line"><span class="number">5</span>               <span class="number">5</span>               <span class="number">3</span>               <span class="number">0</span></span><br><span class="line"><span class="number">9</span>               <span class="number">6</span>               <span class="number">4</span>               <span class="number">1</span></span><br><span class="line"><span class="number">14</span>              <span class="number">-1</span>              <span class="number">5</span>               <span class="number">2</span></span><br><span class="line">哈夫曼编码为：</span><br><span class="line"><span class="number">001</span> <span class="number">01</span> <span class="number">1</span> <span class="number">000</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>注，最后的 0 是 return 0 造成的，并非编码。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"># 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/11/18/data-structure-05/" rel="prev" title="数据结构和算法(零五)：递归·字符串·KMP算法">
      <i class="fa fa-chevron-left"></i> 数据结构和算法(零五)：递归·字符串·KMP算法
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/11/26/data-structure-07/" rel="next" title="数据结构和算法(零七)：图">
      数据结构和算法(零七)：图 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minwei Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
