<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="本篇主要介绍的是位域，位操作，C 语言中的文件操作，流与缓冲。">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言笔记(零四)：位·文件操作·流与缓冲">
<meta property="og:url" content="http://yoursite.com/2021/01/20/The-C04/index.html">
<meta property="og:site_name" content="Cross Code">
<meta property="og:description" content="本篇主要介绍的是位域，位操作，C 语言中的文件操作，流与缓冲。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A3001.jpg">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A3002.jpg">
<meta property="article:published_time" content="2021-01-20T01:41:30.000Z">
<meta property="article:modified_time" content="2021-05-30T15:26:47.738Z">
<meta property="article:author" content="Minwei Chen">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A3001.jpg">

<link rel="canonical" href="http://yoursite.com/2021/01/20/The-C04/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C语言笔记(零四)：位·文件操作·流与缓冲 | Cross Code</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cross Code</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">There is only one heroism in the world: to see the world as it is and to love it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E4%BD%8D%E5%9F%9F"><span class="nav-text">一. 位域</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E4%BD%8D%E5%9F%9F%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-text">(A) 位域的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E8%A7%84%E5%88%99"><span class="nav-text">(B) 结构体内存对齐规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%97%A0%E5%90%8D%E4%BD%8D%E5%9F%9F"><span class="nav-text">(C) 无名位域</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E4%BD%8D%E6%93%8D%E4%BD%9C"><span class="nav-text">二. 位操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E9%80%BB%E8%BE%91%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">(A) 逻辑位运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">(B) 移位运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E7%AE%80%E4%BB%8B"><span class="nav-text">(a) 简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%B8%80%E4%BA%9B%E6%9C%AA%E5%AE%9A%E4%B9%89%E8%A1%8C%E4%B8%BA"><span class="nav-text">(b) 一些未定义行为</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-C-%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">三. C 语言文件操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E6%96%87%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88"><span class="nav-text">(A) 文件是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="nav-text">(B) 文件操作函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-fopen"><span class="nav-text">(a) fopen( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-fclose"><span class="nav-text">(b) fclose( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-fgetc"><span class="nav-text">(c) fgetc( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-fputc"><span class="nav-text">(d) fputc( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-fgets"><span class="nav-text">(e) fgets( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-fputs"><span class="nav-text">(f) fputs( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#g-fprintf"><span class="nav-text">(g) fprintf( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#h-fread"><span class="nav-text">(h) fread( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#i-fwrite"><span class="nav-text">(i) fwrite( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#j-getw"><span class="nav-text">(j) getw( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#k-putw"><span class="nav-text">(k) putw( )</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%96%87%E4%BB%B6%E7%8A%B6%E6%80%81%E6%A3%80%E6%9F%A5%E5%87%BD%E6%95%B0"><span class="nav-text">(C) 文件状态检查函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-feof"><span class="nav-text">(a) feof( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-ferror"><span class="nav-text">(b) ferror( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-clearerr"><span class="nav-text">(c) clearerr( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-ftell"><span class="nav-text">(d) ftell( )</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D%E5%87%BD%E6%95%B0"><span class="nav-text">(D) 文件定位函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-rewind"><span class="nav-text">(a) rewind( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-fseek"><span class="nav-text">(b) fseek( )</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-exit-%E4%B8%8E-feof"><span class="nav-text">(E) exit( ) 与 feof( )</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-exit"><span class="nav-text">(a) exit( )</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-feof"><span class="nav-text">(b) feof( )</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E6%B5%81%E4%B8%8E%E7%BC%93%E5%86%B2"><span class="nav-text">四. 流与缓冲</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E6%B5%81"><span class="nav-text">(A) 流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">(B) 缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="nav-text">(a) 为什么要引入缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-text">(b) 缓冲区的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="nav-text">(c) 缓冲区的大小</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E7%BC%93%E5%86%B2%E5%8C%BA%E7%9A%84%E5%88%B7%E6%96%B0"><span class="nav-text">(d) 缓冲区的刷新</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-getchar"><span class="nav-text">(C) getchar( )</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minwei Chen"
      src="/images/tuoqi.jpg">
  <p class="site-author-name" itemprop="name">Minwei Chen</p>
  <div class="site-description" itemprop="description">Cross the surface, get to the reality. Welcome to Cross Code!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">40</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AltriaChen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AltriaChen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mwchennju@foxmail.com" title="E-Mail → mailto:mwchennju@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/20/The-C04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tuoqi.jpg">
      <meta itemprop="name" content="Minwei Chen">
      <meta itemprop="description" content="Cross the surface, get to the reality. Welcome to Cross Code!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cross Code">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言笔记(零四)：位·文件操作·流与缓冲
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-20 09:41:30" itemprop="dateCreated datePublished" datetime="2021-01-20T09:41:30+08:00">2021-01-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-30 23:26:47" itemprop="dateModified" datetime="2021-05-30T23:26:47+08:00">2021-05-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇主要介绍的是位域，位操作，C 语言中的文件操作，流与缓冲。</p>
<a id="more"></a>

<h1 id="一-位域"><a href="#一-位域" class="headerlink" title="一. 位域"></a>一. 位域</h1><h2 id="A-位域的概念"><a href="#A-位域的概念" class="headerlink" title="(A) 位域的概念"></a>(A) 位域的概念</h2><ul>
<li><p>有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足矣，也就是用一个二进制位。正是基于这种考虑，C 语言又提供了一种数据结构，叫做“位域”或“位段”。<br>位域是操控位的一种方法(操控位的另一种方法是使用按位运算符)。</p>
</li>
<li><p>位域通过一个结构声明来建立：该结构声明为每个字段提供标签，并确定该字段的宽度。例如，下面的声明建立了 4 个 1 位的字段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> c:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> d:<span class="number">1</span>;</span><br><span class="line">&#125;exam;</span><br></pre></td></tr></table></figure>

<p>根据该声明，exam 包含 4 个 1 位的字段。现在，可以通过普通的结构成员运算符 (.) 单独给这些字段赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exam.a = <span class="number">0</span>;</span><br><span class="line">exam.b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>由于每个字段恰好为 1 位，所以只能为其赋值 0 或 1。变量 exam 被储存在 int 大小的内存单元中，但是在本例中只使用了其中的 4 位。<br><code>:</code> 后面的数字用来限定成员变量占用的位数。位域的宽度不能超过它所依附的数据类型的长度。如上述结构中 a，b，c，d 后面的数字不能超过 unsigned int 的位数，即在 32bit 环境中就是不能超过 32。</p>
</li>
<li><p>C 语言标准规定，只有有限的几种数据类型可以用于位域。在 ANSIC 中，这几种数据类型是 signed int 和 unsigned int；到了 C99 与 C11 新增了 _Bool 的位字段。</p>
</li>
</ul>
<h2 id="B-结构体内存对齐规则"><a href="#B-结构体内存对齐规则" class="headerlink" title="(B) 结构体内存对齐规则"></a>(B) 结构体内存对齐规则</h2><ul>
<li><p>位域的存储遵循结构体内存对齐的规则。<br>内存对齐是编译器的管辖范围。编译器将程序中的每个“数据单元”安排在适当的位置上，以便于能快速地找到每个“数据单元”。对于 32bit 的 CPU，其寻址的步长为 4 个字节(即 unsigned int 字节长度)，这就是常说的“4 字节对齐”。同理，对于 64bit 的 CPU，就有“8 字节对齐”。本文以 32 为的 CPU 为例。</p>
</li>
<li><p>例如下面的一个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a1;</span><br><span class="line">    <span class="keyword">int</span> a2;</span><br><span class="line">    <span class="keyword">char</span> a3;</span><br><span class="line">    <span class="keyword">short</span> a4;</span><br><span class="line">&#125;test;</span><br></pre></td></tr></table></figure>

<p>在 32 位编译系统下这一个结构体的字节数为 12 字节。因为编译器会对不足 4 字节的变量空间自动补齐为 4 个字节(这就是内存对齐)，以提高 CPU 的寻址效率(32 位 CPU 以 4 个字节步长寻址的)。</p>
<p>图示为：<br><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A3001.jpg"></p>
</li>
</ul>
<h2 id="C-无名位域"><a href="#C-无名位域" class="headerlink" title="(C) 无名位域"></a>(C) 无名位域</h2><p>位域成员可以没有名称，只给出数据类型和位宽，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m:<span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span>  :<span class="number">20</span>;  <span class="comment">//该位域成员不能使用，用于填充</span></span><br><span class="line">    <span class="keyword">int</span> n:<span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。<br>上面的例子中，如果没有位宽为 20 的无名t成员，m 和 n 将会挨着存储，<code>sizeof(struct Test)</code> 的结果为 4；有了这 20 位作为填充，m 和 n 将分开存储，<code>sizeof(struct Test)</code> 的结果为 8。</p>
<h1 id="二-位操作"><a href="#二-位操作" class="headerlink" title="二. 位操作"></a>二. 位操作</h1><p>注，C 语言并没有规定一个字节的尺寸，只是规定“可寻址的数据存储单位，其尺寸必须可以容纳运行环境的基本字符集的任何成员”。</p>
<h2 id="A-逻辑位运算符"><a href="#A-逻辑位运算符" class="headerlink" title="(A) 逻辑位运算符"></a>(A) 逻辑位运算符</h2><table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>优先级</th>
<th>举例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>按位取反</td>
<td>高</td>
<td>~a</td>
<td>如果a为1，<del>a为0；<br />如果a为0，</del>a为1。</td>
</tr>
<tr>
<td>&amp;</td>
<td>按位与</td>
<td>中</td>
<td>a&amp;b</td>
<td>只有a和b同时为1，结果才为1；<br />只要a和b其中一个为0，结果为0。</td>
</tr>
<tr>
<td>^</td>
<td>按位异或</td>
<td>低</td>
<td>a^b</td>
<td>如果a和b不同，其结果为1；<br />如果a和b相同，其结果为0。</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>最低</td>
<td>a|b</td>
<td>只要a和b其中一个为1，结果为1;<br />只有a和b同时为0，结果为0。</td>
</tr>
</tbody></table>
<h2 id="B-移位运算符"><a href="#B-移位运算符" class="headerlink" title="(B) 移位运算符"></a>(B) 移位运算符</h2><h3 id="a-简介"><a href="#a-简介" class="headerlink" title="(a) 简介"></a>(a) 简介</h3><ul>
<li>C 语言除了提供四种逻辑位运算符之外，还提供了可以将某个变量中的所有二进制位进行左移或右移的运算符——移位运算符。</li>
</ul>
<table>
<thead>
<tr>
<th>运算符</th>
<th>含义</th>
<th>作用</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>&lt;&lt;</td>
<td>左移</td>
<td>将变量的各位按要求向左移动若干位</td>
<td>0100&lt;&lt;1=1000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>右移</td>
<td>将变量的各位按要求向右移动若干位</td>
<td>0100&gt;&gt;1=0010</td>
</tr>
</tbody></table>
<ul>
<li>移位操作可用于整数的快速乘除运算，左移一位等效于乘 2，而右移一位等效于除以 2。</li>
</ul>
<h3 id="b-一些未定义行为"><a href="#b-一些未定义行为" class="headerlink" title="(b) 一些未定义行为"></a>(b) 一些未定义行为</h3><ul>
<li>左移、右移运算符右边的操作数如果是为负数，或者右边的操作数大于左边操作数支持的最大宽度，那么表达式的结果均是属于“未定义行为”。</li>
<li>左边的操作数是有符号还是无符号数其实也对移位运算符有着不同的影响。无符号数肯定没问题，因为这时候变量里边所有的位都用于表示该数值的大小。但如果是有符号数，那就要区别对待了，因为有符号数的左边第一位是符号位，所以如果恰好这个操作数是个负数，那么移动之后是否覆盖符号位的决定权还是落到了编译器上。</li>
</ul>
<h1 id="三-C-语言文件操作"><a href="#三-C-语言文件操作" class="headerlink" title="三. C 语言文件操作"></a>三. C 语言文件操作</h1><h2 id="A-文件是什么"><a href="#A-文件是什么" class="headerlink" title="(A) 文件是什么"></a>(A) 文件是什么</h2><p>计算机文件(或称文件，电脑档案，档案)，是存储在某种长期存储设备或临时存储设备中的一段数据流，并且归属于计算机文件系统管理之下。<br>所谓“长期存储设备”一般指磁盘、光盘、磁带等，而“短期存储设备”一般指计算机内存。需要注意的是，存储于长期存储设备的文件不一定是长期存储的，有些也可能是程序或系统运行中产生的临时数据，并于程序或系统退出后删除。</p>
<h2 id="B-文件操作函数"><a href="#B-文件操作函数" class="headerlink" title="(B) 文件操作函数"></a>(B) 文件操作函数</h2><h3 id="a-fopen"><a href="#a-fopen" class="headerlink" title="(a) fopen( )"></a>(a) fopen( )</h3><table>
<thead>
<tr>
<th>fopen( )</th>
<th>文件打开</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>FILE *fopen(char *pname, char *mode)</td>
</tr>
<tr>
<td>函数说明</td>
<td>pname 是文件名，mode 是打开文件的方式</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：FILE*，被打开文件的文件指针<br />异常返回：NULL，表示打开操作不成功</td>
</tr>
</tbody></table>
<p>注：(1) C 语言将计算机的输入输出设备都看作是文件。例如，键盘文件、屏幕文件等。ANSIC 标准规定，在执行程序时系统先自动打开键盘、屏幕、错误三个文件。这三个文件的文件指针分别是：标准输入 stdin、标准输出 stdout 和标准出错 stderr。<br>(2) 文件打开模式有</p>
<table>
<thead>
<tr>
<th>文件打开模式</th>
<th>读写模式</th>
<th>含义</th>
<th>如果指定的文件不存在</th>
</tr>
</thead>
<tbody><tr>
<td>“r”</td>
<td>只读</td>
<td>为了输入数据，打开一个已存在的文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w”</td>
<td>只写</td>
<td>为了输出数据，打开一个文本文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>“a”</td>
<td>追加</td>
<td>向文本文件尾添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“rb”</td>
<td>只读</td>
<td>为了输入数据，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb”</td>
<td>只写</td>
<td>为了输出数据，打开一个二进制文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>“ab”</td>
<td>追加</td>
<td>向二进制文件尾添加数据</td>
<td>出错</td>
</tr>
<tr>
<td>“r+”</td>
<td>读写</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“w+”</td>
<td>读写</td>
<td>为了读和写，建立一个新的文本文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>“a+”</td>
<td>读写</td>
<td>为了读和写，打开一个文本文件</td>
<td>出错</td>
</tr>
<tr>
<td>“rb+”</td>
<td>读写</td>
<td>为了读和写，打开一个二进制文件</td>
<td>出错</td>
</tr>
<tr>
<td>“wb+”</td>
<td>读写</td>
<td>为了读和写，建立一个新的二进制文件</td>
<td>建立新文件</td>
</tr>
<tr>
<td>“ab+”</td>
<td>读写</td>
<td>为读写打开一个二进制文件</td>
<td>出错</td>
</tr>
</tbody></table>
<h3 id="b-fclose"><a href="#b-fclose" class="headerlink" title="(b) fclose( )"></a>(b) fclose( )</h3><table>
<thead>
<tr>
<th>fclose( )</th>
<th>文件关闭</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fclose(FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>fp 是一个已打开的文件的文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：0<br />异常返回：EOF，表示文件在关闭时发生错误</td>
</tr>
</tbody></table>
<h3 id="c-fgetc"><a href="#c-fgetc" class="headerlink" title="(c) fgetc( )"></a>(c) fgetc( )</h3><table>
<thead>
<tr>
<th>fgetc( )</th>
<th>读取一个字符</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fgetc(FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>从 fp 中读取一个字符，作为返回值返回</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：返回读取字符的代码<br />异常返回：返回 EOF</td>
</tr>
</tbody></table>
<p>(1) 实例：显示指定文件的内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 程序名为：display.c</span></span><br><span class="line"><span class="comment">执行时可用：display filename1 形式的命令行运行。显示文件filename1中的内容。</span></span><br><span class="line"><span class="comment">例如，执行命令行display display.c将在屏幕上显示display的原代码。*/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//File display program.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> <span class="comment">//命令行参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;<span class="comment">//定义文件类型指针</span></span><br><span class="line">    FILE *fp;<span class="comment">//判断命令行是否正确</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error format,Usage: display filename1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//键入了错误的命令行，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按读方式打开由argv[1]指出的文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file &lt;%s&gt; can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);<span class="comment">//打开操作不成功</span></span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功打开了argv[1]所指文件</span></span><br><span class="line">    ch=fgetc(fp); <span class="comment">//从fp所指文件的当前指针位置读取一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(ch!=EOF) <span class="comment">//判断刚读取的字符是否是文件结束符</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch); <span class="comment">//若不是结束符，将它输出到屏幕上显示</span></span><br><span class="line">        ch=fgetc(fp); <span class="comment">//继续从fp所指文件中读取下一个字符</span></span><br><span class="line">    &#125; <span class="comment">//完成将fp所指文件的内容输出到屏幕上显示</span></span><br><span class="line">    fclose(fp); <span class="comment">//关闭fp所指文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="d-fputc"><a href="#d-fputc" class="headerlink" title="(d) fputc( )"></a>(d) fputc( )</h3><table>
<thead>
<tr>
<th>fputc( )</th>
<th>写一个字符到文件中</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fputc(int ch, FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>ch 是一个整型变量，要写到文件的字符<br />fp 是文件指针，要写入的文件</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：要写入的字符的代码<br />异常返回：返回 EOF</td>
</tr>
</tbody></table>
<p>(1) 实例 1：将一个文件的内容复制到另一个文件中去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*程序名为：copyfile.c</span></span><br><span class="line"><span class="comment">执行时可用：copyfile filename1 filename2形式的命令行运行，</span></span><br><span class="line"><span class="comment">将文件filename1中的内容复制到文件filename2中去。</span></span><br><span class="line"><span class="comment">file copy program. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span> <span class="comment">//命令行参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line">    FILE *in,*out; <span class="comment">//定义in和out两个文件类型指针</span></span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>) <span class="comment">//判断命令行是否正确</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error in format,Usage: copyfile filename1 filename2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//命令行错，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按读方式打开由argv[1]指出的文件</span></span><br><span class="line">    <span class="keyword">if</span>((in=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file &lt;%s&gt; can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//打开失败，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功打开了argv[1]所指文件，再</span></span><br><span class="line">    <span class="comment">//按写方式打开由argv[2]指出的文件</span></span><br><span class="line">    <span class="keyword">if</span>((out=fopen(argv[<span class="number">2</span>],<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">//打开失败，结束程序的执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成功打开了argv[2]所指文件</span></span><br><span class="line">    ch=fgetc(in); <span class="comment">//从in所指文件的当前指针位置读取一个字符</span></span><br><span class="line">    <span class="keyword">while</span>(ch!=EOF) <span class="comment">//判断刚读取的字符是否是文件结束符</span></span><br><span class="line">    &#123;</span><br><span class="line">        fputc(ch,out); <span class="comment">//若不是结束符，将它写入out所指文件</span></span><br><span class="line">        ch=fgetc(in); <span class="comment">//继续从in所指文件中读取下一个字符</span></span><br><span class="line">    &#125; <span class="comment">//完成将in所指文件的内容写入（复制）到out所指文件中</span></span><br><span class="line">    fclose(in); <span class="comment">//关闭in所指文件</span></span><br><span class="line">    fclose(out); <span class="comment">//关闭out所指文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(2) 实例 2：按十进制和字符显示文件代码，若遇不可示字符就用井号 “#” 字符代替之。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 序名为：dumpf.c</span></span><br><span class="line"><span class="comment">执行时可用：dumpf filename1 形式的命令行运行。</span></span><br><span class="line"><span class="comment"> File dump program. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">9</span>];</span><br><span class="line">    <span class="keyword">int</span> ch,count,i;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error format,Usage: dumpf filename\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        i=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//按八进制输出第一列，作为一行八个字节的首地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%06o: &quot;</span>,count*<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">// 从打开的文件中读取一个字符</span></span><br><span class="line">            ch=fgetc(fp);</span><br><span class="line">            <span class="comment">// 按十进制方式输出这个字符的ASCII码</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%4d&quot;</span>,ch);</span><br><span class="line">            <span class="comment">// 如果是不可示字符就用&quot;#&quot;字符代替</span></span><br><span class="line">            <span class="keyword">if</span>(ch&lt;<span class="string">&#x27; &#x27;</span>||ch&gt;<span class="string">&#x27;~&#x27;</span>) str[i]=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果是可示字符，就将它存入数组str以便形成字符串</span></span><br><span class="line">            <span class="keyword">else</span> str[i]=ch;</span><br><span class="line">            <span class="comment">// 保证每一行输出八个字符</span></span><br><span class="line">            <span class="keyword">if</span>(++i==<span class="number">8</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">while</span>(ch!=EOF); <span class="comment">// 遇到文件尾标志，结束读文件操作</span></span><br><span class="line">        str[i]=<span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 在数组str加字符串结束标志</span></span><br><span class="line">        <span class="keyword">for</span>(;i&lt;<span class="number">8</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">// 一行不足八个字符用空格填充</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot; %s\n&quot;</span>,str); <span class="comment">// 输出字符串</span></span><br><span class="line">        count++; <span class="comment">// 准备输出下一行</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(ch!=EOF); <span class="comment">// 直到文件结束</span></span><br><span class="line">    fclose(fp); <span class="comment">// 关闭fp所指文件</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="e-fgets"><a href="#e-fgets" class="headerlink" title="(e) fgets( )"></a>(e) fgets( )</h3><table>
<thead>
<tr>
<th>fgets( )</th>
<th>从文件中读取一个字符串</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>char *fgets(char *str, int n, FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>由 fp 指出的文件中读取 n-1 个字符，并把它们存放到由 str 指出的字符串数组中，<br />最后加上一个字符串结束符 ‘\0’</td>
</tr>
<tr>
<td>参数说明</td>
<td>str：接受字符串的内存地址，可以是数组别名，也可以是指针<br />n：指出要读取的字符的个数<br />fp：这个是文件指针，指出要从中读取字符的文件</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：字符串的内存首地址，即 str 的值<br />异常返回：返回一个 NULL 值，此时应当用 feof( ) 或 ferror( ) 函数来判断错误原因</td>
</tr>
</tbody></table>
<h3 id="f-fputs"><a href="#f-fputs" class="headerlink" title="(f) fputs( )"></a>(f) fputs( )</h3><table>
<thead>
<tr>
<th>fputs( )</th>
<th>写入字符串到文件中</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fputs(const char *str, FILE *stream)</td>
</tr>
<tr>
<td>函数说明</td>
<td>str：这是一个数组，包含了要写入的以空字符终止的字符序列<br />stream：指向 FILE 对象的指针，该 FILE 对象标识了要被写入字符串的流</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：写入到的文件的字符个数，即字符串的长度<br />异常返回：返回一个 NULL 值，此时应当用 feof( ) 或 ferror( ) 函数来判断错误原因</td>
</tr>
</tbody></table>
<p>(1) 以下程序将一个文件的内容附加到另一个文件中去</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 程序名：linkfile.c</span></span><br><span class="line"><span class="comment">执行时可用：linkfile filename1 filename2形式的命令行运行，</span></span><br><span class="line"><span class="comment">将文件filename2的内容附加在文件filename1之后。</span></span><br><span class="line"><span class="comment">file linked program. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 512</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">buffer</span>[SIZE];</span><br><span class="line">    FILE *fp1,*fp2;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: linkfile filename1 filename2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按追加方式打开argv[1] 所指文件</span></span><br><span class="line">    <span class="keyword">if</span>((fp1=fopen(argv[<span class="number">1</span>],<span class="string">&quot;a&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((fp2=fopen(argv[<span class="number">2</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读入一行立即写出，直到文件结束</span></span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">buffer</span>,SIZE,fp1)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">buffer</span>);</span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">buffer</span>,SIZE,fp2)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fputs</span>(<span class="built_in">buffer</span>,fp1);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">    fclose(fp2);</span><br><span class="line">    <span class="keyword">if</span>((fp1=fopen(argv[<span class="number">1</span>],<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fgets(<span class="built_in">buffer</span>,SIZE,fp1)!=<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,<span class="built_in">buffer</span>);</span><br><span class="line">    fclose(fp1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="g-fprintf"><a href="#g-fprintf" class="headerlink" title="(g) fprintf( )"></a>(g) fprintf( )</h3><table>
<thead>
<tr>
<th>fprintf( )</th>
<th>往文件中写格式化数据</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fprintf(FILE *fp, char *format, arg_list)</td>
</tr>
<tr>
<td>函数说明</td>
<td>将变量列表 (arg_list) 中的数据，按照 format 指出的格式，写入由 fp 指定的文件</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：这是个文件指针，指出要将数据写入的文件<br />format：指向字符串的字符指针，字符串中含有要写出数据的格式，即成为格式串。<br />                格式串描述的规则与 printf( ) 函数中的格式串相同<br />arg_list：是要写入文件的变量列表，各变量之间用逗号分隔</td>
</tr>
<tr>
<td>返回值</td>
<td>无</td>
</tr>
</tbody></table>
<p>(1) 实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 存储文件名：save.txt</span></span><br><span class="line"><span class="comment">程序代码如下：</span></span><br><span class="line"><span class="comment">file display program. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> nAge,nClass;</span><br><span class="line">    <span class="keyword">long</span> number;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;w&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(<span class="built_in">stdin</span>,<span class="string">&quot;%s %d %d %ld&quot;</span>,name,&amp;nClass,&amp;nAge,&amp;number);</span><br><span class="line">    <span class="built_in">fprintf</span>(fp,<span class="string">&quot;%s %5d %4d %8ld&quot;</span>,name,nClass,nAge,number);</span><br><span class="line">    fclose(fp);</span><br><span class="line">    <span class="keyword">if</span>((fp=fopen(<span class="string">&quot;student.txt&quot;</span>,<span class="string">&quot;r&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;student.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">&quot;%s %d %d %ld&quot;</span>,name,&amp;nClass,&amp;nAge,&amp;number);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name nClass nAge number\n&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;%-10s%-8d%-6d%-8ld\n&quot;</span>,name,nClass,nAge,number);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="h-fread"><a href="#h-fread" class="headerlink" title="(h) fread( )"></a>(h) fread( )</h3><table>
<thead>
<tr>
<th>fread( )</th>
<th>以二进制形式读取文件中的数据</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fread(void *buffer, unsigned sife, unsigned count, FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>从由 fp 指定的文件中，按二进制形式将 sife*count 个数据读到由 buffer 指出的数据区中</td>
</tr>
<tr>
<td>参数说明</td>
<td>butter：这是一个 void 型指针，指出要将读入数据存放在其中的存储区首地址<br />sife：指出一个数据块的字节数，即一个数据块的大小尺寸<br />count：指出一个读入多少个数据块 (sife)<br />fp：这是个文件指针，指出要从其中读出数据的文件</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：实际读取数据块的个数，即 count<br />异常返回：如果文件中剩下的数据块个数少于 count 或发生了错误，返回 0 值</td>
</tr>
</tbody></table>
<h3 id="i-fwrite"><a href="#i-fwrite" class="headerlink" title="(i) fwrite( )"></a>(i) fwrite( )</h3><table>
<thead>
<tr>
<th>fwrite( )</th>
<th>以二进制形式写数据到文件中去</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fwrite(void *buffer, unsigned sife, unsigned count, FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>按二进制形式，将由 buffer 指定的数据缓冲区内的 sife*count 个数据写入由 fp 指定的文件中</td>
</tr>
<tr>
<td>参数说明</td>
<td>butter：这是一个 void 型指针，指出要将读入数据存放在其中的存储区首地址<br />sife：指出一个数据块的字节数，即一个数据块的大小尺寸<br />count：指出一个读入多少个数据块 (sife)<br />fp：这是个文件指针，指出要从其中读出数据的文件</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：实际输出数据块的个数，即 count<br />异常返回：返回 0 值，表示输出结束或发生了错误</td>
</tr>
</tbody></table>
<p>(1) 实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE 4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">worker</span> <span class="title">wk</span>;</span></span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    FILE *in,*out;</span><br><span class="line">    <span class="keyword">if</span>((in=fopen(<span class="string">&quot;file1.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;file1.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((out=fopen(<span class="string">&quot;file2.txt&quot;</span>,<span class="string">&quot;wb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,<span class="string">&quot;file2.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(fread(&amp;wk,<span class="keyword">sizeof</span>(struct worker),<span class="number">1</span>,in)==<span class="number">1</span>)</span><br><span class="line">        fwrite(&amp;wk,<span class="keyword">sizeof</span>(struct worker),<span class="number">1</span>,out);</span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="j-getw"><a href="#j-getw" class="headerlink" title="(j) getw( )"></a>(j) getw( )</h3><table>
<thead>
<tr>
<th>getw( )</th>
<th>以二进制形式读取一个整数</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int getw(FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>从由 fp 指定的文件中，以二进制形式读取一个整数</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp 是文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：所读取的整数值<br />异常返回：返回 EOF，即 -1。可用 feof( ) 或 ferror( ) 判断错误类型</td>
</tr>
</tbody></table>
<p>(1) 实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,sum=<span class="number">0</span>;</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Command error,Usage: readfile filename\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(fp=fopen(argv[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++) sum+=getw(fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum is %d\n&quot;</span>,sum);</span><br><span class="line">    fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="k-putw"><a href="#k-putw" class="headerlink" title="(k) putw( )"></a>(k) putw( )</h3><table>
<thead>
<tr>
<th>putw( )</th>
<th>以二进制形式存贮一个整数</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int putw(int n, FILE *fp)</td>
</tr>
<tr>
<td>函数说明</td>
<td>以二进制形式把由变量 n 指出的整数值存放到由 fp 指定的文件中</td>
</tr>
<tr>
<td>参数说明</td>
<td>n：要存入文件的整数<br />fp：是文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：所输出的整数值<br />异常返回：返回 EOF，即 -1。可用 feof( ) 或 ferror( ) 判断错误类型</td>
</tr>
</tbody></table>
<h2 id="C-文件状态检查函数"><a href="#C-文件状态检查函数" class="headerlink" title="(C) 文件状态检查函数"></a>(C) 文件状态检查函数</h2><h3 id="a-feof"><a href="#a-feof" class="headerlink" title="(a) feof( )"></a>(a) feof( )</h3><table>
<thead>
<tr>
<th>feof( )</th>
<th>判断文件是否结束</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int feof(FILE *fp)</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>0：假值，表示文件未结束<br />1：真值，表示文件结束</td>
</tr>
</tbody></table>
<p>(1) 实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FILE *in,*out;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">3</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Usage: copyfile filename1 filename2\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((in=fopen(argv[<span class="number">1</span>],<span class="string">&quot;rb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((out=fopen(argv[<span class="number">2</span>],<span class="string">&quot;wb&quot;</span>))==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The file %s can not be opened.\n&quot;</span>,argv[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!feof(in))</span><br><span class="line">    &#123;</span><br><span class="line">        ch=fgetc(in);</span><br><span class="line">        <span class="keyword">if</span>(ferror(in))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;read error!\n&quot;</span>);</span><br><span class="line">            clearerr(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            fputc(ch,out);</span><br><span class="line">            <span class="keyword">if</span>(ferror(out))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;write error!\n&quot;</span>);</span><br><span class="line">                clearerr(out);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(in);</span><br><span class="line">    fclose(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-ferror"><a href="#b-ferror" class="headerlink" title="(b) ferror( )"></a>(b) ferror( )</h3><table>
<thead>
<tr>
<th>ferror( )</th>
<th>检查文件在读写时是否出错</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int ferror(FILE *fp)</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>0：假值，表示无错误<br />1：真值，表示出错</td>
</tr>
</tbody></table>
<h3 id="c-clearerr"><a href="#c-clearerr" class="headerlink" title="(c) clearerr( )"></a>(c) clearerr( )</h3><table>
<thead>
<tr>
<th>clearerr( )</th>
<th>清除文件的错误标志</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>void clearerr(FILE *fp)</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="d-ftell"><a href="#d-ftell" class="headerlink" title="(d) ftell( )"></a>(d) ftell( )</h3><table>
<thead>
<tr>
<th>ftell( )</th>
<th>取得文件的当前读/写位置，该位置值用相对于文件开头的位移量来表示</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>long ftell(FILE *fp)</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：位移量(这是个长整数)<br />异常返回：-1，表示出错</td>
</tr>
</tbody></table>
<h2 id="D-文件定位函数"><a href="#D-文件定位函数" class="headerlink" title="(D) 文件定位函数"></a>(D) 文件定位函数</h2><h3 id="a-rewind"><a href="#a-rewind" class="headerlink" title="(a) rewind( )"></a>(a) rewind( )</h3><table>
<thead>
<tr>
<th>rewind( )</th>
<th>使文件的位置指针重新指向文件的开头位置</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>void rewind(FILE *fp)</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="b-fseek"><a href="#b-fseek" class="headerlink" title="(b) fseek( )"></a>(b) fseek( )</h3><table>
<thead>
<tr>
<th>fseek( )</th>
<th>使文件指针 fp 移到基于 base 的相对位置 offset 处</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int fseek(FILE *fp, long offset, int base)</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：文件指针<br />offset：相对 base 的字节位移量。这是个长整数，用以支持大于 64KB 的文件<br />base：文件位置指针移动的基准位置，是计算文件位置指针位移的基点。</td>
</tr>
<tr>
<td>返回值</td>
<td>正常返回：当前指针位置<br />异常返回：-1，表示定位操作出错</td>
</tr>
</tbody></table>
<h2 id="E-exit-与-feof"><a href="#E-exit-与-feof" class="headerlink" title="(E) exit( ) 与 feof( )"></a>(E) exit( ) 与 feof( )</h2><h3 id="a-exit"><a href="#a-exit" class="headerlink" title="(a) exit( )"></a>(a) exit( )</h3><table>
<thead>
<tr>
<th>exit( )</th>
<th>使程序立即终止执行，同时将缓冲区中剩余的数据输出并关闭所有已打开的文件</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>void exit(int status)</td>
</tr>
<tr>
<td>参数说明</td>
<td>status：为 0 值表示程序正常终止，为非 0 值表示一个定义错误</td>
</tr>
<tr>
<td>返回值</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="b-feof"><a href="#b-feof" class="headerlink" title="(b) feof( )"></a>(b) feof( )</h3><table>
<thead>
<tr>
<th>feof( )</th>
<th>用来识别文件是否结束</th>
</tr>
</thead>
<tbody><tr>
<td>函数原型</td>
<td>int feof(FILE *fp)</td>
</tr>
<tr>
<td>参数说明</td>
<td>fp：文件指针</td>
</tr>
<tr>
<td>返回值</td>
<td>返回为非 0 值：已到文件尾<br />返回为 0 值：表示还未到文件尾</td>
</tr>
</tbody></table>
<h1 id="四-流与缓冲"><a href="#四-流与缓冲" class="headerlink" title="四. 流与缓冲"></a>四. 流与缓冲</h1><p>引言<br>C 语言中我们用到的最频繁的输入输出方式就是 scanf( ) 和 printf( )。<br>scanf( )：从标准输入设备(键盘)读取数据，并将值存放在变量中。<br>printf( )：将指定的文字/字符串输出到标准输出设备(屏幕)。注意宽度输出和精度输出控制。<br>C 语言借助了相应的缓冲区来进行输入与输出。<br><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A3002.jpg"></p>
<h2 id="A-流"><a href="#A-流" class="headerlink" title="(A) 流"></a>(A) 流</h2><ul>
<li>在计算机编程中，流就是一个类的对象，很多文件的输入输出操作都以类的成员函数的方式来提供。</li>
<li>计算机中的流其实是一种信息的转换。它是一种有序流，因此相对于某一对象，通常我们把对象接收外界的信息输入 (Input) 称为输入流，相应地从对象向外输出 (Output) 信息为输出流，合称为输入/输出流 (I/O Streams)。对象间进行信息或者数据的交换时总是先将对象或数据转换为某种形式的流，再通过流的输出，到达目的对象后再将流转换为对象数据。所以，可以把流看作是一种数据的载体，通过它可以实现数据交换和传输。</li>
</ul>
<h2 id="B-缓冲区"><a href="#B-缓冲区" class="headerlink" title="(B) 缓冲区"></a>(B) 缓冲区</h2><h3 id="a-为什么要引入缓冲区"><a href="#a-为什么要引入缓冲区" class="headerlink" title="(a) 为什么要引入缓冲区"></a>(a) 为什么要引入缓冲区</h3><ul>
<li>例如，我们从磁盘里取信息，我们先把读出的数据放在缓冲区，计算机再直接从缓冲区中取数据，等缓冲区的数据取完后再去磁盘中读取。这样就可以减少磁盘的读写次数，再加上计算机对缓冲区的操作大大快于对磁盘的操作，故应用缓冲区可大大提高计算机的运行速度。</li>
<li>缓冲区是这样的一块内存区域，它用在输入输出设备和 CPU 之间，用来缓存数据。它使得低速的输入输出设备和高速的 CPU 能够协调工作，避免低速的输入输出设备过度地占用 CPU，从而解放出 CPU，使其能够高效率工作。</li>
</ul>
<h3 id="b-缓冲区的类型"><a href="#b-缓冲区的类型" class="headerlink" title="(b) 缓冲区的类型"></a>(b) 缓冲区的类型</h3><p>缓冲区分为三种类型：全缓冲，行缓冲，不带缓冲。</p>
<ul>
<li>全缓冲<br>在这种情况下，当填满标准 I/O 缓存后才进行实际 I/O 操作。全缓冲的典型代表是对磁盘文件的读写。</li>
<li>行缓冲<br>在这种情况下，当在输入和输出中遇到换行符时，执行真正的 I/O 操作。这时，我们输入的字符先存放在缓冲区，等按下回车键换行时才进行实际的 I/O 操作。典型代表是标准输入(stdin) 和 标准输出 (stdout)。</li>
<li>不带缓冲<br>也就是不进行缓冲，标准出错情况 stderr 是典型代表，这使得出错信息可以直接尽快地显示出来。</li>
</ul>
<h3 id="c-缓冲区的大小"><a href="#c-缓冲区的大小" class="headerlink" title="(c) 缓冲区的大小"></a>(c) 缓冲区的大小</h3><p>如果我们没有自己设置缓冲区的话，系统会默认为标准输入输出设置一个缓冲区，这个缓冲区的大小通常是 512 个字节的大小。<br>缓冲区大小由 stdio.h 头文件中的宏 BUFSIZ 定义。如果希望查看它的大小，包含头文件，直接输出它的值即可： printf(“%d”, BUFSIZ)。<br>缓冲区的大小是可以改变的，也可以将文件关联到自定义的缓冲区，详情可以查看 setvbuf( ) 和 setbuf( ) 函数。</p>
<h3 id="d-缓冲区的刷新"><a href="#d-缓冲区的刷新" class="headerlink" title="(d) 缓冲区的刷新"></a>(d) 缓冲区的刷新</h3><p>下列情况会引发缓冲区的刷新：<br>缓冲区满时，行缓冲区遇到回车时，关闭文件，使用特定函数刷新缓冲区。</p>
<h2 id="C-getchar"><a href="#C-getchar" class="headerlink" title="(C) getchar( )"></a>(C) getchar( )</h2><ul>
<li><code>getchar()</code>，函数原型为 <code>int getchar(void);</code></li>
<li>当程序调用 getchar( ) 函数时，程序就等着用户按键，用户输入的字符被存放在键盘缓冲区中，直到用户按回车为止(回车字符也放在缓冲区中)。当用户键入回车之后，getchar( ) 函数才开始从键盘缓冲区中每次读入一个字符。也就是说，后续的 getchar( ) 函数调用不会等待用户按键，而直接读取缓冲区中的字符，直到缓冲区中的字符读完后，才重新等待用户按键。</li>
<li>即，当程序调用 getchar( ) 函数时，程序就等着用户按键，并等用户按下回车键返回。期间按下的字符存放在缓冲区，第一个字符作为函数返回值。继续调用 getchar( ) 函数，将不再等用户按键，而是返回你刚才输入的第 2 个字符。继续调用，返回第 3 个字符，直到缓冲区中的字符读完后，才等待用户按键。</li>
<li>getchar( ) 函数的执行就是采用了行缓冲。第一次调用 getchar( ) 函数，会让用户输入一行字符并直到按下回车键时函数才返回，此时用户输入的字符和回车符都存放在行缓冲区。再次调用 getchar( ) 函数，会逐步输出行缓冲区的内容。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"># C语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/14/The-C03/" rel="prev" title="C语言笔记(零三)：动态内存管理·结构体">
      <i class="fa fa-chevron-left"></i> C语言笔记(零三)：动态内存管理·结构体
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/24/Cpplus01/" rel="next" title="C++笔记(零一)：C++与OO思想简介">
      C++笔记(零一)：C++与OO思想简介 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minwei Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
