<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="本篇主要介绍的是动态内存管理与结构体。除此之外，也介绍了共用体与枚举类型的简单用法。">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言笔记(零三)：动态内存管理·结构体">
<meta property="og:url" content="http://yoursite.com/2021/01/14/The-C03/index.html">
<meta property="og:site_name" content="Cross Code">
<meta property="og:description" content="本篇主要介绍的是动态内存管理与结构体。除此之外，也介绍了共用体与枚举类型的简单用法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://chenminwei-picture.oss-cn-beijing.aliyuncs.com/img/A2901.jpg">
<meta property="article:published_time" content="2021-01-14T02:39:36.000Z">
<meta property="article:modified_time" content="2021-01-14T02:40:37.937Z">
<meta property="article:author" content="Minwei Chen">
<meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://chenminwei-picture.oss-cn-beijing.aliyuncs.com/img/A2901.jpg">

<link rel="canonical" href="http://yoursite.com/2021/01/14/The-C03/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C语言笔记(零三)：动态内存管理·结构体 | Cross Code</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cross Code</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">There is only one heroism in the world: to see the world as it is and to love it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="nav-text">一. 动态内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%AE%80%E4%BB%8B"><span class="nav-text">(A) 简介</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8"><span class="nav-text">(a) 为什么存在</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="nav-text">(b) 相关函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0"><span class="nav-text">(B) 动态内存管理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-malloc"><span class="nav-text">(a) malloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-free"><span class="nav-text">(b) free</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-calloc"><span class="nav-text">(c) calloc</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-realloc"><span class="nav-text">(d) realloc</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="nav-text">(C) C语言的内存布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%A6%82%E8%BF%B0"><span class="nav-text">(a) 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%A0%86-Heap-%E5%92%8C%E6%A0%88-Stack"><span class="nav-text">(b) 堆 (Heap) 和栈 (Stack)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%AE%80%E4%BB%8B"><span class="nav-text">(1) 简介</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8C%BA%E5%88%AB"><span class="nav-text">(2) 区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%AE%9E%E4%BE%8B"><span class="nav-text">(c) 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0-inline"><span class="nav-text">(D) 内联函数 inline</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-text">(a) 什么是内联函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="nav-text">(b) 内联函数的编程风格</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E6%85%8E%E7%94%A8%E5%86%85%E8%81%94"><span class="nav-text">(c) 慎用内联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E6%80%BB%E7%BB%93"><span class="nav-text">(d) 总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-text">二. 结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E7%BB%93%E6%9E%84%E4%BD%93%E5%A3%B0%E6%98%8E%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">(A) 结构体声明定义与初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E7%BB%93%E6%9E%84%E5%A3%B0%E6%98%8E"><span class="nav-text">(a) 结构声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E5%8F%98%E9%87%8F"><span class="nav-text">(b) 定义结构变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E8%AE%BF%E9%97%AE%E7%BB%93%E6%9E%84%E6%88%90%E5%91%98"><span class="nav-text">(c) 访问结构成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">(d) 结构体变量的初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84"><span class="nav-text">(B) 结构体数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89"><span class="nav-text">(a) 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">(b) 初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="nav-text">(C) 结构体指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%AE%9A%E4%B9%89-1"><span class="nav-text">(a) 定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E8%AE%BF%E9%97%AE%E6%88%90%E5%91%98%E5%80%BC"><span class="nav-text">(b) 访问成员值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="nav-text">(D) 结构体的嵌套</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-typedef"><span class="nav-text">(E) typedef</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E5%85%B1%E7%94%A8%E4%BD%93"><span class="nav-text">三. 共用体</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E5%AE%9A%E4%B9%89"><span class="nav-text">(A) 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E5%AE%9E%E4%BE%8B"><span class="nav-text">(B) 实例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="nav-text">(a) 问题描述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-text">(b) 代码实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="nav-text">四. 枚举类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E5%AE%9A%E4%B9%89-1"><span class="nav-text">(A) 定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E5%AE%9E%E4%BE%8B-1"><span class="nav-text">(B) 实例</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minwei Chen"
      src="/images/tuoqi.jpg">
  <p class="site-author-name" itemprop="name">Minwei Chen</p>
  <div class="site-description" itemprop="description">Cross the surface, get to the reality. Welcome to Cross Code!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AltriaChen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AltriaChen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mwchennju@foxmail.com" title="E-Mail → mailto:mwchennju@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/14/The-C03/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tuoqi.jpg">
      <meta itemprop="name" content="Minwei Chen">
      <meta itemprop="description" content="Cross the surface, get to the reality. Welcome to Cross Code!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cross Code">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C语言笔记(零三)：动态内存管理·结构体
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-01-14 10:39:36 / 修改时间：10:40:37" itemprop="dateCreated datePublished" datetime="2021-01-14T10:39:36+08:00">2021-01-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">C语言</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇主要介绍的是动态内存管理与结构体。除此之外，也介绍了共用体与枚举类型的简单用法。</p>
<a id="more"></a>

<h1 id="一-动态内存管理"><a href="#一-动态内存管理" class="headerlink" title="一. 动态内存管理"></a>一. 动态内存管理</h1><h2 id="A-简介"><a href="#A-简介" class="headerlink" title="(A) 简介"></a>(A) 简介</h2><h3 id="a-为什么存在"><a href="#a-为什么存在" class="headerlink" title="(a) 为什么存在"></a>(a) 为什么存在</h3><p>内存开辟的方式有：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">20</span>;  <span class="comment">//在栈空间上开辟四个字节</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//在栈空间上开辟10字节连续空间</span></span><br></pre></td></tr></table></figure>

<p>但是上述的开辟空间的方式有两个特点：</p>
<ol>
<li>空间开辟大小是固定的。</li>
<li>数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。</li>
</ol>
<p>但是对于空间的需求，不仅仅是上述的情况。有时候我们需要的空间大小在程序运行的时候才能知道，那数组的编译时开辟空间的方式就不能满足了。这时就需要使用动态内存管理。</p>
<h3 id="b-相关函数"><a href="#b-相关函数" class="headerlink" title="(b) 相关函数"></a>(b) 相关函数</h3><p>C 语言提供的动态内存管理函数主要有四个：</p>
<ul>
<li>malloc<br>– 申请动态内存空间</li>
<li>free<br>– 释放动态内存空间</li>
<li>calloc<br>– 申请并初始化一系列内存空间</li>
<li>realloc<br>– 重新分配内存空间</li>
</ul>
<h2 id="B-动态内存管理函数"><a href="#B-动态内存管理函数" class="headerlink" title="(B) 动态内存管理函数"></a>(B) 动态内存管理函数</h2><h3 id="a-malloc"><a href="#a-malloc" class="headerlink" title="(a) malloc"></a>(a) malloc</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>malloc 函数向系统申请分配连续可用的 size 个字节的内存空间，并返回一个指向这块空间的指针。</p>
<ul>
<li>如果函数调用成功，返回一个指向申请的内存空间的指针，由于返回类型是 void 指针 (void*)，所以它可以被转换成任何类型的数据；如果函数调用失败，返回值是 NULL。另外，如果 size 参数设置为 0，返回值也可能是 NULL，但这并不意味着函数调用失败。</li>
<li>补充：<ol>
<li>malloc 开辟空间是在堆上开辟空间。</li>
<li>之前栈上开辟数组大小在编译时就已经确定，malloc 是函数，所以堆空间只能在运行时确定。</li>
<li>malloc 开辟空间是程序员自己申请，自己释放，不释放就会出现内存泄漏问题。</li>
</ol>
</li>
</ul>
<h3 id="b-free"><a href="#b-free" class="headerlink" title="(b) free"></a>(b) free</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>free 函数释放 ptr 参数指向的内存空间。该内存空间必须是由 malloc、calloc 或 realloc 函数申请的。否则，该函数将导致未定义行为。如果 ptr 参数是 NULL，则不执行任何操作。<br>注意：该函数并不会修改 ptr 参数的值，所以调用后它仍然指向原来的地方(变为非法空间)。</p>
</li>
<li><p>实例：<br>malloc 和 free 都证明在 stdlib.h 头文件中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//代码1</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;num);</span><br><span class="line">    <span class="keyword">int</span> arr[num] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//代码2</span></span><br><span class="line">    <span class="keyword">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line">    ptr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(num*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != ptr)<span class="comment">//判断ptr指针是否为空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            *(ptr+i) = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(ptr);<span class="comment">//释放ptr所指向的动态内存</span></span><br><span class="line">    ptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>free 时释放的是指针和对应内存块的关系。</p>
</li>
</ul>
<h3 id="c-calloc"><a href="#c-calloc" class="headerlink" title="(c) calloc"></a>(c) calloc</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>calloc 函数在内存中动态地申请 nmemb 个长度为 size 的连续内存空间(即申请的总空间尺寸为 nmemb*size)，这些内存空间全部被初始化为 0。<br>以下两种写法是等价的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// calloc() 分配内存空间并初始化</span></span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span>*)<span class="built_in">calloc</span>(<span class="number">8</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// malloc() 分配内存空间并用 memset() 初始化</span></span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>calloc 函数与 malloc 函数的一个重要区别是：<br>– calloc 函数在申请完内存后，自动初始化该内存空间为零<br>– malloc 函数不进行初始化操作，里边数据是随机的</p>
</li>
<li><p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">calloc</span>(<span class="number">10</span>,<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> != p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//使用空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="d-realloc"><a href="#d-realloc" class="headerlink" title="(d) realloc"></a>(d) realloc</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr,<span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要注意以下几点：<br>(1) realloc 函数修改 ptr 指向的内存空间大小为 size 字节。<br>(2) 如果新分配的内存空间比原来的大，则旧内存块的数据不会发生改变；如果新的内存空间大小小于旧的内存空间，可能会导致数据丢失，慎用！<br>(3) 该函数将移动内存空间的数据并返回新的指针。<br>(4) 如果 ptr 参数为 NULL，那么调用该函数就相当于调用 malloc(size)；如果 size 参数为 0，并且 ptr 参数不为 NULL，那么调用该函数就相当于调用 free(ptr)；除非 ptr 参数为 NULL，否则 ptr 的值必须由先前调用 malloc、calloc 或 realloc 函数返回。</p>
</li>
</ul>
<h2 id="C-C语言的内存布局"><a href="#C-C语言的内存布局" class="headerlink" title="(C) C语言的内存布局"></a>(C) C语言的内存布局</h2><h3 id="a-概述"><a href="#a-概述" class="headerlink" title="(a) 概述"></a>(a) 概述</h3><p>一个程序本质上都是由 Bss 段，Data 段，Text 段三个组成的。这样的概念在计算机程序设计中是一个很重要的基本概念，而且在嵌入式系统的设计中也非常重要，牵涉到嵌入式系统运行时的内存大小分配，存储单元占用空间大小的问题。</p>
<p><img src="https://chenminwei-picture.oss-cn-beijing.aliyuncs.com/img/A2901.jpg"></p>
<ul>
<li>Bss 段：在采用段式内存管理的架构中，Bss 段通常是指用来存放程序中未初始化的全局变量的一块内存区域。Bss 是英文 Block Started by Symbol 的简称，Bss 段属于静态内存分配。</li>
<li>Data 段：在采用段式内存管理的架构中，Data 段通常是指用来存放程序中已初始化的全局变量的一块内存区域。Data 段属于静态内存分配。</li>
<li>Text 段：在采用段式内存管理的架构中，Text 段通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域属于只读。在 Text 段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
</ul>
<h3 id="b-堆-Heap-和栈-Stack"><a href="#b-堆-Heap-和栈-Stack" class="headerlink" title="(b) 堆 (Heap) 和栈 (Stack)"></a>(b) 堆 (Heap) 和栈 (Stack)</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="(1) 简介"></a>(1) 简介</h4><p>上图中，Text 即为代码段，为只读。Bss 段包含程序中未初始化的全局变量和 static 变量。 Data 段包含三个部分：Heap (堆)，Stack (栈) 和 Static Data (静态数据区)。</p>
<ul>
<li>堆 (Heap)：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用 malloc 等函数分配内存时，新分配的内存就被动态添加到堆上(堆被扩张)；当利用 free 等函数释放内存时，被释放的内存从堆中被剔除(堆被缩减)。</li>
<li>栈 (Stack)：栈又称堆栈，用来存放程序临时创建的局部变量。除此之外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把栈看成一个寄存、交换临时数据的内存区。</li>
</ul>
<p>当程序在执行时动态分配空间(C 中的 malloc 函数)，所分配的空间就属于 Heap。不过其概念与数据结构中的堆概念不同。Stack 存放函数内部的变量、参数和返回地址，其在函数被调用时自动分配，访问方式就是标准栈中的 LIFO 方式。</p>
<h4 id="2-区别"><a href="#2-区别" class="headerlink" title="(2) 区别"></a>(2) 区别</h4><ul>
<li>申请方式：<br>– 堆由程序员手动申请<br>– 栈由系统自动分配</li>
<li>释放方式：<br>– 堆由程序员手动释放<br>– 栈由系统自动释放</li>
<li>生存周期：<br>– 堆的生存周期由动态申请到程序员主动释放为止，不同函数之间均可自由访问<br>– 栈的生存周期由函数调用开始到函数返回时结束，函数之间的局部变量不能互相访问</li>
<li>发展方向：<br>– 堆和其它区段一样，都是从低地址向高地址发展<br>– 栈则相反，是由高地址向低地址发展</li>
</ul>
<h3 id="c-实例"><a href="#c-实例" class="headerlink" title="(c) 实例"></a>(c) 实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;  <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1;  <span class="comment">//全局未初始化区</span></span><br><span class="line"></span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> c = <span class="number">0</span>;  <span class="comment">//全局(静态)初始化区</span></span><br><span class="line">    <span class="keyword">int</span> b;  <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> s[] = <span class="string">&quot;abc&quot;</span>;  <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p2;  <span class="comment">//栈</span></span><br><span class="line">    <span class="keyword">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">//&quot;123456\0&quot;在常量区，p3在栈上</span></span><br><span class="line">    p1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    p2 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);  <span class="comment">//分配得来的10和20字节的区域就在堆区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="D-内联函数-inline"><a href="#D-内联函数-inline" class="headerlink" title="(D) 内联函数 inline"></a>(D) 内联函数 inline</h2><h3 id="a-什么是内联函数"><a href="#a-什么是内联函数" class="headerlink" title="(a) 什么是内联函数"></a>(a) 什么是内联函数</h3><ul>
<li><p>在 C 语言中，如果一些函数被频繁调用，不断地有函数入栈，即函数栈，会造成栈空间或栈内存的大量消耗。为了解决这个问题，特别引入了 inline 修饰符，表示为内联函数。<br>栈空间就是指放置程序的局部数据也就是函数内数据的内存空间。在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足所造成的程序出错的问题，例如函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>
</li>
<li><p>实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//函数定义为inline即:内联函数  </span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">dbtest</span><span class="params">(<span class="keyword">int</span> a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (i % <span class="number">2</span> &gt; <span class="number">0</span>) ? <span class="string">&quot;奇&quot;</span> : <span class="string">&quot;偶&quot;</span>;  </span><br><span class="line">&#125;   </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>; i &lt; <span class="number">100</span>; i++) </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i:%d  奇偶性:%s /n&quot;</span>, i, dbtest(i));      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的例子就是标准的内联函数的用法，使用 inline 修饰带来的好处我们表面看不出来，其实在内部的工作就是在每个 for 循环的内部任何调用 <code>dbtest(i)</code> 的地方都换成了 <code>(i%2&gt;0)?&quot;奇&quot;:&quot;偶&quot;</code>，这样就避免了频繁调用函数对栈内存重复开辟所带来的消耗。</p>
</li>
</ul>
<h3 id="b-内联函数的编程风格"><a href="#b-内联函数的编程风格" class="headerlink" title="(b) 内联函数的编程风格"></a>(b) 内联函数的编程风格</h3><ul>
<li><p>关键字 inline 必须与函数定义体放在一起才能使函数成为内联，仅将 inline 放在函数声明前面不起任何作用。<br>内联函数标准写法示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span>  <span class="comment">//inline须与函数定义体放在一起</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以说，inline 是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。<br>一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了 inline 关键字，但严谨地说，inline 不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量 C++/C 程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要，也不应该知道函数是否需要内联。</p>
</li>
<li><p>inline 的使用是有所限制的<br>inline 只适合函数体内代码简单的函数使用，不能包含复杂的结构控制语句例如 while、switch，并且内联函数本身不能是直接递归函数(自己内部还调用自己的函数)。</p>
</li>
</ul>
<h3 id="c-慎用内联"><a href="#c-慎用内联" class="headerlink" title="(c) 慎用内联"></a>(c) 慎用内联</h3><p>内联是以代码膨胀(复制)为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。<br>以下情况不宜使用内联：<br>(1) 如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。<br>(2) 如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。<br>一个好的编译器将会根据函数的定义体，自动地取消不值得的内联(这进一步说明了 inline 不应该出现在函数的声明中)。</p>
<h3 id="d-总结"><a href="#d-总结" class="headerlink" title="(d) 总结"></a>(d) 总结</h3><p>由以上分析，将内联函数放在头文件里实现是合适的，省却你为每个文件实现一次的麻烦。而声明跟定义要一致，其实是指，如果在每个文件里都实现一次该内联函数的话，那么，最好保证每个定义都是一样的。否则，将会引起未定义的行为，即是说，如果不是每个文件里的定义都一样，那么，编译器展开的是哪一个，那要看具体的编译器而定。所以，最好将内联函数定义放在头文件中。</p>
<h1 id="二-结构体"><a href="#二-结构体" class="headerlink" title="二. 结构体"></a>二. 结构体</h1><h2 id="A-结构体声明定义与初始化"><a href="#A-结构体声明定义与初始化" class="headerlink" title="(A) 结构体声明定义与初始化"></a>(A) 结构体声明定义与初始化</h2><p>结构体是 C 语言中一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。</p>
<h3 id="a-结构声明"><a href="#a-结构声明" class="headerlink" title="(a) 结构声明"></a>(a) 结构声明</h3><p>结构声明 (structure declaration) 是描述结构如何组合的主要方法。一般形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名&#123;</span></span><br><span class="line">    成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>struct 关键字表示接下来是一个结构体，如声明一个学生的结构：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>       <span class="comment">//声明结构体</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;          <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">float</span> score;      <span class="comment">//成绩</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>– 上面的声明描述了一个包含三个不同类型的成员的结构，但它还没创建一个实际的数据对象，类似 Python 中定义了类但还没进行类的实例化。<br>– 每个成员变量都用自己的声明来描述，以分号结束。<br>– 花括号之后的分号表示结构声明结束。<br>– 结构声明可以放在函数外(此时为全局结构体，类似全局变量，在它之后声明的所有函数都可以使用)，也可以放在函数内(此时为局部结构体，类似局部变量，只能放在该函数内使用，如果与全局结构体同名，则会暂时屏蔽全局结构体)。</p>
<h3 id="b-定义结构变量"><a href="#b-定义结构变量" class="headerlink" title="(b) 定义结构变量"></a>(b) 定义结构变量</h3><p>定义结构变量，其一般形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span>  <span class="comment">//定义结构体变量</span></span><br></pre></td></tr></table></figure>

<p>常用形式有<br>(1) 结构体变量的定义可以放在结构体的声明之后：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>       <span class="comment">//声明结构体</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];    <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;          <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">float</span> score;      <span class="comment">//成绩</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>;</span>  <span class="comment">//定义结构体变量</span></span><br></pre></td></tr></table></figure>

<p>(2) 结构体变量的定义也可以与结构体的声明同时，这样就简化了代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>        </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];       </span><br><span class="line">    <span class="keyword">int</span> num;             </span><br><span class="line">    <span class="keyword">float</span> score;         </span><br><span class="line">&#125;stu1;                <span class="comment">//在声明之后跟变量名</span></span><br></pre></td></tr></table></figure>

<p>(3) 还可以使用匿名结构体来定义结构体变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span>              <span class="comment">//没有结构名</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];       </span><br><span class="line">    <span class="keyword">int</span> num;            </span><br><span class="line">    <span class="keyword">float</span> score;         </span><br><span class="line">&#125;stu1; </span><br></pre></td></tr></table></figure>

<p>但要注意的是这样的方式虽然简单，但不能再次定义新的结构体变量了。</p>
<h3 id="c-访问结构成员"><a href="#c-访问结构成员" class="headerlink" title="(c) 访问结构成员"></a>(c) 访问结构成员</h3><p>(1) 虽然结构类似一个数组，只是数组元素的数据类型是相同的，而结构中元素的数据类型是可以不同的。但结构不能像数组那样使用下标去访问其中的各个元素，而应该用结构成员运算符点 (.)。即访问成员的一般形式是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结构变量名.成员名</span><br></pre></td></tr></table></figure>

<p>如 <code>stu1.name</code> 表示学生 stu1 的姓名。<br>(2) 但如果结构体中的成员又是一个结构体，如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Birthday</span>&#123;</span>              <span class="comment">//声明结构体 Birthday</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>               <span class="comment">//声明结构体 Student</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];              </span><br><span class="line">    <span class="keyword">int</span> num;                    </span><br><span class="line">    <span class="keyword">float</span> score;                 </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Birthday</span> <span class="title">birthday</span>;</span> <span class="comment">//生日</span></span><br><span class="line">&#125;stu1;</span><br></pre></td></tr></table></figure>

<p>则用 <code>stu1.birthday.year</code> 访问出生的年份。</p>
<h3 id="d-结构体变量的初始化"><a href="#d-结构体变量的初始化" class="headerlink" title="(d) 结构体变量的初始化"></a>(d) 结构体变量的初始化</h3><p>(1) 结构体变量的初始化可以放在定义之后，可以对结构体的成员逐个赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu1</span>, <span class="title">stu2</span>;</span>    <span class="comment">//定义结构体变量</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu1.name, <span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">stu1.num = <span class="number">18</span>;</span><br><span class="line">stu1.score = <span class="number">90.5</span>;</span><br></pre></td></tr></table></figure>

<p>注意：不能直接给数组名赋值，因为数组名是一个常量。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu1.name = <span class="string">&quot;Jack&quot;</span>; <span class="comment">//…main.c:26:15: Array type &#x27;char [20]&#x27; is not assignable</span></span><br></pre></td></tr></table></figure>

<p>或者可以对结构体进行整体赋值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stu2 = (struct Student)&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">15</span>, <span class="number">88.0</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>注意：此时要进行强制类型转换，因为数组赋值也是使用 { }，不转换的话系统无法区分！</p>
<p>(2) 结构体变量的初始化也可以与定义同时：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>             <span class="comment">//声明结构体 Student</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];               </span><br><span class="line">    <span class="keyword">int</span> num;                    </span><br><span class="line">    <span class="keyword">float</span> score;                 </span><br><span class="line">&#125;stu = &#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">15</span>, <span class="number">91</span>&#125;;    <span class="comment">//注意初始化值的类型和顺序要与结构体声明时成员的类型和顺序一致</span></span><br></pre></td></tr></table></figure>

<p>此时不需要强制类型转换。<br>也可以部分初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu4</span> = &#123;</span>.name = <span class="string">&quot;Lisa&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>也可以按照任意的顺序使用指定初始化项目：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st</span> = &#123;</span> .name = <span class="string">&quot;Smith&quot;</span>,</span><br><span class="line">                      .score = <span class="number">90.5</span>,</span><br><span class="line">                      .num = <span class="number">18</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>(3) 可以用一个已经存在的结构体去初始化一个新的相同类型的结构体变量，是整体的拷贝(每一个成员都一一赋值给新的结构体变量)，而不是地址赋值。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stu3 = stu1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stu1 addr: %p\nstu3 addr: %p\n&quot;</span>, &amp;stu1, &amp;stu3);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stu1.num: %d\nstu3.num: %d\n&quot;</span>, stu1.num, stu3.num);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;stu1.num addr: %p\nstu3.num addr: %p\n&quot;</span>, &amp;stu1.num, &amp;stu3.num);</span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">stu1 addr: <span class="number">0x10000104c</span></span><br><span class="line">stu3 addr: <span class="number">0x100001084</span></span><br><span class="line">stu1.num: <span class="number">18</span></span><br><span class="line">stu3.num: <span class="number">18</span></span><br><span class="line">stu1.num addr: <span class="number">0x100001060</span></span><br><span class="line">stu3.num addr: <span class="number">0x100001098</span></span><br></pre></td></tr></table></figure>

<h2 id="B-结构体数组"><a href="#B-结构体数组" class="headerlink" title="(B) 结构体数组"></a>(B) 结构体数组</h2><p>结构类型作为一种数据类型，也可以像基本数据类型那样，作为数组的元素的类型。元素属于结构类型的数组称为结构体数组。<br>生活中经常用到结构体数组来表示具有相同数据结构的一个群体，如一个班的学生信息，一个图书馆的书籍信息等。</p>
<h3 id="a-定义"><a href="#a-定义" class="headerlink" title="(a) 定义"></a>(a) 定义</h3><p>一般格式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名&#123;</span></span><br><span class="line">    成员列表</span><br><span class="line">&#125;数组名[数组长度];</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>           <span class="comment">//声明结构体 Student</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;stu[<span class="number">5</span>];                  <span class="comment">//定义一个结构结构数组stu，共有5个元素</span></span><br></pre></td></tr></table></figure>

<h3 id="b-初始化"><a href="#b-初始化" class="headerlink" title="(b) 初始化"></a>(b) 初始化</h3><p>(1) 定义结构体数组的同时进行初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>         </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;stu[<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">27</span>, <span class="number">91</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">15</span>, <span class="number">88.0</span>&#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>(2) 先定义，后初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>         </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;stu[<span class="number">2</span>];  </span><br><span class="line"></span><br><span class="line">stu[<span class="number">0</span>] = (struct Student)&#123;<span class="string">&quot;Mike&quot;</span>, <span class="number">27</span>, <span class="number">91</span>&#125;; </span><br><span class="line">stu[<span class="number">1</span>] = (struct Student)&#123;<span class="string">&quot;Tom&quot;</span>, <span class="number">15</span>, <span class="number">88.0</span>&#125;; </span><br></pre></td></tr></table></figure>

<p>(3) 可以将结构体变量的成员逐个赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>         </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">&#125;stu[<span class="number">2</span>];  </span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(stu[<span class="number">0</span>].name, <span class="string">&quot;Mike&quot;</span>);</span><br><span class="line">stu[<span class="number">0</span>].num = <span class="number">27</span>;</span><br><span class="line">stu[<span class="number">0</span>].score = <span class="number">91</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(stu[<span class="number">1</span>].name, <span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">stu[<span class="number">1</span>].num = <span class="number">15</span>;</span><br><span class="line">stu[<span class="number">1</span>].score = <span class="number">88.0</span>;</span><br></pre></td></tr></table></figure>

<p>输出结构体示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体数组的长度：</span></span><br><span class="line"><span class="keyword">int</span> length = <span class="keyword">sizeof</span>(stu) / <span class="keyword">sizeof</span>(struct Student);</span><br><span class="line"><span class="comment">//逐个输出结构数组的元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s  学号：%d  成绩：%f \n&quot;</span>, stu[i].name, stu[i].num, stu[i].score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="C-结构体指针"><a href="#C-结构体指针" class="headerlink" title="(C) 结构体指针"></a>(C) 结构体指针</h2><p>当一个指针变量用来指向了一个结构变量，这个指针就成了结构指针变量。</p>
<h3 id="a-定义-1"><a href="#a-定义-1" class="headerlink" title="(a) 定义"></a>(a) 定义</h3><p>定义结构指针变量的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构名 *结构指针变量名;</span></span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">pstu</span>;</span>   <span class="comment">//定义了一个指针变量，它只能指向Student结构体类型的结构体变量</span></span><br></pre></td></tr></table></figure>

<p>结构指针变量的定义也可以与结构体的定义同时，而且它必须先赋值后使用。<br>数组名表示的是数组的首地址，可以直接赋值给数组指针。但结构变量名只是表示整个结构体变量，不表示结构体变量的首地址，所以不能直接赋值给结构体指针，而应该使用 &amp; 运算符把结构变量的地址赋值给结构指针变量。即：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">pstu</span>;</span> </span><br><span class="line">pstu = &amp;stu1;</span><br></pre></td></tr></table></figure>

<h3 id="b-访问成员值"><a href="#b-访问成员值" class="headerlink" title="(b) 访问成员值"></a>(b) 访问成员值</h3><p>通过结构指针间接访问成员值<br>访问的一般形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(*结构指针变量).成员名</span><br><span class="line">或</span><br><span class="line">结构指针变量-&gt;成员名</span><br></pre></td></tr></table></figure>

<p>如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*pstu).name</span><br><span class="line">pstu-&gt;name</span><br></pre></td></tr></table></figure>

<h2 id="D-结构体的嵌套"><a href="#D-结构体的嵌套" class="headerlink" title="(D) 结构体的嵌套"></a>(D) 结构体的嵌套</h2><p>(1) 结构体中的成员可以又是一个结构体，构成结构体的嵌套：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Birthday</span>&#123;</span>                <span class="comment">//声明结构体Birthday</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>                 <span class="comment">//声明结构体Student</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];              </span><br><span class="line">    <span class="keyword">int</span> num;                    </span><br><span class="line">    <span class="keyword">float</span> score;                 </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Birthday</span> <span class="title">birthday</span>;</span>   <span class="comment">//生日</span></span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<p>(2) 结构体不可以嵌套跟自己类型相同的结构体，但可以嵌套定义自己的指针。如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>                 <span class="comment">//声明结构体 Student</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">friend</span>;</span>     <span class="comment">//嵌套定义自己的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(3) 可以多层嵌套：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Time</span>&#123;</span>                    <span class="comment">//声明结构体 Time</span></span><br><span class="line">    <span class="keyword">int</span> hh;                     <span class="comment">//时</span></span><br><span class="line">    <span class="keyword">int</span> mm;                     <span class="comment">//分</span></span><br><span class="line">    <span class="keyword">int</span> ss;                     <span class="comment">//秒</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Birthday</span>&#123;</span>                <span class="comment">//声明结构体 Birthday</span></span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Time</span> <span class="title">dateTime</span>        //嵌套结构</span></span><br><span class="line"><span class="class">&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>                 <span class="comment">//声明结构体 Student</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">float</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Birthday</span> <span class="title">birthday</span>;</span>   <span class="comment">//嵌套结构</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义并初始化</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stud</span> = &#123;</span><span class="string">&quot;Jack&quot;</span>, <span class="number">32</span>, <span class="number">85</span>, &#123;<span class="number">1990</span>, <span class="number">12</span>, <span class="number">3</span>, &#123;<span class="number">12</span>, <span class="number">43</span>, <span class="number">23</span>&#125;&#125;&#125;;</span><br><span class="line"><span class="comment">//访问嵌套结构的成员并输出</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s 的出生时刻：%d时 \n&quot;</span>, stud.name, stud.birthday.dateTime.hh);</span><br><span class="line"><span class="comment">//输出结果：Jack 的出生时刻：12时 </span></span><br></pre></td></tr></table></figure>

<h2 id="E-typedef"><a href="#E-typedef" class="headerlink" title="(E) typedef"></a>(E) typedef</h2><ul>
<li><p>typedef 用来为复杂的声明定义简单的别名。它本身是一种存储类的关键字，与 auto，register，static，extern 等关键字不能出现在同一个表达式中。</p>
</li>
<li><p>例如给 int 型起一个新的别名 BOOL</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> BOOL;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line">BOOL flag = TRUE;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义新的结构体 student，并给结构体起新的别名 LinkList</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> cName[<span class="number">20</span>]; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> iNumber;    <span class="comment">//电话号码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span> <span class="comment">//指向写一个结点</span></span><br><span class="line">&#125; LinkList;</span><br><span class="line">LinkList *head;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义结构体指针，例如定义 struct student { }* 的别名为 LinkList</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">student</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> cName[<span class="number">20</span>]; <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> iNumber;    <span class="comment">//电话号码</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">student</span> *<span class="title">next</span>;</span> <span class="comment">//指向下一个结点</span></span><br><span class="line">&#125;*LinkList;</span><br><span class="line">LinkList head;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="三-共用体"><a href="#三-共用体" class="headerlink" title="三. 共用体"></a>三. 共用体</h1><h2 id="A-定义"><a href="#A-定义" class="headerlink" title="(A) 定义"></a>(A) 定义</h2><ul>
<li><p>在 C 语言中，还有一种和结构体非常类似的语法，叫做共用体 (Union)。共用体有时也称为联合或联合体，这也是 Union 这个单词的本意，它的定义格式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> 共用体名&#123;</span><br><span class="line">    成员列表</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>结构体和共用体的区别在于：结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员占用同一段内存，修改一个成员会影响其余所有成员。<br>结构体占用的内存大于等于所有成员占用的内存的总和(成员之间可能会存在缝隙)，共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
</li>
<li><p>共用体也是一种自定义类型，可以通过它来创建变量。例如<br>(1) 先定义共用体，再创建变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> data a, b, c;</span><br></pre></td></tr></table></figure>

<p>(2) 可以在定义共用体的同时创建变量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> data&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure>

<p>(3) 如果不再定义新的变量，也可以将共用体的名字省略</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">double</span> f;</span><br><span class="line">&#125; a, b, c;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="B-实例"><a href="#B-实例" class="headerlink" title="(B) 实例"></a>(B) 实例</h2><h3 id="a-问题描述"><a href="#a-问题描述" class="headerlink" title="(a) 问题描述"></a>(a) 问题描述</h3><p>共用体在一般的编程中应用较少，在单片机中应用较多。对于 PC 机，经常用到的一个实例是：现有一张关于学生信息和教师信息的表格。学生信息包括姓名、编号、性别、职业、分数，教师的信息包括姓名、编号、性别、职业、教学科目。请看下面的表格：</p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Num</th>
<th>Sex</th>
<th>Profession</th>
<th>Score/Course</th>
</tr>
</thead>
<tbody><tr>
<td>HanXiaoXiao</td>
<td>501</td>
<td>f</td>
<td>s</td>
<td>89.5</td>
</tr>
<tr>
<td>YanWeiMin</td>
<td>1011</td>
<td>m</td>
<td>t</td>
<td>Math</td>
</tr>
<tr>
<td>LiuZhenTao</td>
<td>109</td>
<td>f</td>
<td>t</td>
<td>English</td>
</tr>
<tr>
<td>ZhaoFeiYan</td>
<td>982</td>
<td>m</td>
<td>s</td>
<td>95.0</td>
</tr>
</tbody></table>
<p>f 和 m 分别表示女性和男性，s 表示学生，t 表示教师。可以看出，学生和教师所包含的数据是不同的。现在要求把这些信息放在同一个表格中，并设计程序输入人员信息然后输出。<br>如果把每个人的信息都看作一个结构体变量的话，那么教师和学生的前 4 个成员变量是一样的，第 5 个成员变量可能是 score 或者 course。当第 4 个成员变量的值是 s 的时候，第 5 个成员变量就是 score；当第 4 个成员变量的值是 t 的时候，第 5 个成员变量就是 course。</p>
<h3 id="b-代码实现"><a href="#b-代码实现" class="headerlink" title="(b) 代码实现"></a>(b) 代码实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOTAL 4  <span class="comment">//人员总数</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Body</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">char</span> profession;</span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">float</span> score;</span><br><span class="line">        <span class="keyword">char</span> course[<span class="number">20</span>];</span><br><span class="line">    &#125; sc;</span><br><span class="line">&#125; bodys[TOTAL];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">//输入人员信息</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Input info: &quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %c %c&quot;</span>, bodys[i].name, &amp;(bodys[i].num), &amp;(bodys[i].sex), &amp;(bodys[i].profession));</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123;  <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%f&quot;</span>, &amp;bodys[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//输出人员信息</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\nName\t\tNum\tSex\tProfession\tScore / Course\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;TOTAL; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(bodys[i].profession == <span class="string">&#x27;s&#x27;</span>)&#123;  <span class="comment">//如果是学生</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%f\n&quot;</span>, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.score);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果是老师</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%c\t%c\t\t%s\n&quot;</span>, bodys[i].name, bodys[i].num, bodys[i].sex, bodys[i].profession, bodys[i].sc.course);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Input info: HanXiaoXiao <span class="number">501</span> f s <span class="number">89.5</span></span><br><span class="line">Input info: YanWeiMin <span class="number">1011</span> m t Math</span><br><span class="line">Input info: LiuZhenTao <span class="number">109</span> f t English</span><br><span class="line">Input info: ZhaoFeiYan <span class="number">982</span> m s <span class="number">95.0</span></span><br><span class="line"></span><br><span class="line">Name            Num     Sex     Profession      Score / Course</span><br><span class="line">HanXiaoXiao     <span class="number">501</span>     f       s               <span class="number">89.500000</span></span><br><span class="line">YanWeiMin       <span class="number">1011</span>    m       t               Math</span><br><span class="line">LiuZhenTao      <span class="number">109</span>     f       t               English</span><br><span class="line">ZhaoFeiYan      <span class="number">982</span>     m       s               <span class="number">95.000000</span></span><br></pre></td></tr></table></figure>

<h1 id="四-枚举类型"><a href="#四-枚举类型" class="headerlink" title="四. 枚举类型"></a>四. 枚举类型</h1><h2 id="A-定义-1"><a href="#A-定义-1" class="headerlink" title="(A) 定义"></a>(A) 定义</h2><ul>
<li><p>枚举类型在 C# 或 C++，java，VB 等一些计算机编程语言中是一种基本数据类型而不是构造数据类型，而在 C 语言等计算机编程语言中是一种构造数据类型 。它用于声明一组命名的常数，当一个变量有几种可能的取值时，可以将它定义为枚举类型。</p>
</li>
<li><p>枚举类型的定义形式为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> typeName&#123; valueName1, valueName2, valueName3, ...... &#125;;</span><br></pre></td></tr></table></figure>

<p><code>enum</code> 是专门用来定义枚举类型的关键字；<code>typeName</code> 是枚举类型的名字；<code>valueName1, valueName2, valueName3, ......</code> 是每个值对应的名字的列表。</p>
</li>
<li><p>例如，列出一个星期有几天：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week&#123; Mon, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们仅仅给出了名字，却没有给出名字对应的值，这是因为枚举值默认从 0 开始，往后逐个加 1 (递增)；也就是说，week 中的 Mon、Tues …… Sun 对应的值分别为 0、1 …… 6。<br>(1) 我们也可以给每个名字指定一个值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week&#123; Mon = <span class="number">1</span>, Tues = <span class="number">2</span>, Wed = <span class="number">3</span>, Thurs = <span class="number">4</span>, Fri = <span class="number">5</span>, Sat = <span class="number">6</span>, Sun = <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>(2) 更为简单的方法是只给第一个名字指定值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week&#123; Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>这样枚举值就从 1 开始递增，跟上面的写法是等效的。</p>
</li>
<li><p>(1) 枚举是一种类型，通过它可以定义枚举变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week a, b, c;</span><br></pre></td></tr></table></figure>

<p>(2) 也可以在定义枚举类型的同时定义变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week&#123; Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a, b, c;</span><br></pre></td></tr></table></figure>

<p>(3) 有了枚举变量，就可以把列表中的值赋给它：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week&#123; Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br><span class="line"><span class="keyword">enum</span> week a = Mon, b = Wed, c = Sat;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> week&#123; Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; a = Mon, b = Wed, c = Sat;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="B-实例-1"><a href="#B-实例-1" class="headerlink" title="(B) 实例"></a>(B) 实例</h2><p>判断用户输入的是星期几</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">enum</span> week&#123; Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125; day;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;day);</span><br><span class="line">    <span class="keyword">switch</span>(day)&#123;</span><br><span class="line">        <span class="keyword">case</span> Mon: <span class="built_in">puts</span>(<span class="string">&quot;Monday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Tues: <span class="built_in">puts</span>(<span class="string">&quot;Tuesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Wed: <span class="built_in">puts</span>(<span class="string">&quot;Wednesday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Thurs: <span class="built_in">puts</span>(<span class="string">&quot;Thursday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Fri: <span class="built_in">puts</span>(<span class="string">&quot;Friday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Sat: <span class="built_in">puts</span>(<span class="string">&quot;Saturday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Sun: <span class="built_in">puts</span>(<span class="string">&quot;Sunday&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">puts</span>(<span class="string">&quot;Error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">Friday</span><br></pre></td></tr></table></figure>


    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag"># C语言</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/08/The-C02/" rel="prev" title="C语言笔记(零二)：指针">
      <i class="fa fa-chevron-left"></i> C语言笔记(零二)：指针
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/01/20/The-C04/" rel="next" title="C语言笔记(零四)：位·文件操作·流与缓冲">
      C语言笔记(零四)：位·文件操作·流与缓冲 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minwei Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
