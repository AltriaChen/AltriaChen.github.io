<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="本篇介绍的是 C++ 面向对象编程的基本要点。内容包括类，继承，方法的相关操作。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++笔记(零二)：类和对象·属性和方法">
<meta property="og:url" content="http://yoursite.com/2021/01/28/Cpplus02/index.html">
<meta property="og:site_name" content="Cross Code">
<meta property="og:description" content="本篇介绍的是 C++ 面向对象编程的基本要点。内容包括类，继承，方法的相关操作。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-01-28T02:02:02.000Z">
<meta property="article:modified_time" content="2021-04-20T08:32:12.000Z">
<meta property="article:author" content="Minwei Chen">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/2021/01/28/Cpplus02/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++笔记(零二)：类和对象·属性和方法 | Cross Code</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cross Code</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">There is only one heroism in the world: to see the world as it is and to love it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E7%B1%BB"><span class="nav-text">一. 类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E5%AE%9A%E4%B9%89"><span class="nav-text">(A) 定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="nav-text">(a) 类定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="nav-text">(b) 定义对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E7%B1%BB%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">(c) 类成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="nav-text">(1) 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E4%BE%8B"><span class="nav-text">(2) 实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%B1%BB%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">(B) 类访问修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%AE%BF%E9%97%AE%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="nav-text">(a) 访问修饰符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9E%8B"><span class="nav-text">(b) 访问属性继承类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-text">(c) 友元函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E4%BE%8B-1"><span class="nav-text">(2) 实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%9E%84%E9%80%A0%E4%B8%8E%E6%9E%90%E6%9E%84"><span class="nav-text">(C) 构造与析构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%9E%84%E9%80%A0"><span class="nav-text">(a) 构造</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">(1) 类的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">(2) 带参数的构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9D%A5%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">(3) 使用初始化列表来初始化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E6%9E%90%E6%9E%84"><span class="nav-text">(b) 析构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B1%BB%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-text">(1) 类的析构函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-this-%E6%8C%87%E9%92%88"><span class="nav-text">(D) this 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="nav-text">(a) 如何理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-this"><span class="nav-text">(b) 为什么需要 this</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-this-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-text">(c) this 的使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E5%AE%9E%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="nav-text">(d) 实例说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E7%BB%A7%E6%89%BF"><span class="nav-text">二. 继承</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E5%AE%9A%E4%B9%89%E5%AD%90%E7%B1%BB"><span class="nav-text">(A) 定义子类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%92%8C%E7%BB%A7%E6%89%BF"><span class="nav-text">(B) 访问控制和继承</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9E%8B"><span class="nav-text">(C) 访问属性继承类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-text">(D) 多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%AF%AD%E6%B3%95"><span class="nav-text">(a) 语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%9E%E4%BE%8B"><span class="nav-text">(b) 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-text">(c) 虚继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-1"><span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%AF%AD%E6%B3%95"><span class="nav-text">(2) 语法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E6%96%B9%E6%B3%95%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="nav-text">三. 方法相关操作</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E8%A6%86%E7%9B%96%E4%B8%8E%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="nav-text">(A) 覆盖与重载方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%A6%86%E7%9B%96%E6%96%B9%E6%B3%95"><span class="nav-text">(a) 覆盖方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-2"><span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%8F%91%E7%94%9F%E8%A6%86%E7%9B%96%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-text">(2) 发生覆盖的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%AE%9E%E4%BE%8B"><span class="nav-text">(3) 实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E9%87%8D%E8%BD%BD%E6%96%B9%E6%B3%95"><span class="nav-text">(b) 重载方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0-3"><span class="nav-text">(1) 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%AE%9E%E4%BE%8B-2"><span class="nav-text">(2) 实例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%B0%8F%E7%BB%93"><span class="nav-text">(c) 小结</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">(B) 静态属性和静态方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E9%9D%99%E6%80%81"><span class="nav-text">(a) 静态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%9D%99%E6%80%81%E5%B1%9E%E6%80%A7%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="nav-text">(b) 为什么需要静态属性和静态方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="nav-text">(c) 静态数据成员</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">(d) 静态成员函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-%E7%B1%BB%E5%86%85%E5%A4%96%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E6%A0%BC%E5%BC%8F"><span class="nav-text">(e) 类内外声明静态成员格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%B1%BB%E5%86%85%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">(1) 类内声明静态成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E7%B1%BB%E5%A4%96%E5%A3%B0%E6%98%8E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F"><span class="nav-text">(2) 类外声明静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E7%B1%BB%E5%A4%96%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">(3) 类外实现静态成员</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-%E5%AE%9E%E4%BE%8B"><span class="nav-text">(f) 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E6%96%B9%E6%B3%95"><span class="nav-text">(C) 虚函数和虚方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9A%E5%AE%9E%E7%8E%B0%E7%B1%BB%E7%9A%84%E5%A4%9A%E6%80%81%E6%80%A7"><span class="nav-text">(a) 虚函数：实现类的多态性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="nav-text">(b) 虚函数的底层实现机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E6%8E%A5%E5%8F%A3%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-text">(D) 接口和抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%A6%82%E8%BF%B0"><span class="nav-text">(a) 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%9E%E4%BE%8B-1"><span class="nav-text">(b) 实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-%E5%A4%9A%E6%80%81"><span class="nav-text">(E) 多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%A4%9A%E6%80%81%E5%AE%9A%E4%B9%89%E5%8F%8A%E6%9E%84%E6%88%90%E6%9D%A1%E4%BB%B6"><span class="nav-text">(a) 多态定义及构成条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%AE%9E%E4%BE%8B-2"><span class="nav-text">(b) 实例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E9%87%8D%E5%86%99%E9%97%AE%E9%A2%98"><span class="nav-text">(c) 析构函数重写问题</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minwei Chen"
      src="/images/tuoqi.jpg">
  <p class="site-author-name" itemprop="name">Minwei Chen</p>
  <div class="site-description" itemprop="description">Cross the surface, get to the reality. Welcome to Cross Code!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AltriaChen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AltriaChen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mwchennju@foxmail.com" title="E-Mail → mailto:mwchennju@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/01/28/Cpplus02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tuoqi.jpg">
      <meta itemprop="name" content="Minwei Chen">
      <meta itemprop="description" content="Cross the surface, get to the reality. Welcome to Cross Code!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cross Code">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++笔记(零二)：类和对象·属性和方法
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-01-28 10:02:02" itemprop="dateCreated datePublished" datetime="2021-01-28T10:02:02+08:00">2021-01-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-20 16:32:12" itemprop="dateModified" datetime="2021-04-20T16:32:12+08:00">2021-04-20</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>本篇介绍的是 C++ 面向对象编程的基本要点。内容包括类，继承，方法的相关操作。</p>
<a id="more"></a>

<h1 id="一-类"><a href="#一-类" class="headerlink" title="一. 类"></a>一. 类</h1><h2 id="A-定义"><a href="#A-定义" class="headerlink" title="(A) 定义"></a>(A) 定义</h2><h3 id="a-类定义"><a href="#a-类定义" class="headerlink" title="(a) 类定义"></a>(a) 类定义</h3><p>类定义是以关键字 class 开头，后跟类的名称。类的主体是包含在一对花括号中，类定义后必须跟着一个分号或一个声明列表。<br>例如，我们使用关键字 class 定义 Box 数据类型，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> length;    <span class="comment">// 盒子的长度</span></span><br><span class="line">        <span class="keyword">double</span> breadth;   <span class="comment">// 盒子的宽度</span></span><br><span class="line">        <span class="keyword">double</span> <span class="built_in">height</span>;    <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关键字 public 确定了类成员的访问属性，这里 public 声明了在类对象的作用域内，公共成员在类的外部是可以访问的。您也可以指定类的成员为 private 或 protected，这个在类访问修饰符中讲解。</p>
<h3 id="b-定义对象"><a href="#b-定义对象" class="headerlink" title="(b) 定义对象"></a>(b) 定义对象</h3><p>类提供了对象的蓝图，对象是根据类来创建的。声明类的对象，就像声明基本类型的变量一样。下面的语句声明了类 Box 的两个对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box box1;  <span class="comment">//声明box1,类型为Box</span></span><br><span class="line">Box box2;  <span class="comment">//声明box2,类型为Box</span></span><br></pre></td></tr></table></figure>

<p>对象 box1 和 box2 都有它们各自的数据成员</p>
<h3 id="c-类成员函数"><a href="#c-类成员函数" class="headerlink" title="(c) 类成员函数"></a>(c) 类成员函数</h3><p>类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。</p>
<h4 id="1-定义"><a href="#1-定义" class="headerlink" title="(1) 定义"></a>(1) 定义</h4><p>成员函数可以定义在类定义内部，或者单独使用范围解析运算符 <code>::</code> 来定义。在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。所以您可以按照如下方式定义 Volume( ) 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> length;  <span class="comment">// 长度</span></span><br><span class="line">        <span class="keyword">double</span> breadth; <span class="comment">// 宽度</span></span><br><span class="line">        <span class="keyword">double</span> <span class="built_in">height</span>;  <span class="comment">// 高度</span></span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getVolume</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">//返回体积</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> length*breadth*<span class="built_in">height</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>您也可以在类的外部使用范围解析运算符 <code>::</code> 定义该函数，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getVolume</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length*breadth*<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这里，需要强调一点，在 <code>::</code> 运算符之前必须使用类名。调用成员函数是在对象上使用点运算符 (.)，这样它就能操作与该对象相关的数据，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box mybox;           <span class="comment">// 创建一个对象</span></span><br><span class="line">myBox.getVolume();   <span class="comment">// 调用该对象的成员函数</span></span><br></pre></td></tr></table></figure>

<h4 id="2-实例"><a href="#2-实例" class="headerlink" title="(2) 实例"></a>(2) 实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;   <span class="comment">// 高度</span></span><br><span class="line">      <span class="comment">// 成员函数声明</span></span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">get</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">( <span class="keyword">double</span> len, <span class="keyword">double</span> bre, <span class="keyword">double</span> hei )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::get</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * <span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Box::set</span><span class="params">( <span class="keyword">double</span> len, <span class="keyword">double</span> bre, <span class="keyword">double</span> hei)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    breadth = bre;</span><br><span class="line">    <span class="built_in">height</span> = hei;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Box Box1;        <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">   Box Box2;        <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">   <span class="keyword">double</span> volume = <span class="number">0.0</span>;     <span class="comment">// 用于存储体积</span></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 1 详述</span></span><br><span class="line">   Box1.<span class="built_in">height</span> = <span class="number">5.0</span>; </span><br><span class="line">   Box1.length = <span class="number">6.0</span>; </span><br><span class="line">   Box1.breadth = <span class="number">7.0</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 2 详述</span></span><br><span class="line">   Box2.<span class="built_in">set</span>(<span class="number">10.0</span>, <span class="number">12.0</span>, <span class="number">13.0</span>); </span><br><span class="line"></span><br><span class="line">   <span class="comment">// box 1 的体积</span></span><br><span class="line">   volume = Box1.<span class="built_in">height</span> * Box1.length * Box1.breadth;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// box 2 的体积</span></span><br><span class="line">   volume = Box2.<span class="built_in">get</span>();</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积：<span class="number">210</span></span><br><span class="line">Box2 的体积：<span class="number">1560</span></span><br></pre></td></tr></table></figure>

<h2 id="B-类访问修饰符"><a href="#B-类访问修饰符" class="headerlink" title="(B) 类访问修饰符"></a>(B) 类访问修饰符</h2><p>数据封装是面向对象编程的一个重要特点，它防止函数直接访问类的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 public，private，protected 来指定的。关键字 public，private，protected 称为访问修饰符。<br>一个类可以有多个 public，private，protected 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。</p>
<h3 id="a-访问修饰符"><a href="#a-访问修饰符" class="headerlink" title="(a) 访问修饰符"></a>(a) 访问修饰符</h3><ul>
<li><p>公有成员 public<br>公有成员在程序中类的外部是可访问的。您可以不使用任何成员函数来设置和获取公有变量的值。</p>
</li>
<li><p>私有成员 private<br>私有成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。<br>默认情况下，类的所有成员都是私有的。例如在下面的类中，width 是一个私有成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">double</span> <span class="built_in">width</span>;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">double</span> length;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">double</span> wid)</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">getWidth</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getWidth</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">width</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Box::getWidth</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">width</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Box::setWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">width</span> = wid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Box box;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 不使用成员函数设置长度</span></span><br><span class="line">   box.length = <span class="number">10.0</span>;   <span class="comment">// OK: 因为 length 是公有的 </span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of box : &quot;</span> &lt;&lt; box.length &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">/* 不使用成员函数设置宽度 </span></span><br><span class="line"><span class="comment">   box.width = 10.0;  Error: 因为 width 是私有的   */</span></span><br><span class="line">   box.setWidth(<span class="number">10.0</span>);  <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span> &lt;&lt; box.getWidth() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>受保护成员 protected<br>protected 成员变量或函数与私有成员十分相似，但有一点不同，protected 成员在派生类(即子类)中是可访问的。<br>例如下面的实例，我们从父类 Box 派生了一个子类 smallBox，在这里 protected 修饰的 width 成员可被派生类 smallBox 的任何成员函数访问。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">width</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallBox</span>:</span>Box <span class="comment">// SmallBox 是派生类</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setSmallWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getSmallWidth</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子类的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">SmallBox::getSmallWidth</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">width</span> ;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SmallBox::setSmallWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">width</span> = wid;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   SmallBox box;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 使用成员函数设置宽度</span></span><br><span class="line">   box.setSmallWidth(<span class="number">5.0</span>);</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Width of box : &quot;</span>&lt;&lt; box.getSmallWidth() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="b-访问属性继承类型"><a href="#b-访问属性继承类型" class="headerlink" title="(b) 访问属性继承类型"></a>(b) 访问属性继承类型</h3><ul>
<li><p>有 public，protected，private 三种继承方式，它们相应地改变了基类成员的访问属性。</p>
<ol>
<li>public 继承：基类 public，protected，private 成员的访问属性在派生类中分别变成：public，protected，private</li>
<li>protected 继承：基类 public，protected，private 成员的访问属性在派生类中分别变成：protected，protected，private</li>
<li>private 继承：基类 public，protected，private 成员的访问属性在派生类中分别变成：private，private，private</li>
</ol>
</li>
<li><p>下面两条恒成立：</p>
<ol>
<li>private 成员只能被本类成员(类内)和友元访问，不能被派生类访问</li>
<li>protected 成员可以被派生类访问</li>
</ol>
</li>
</ul>
<h3 id="c-友元函数"><a href="#c-友元函数" class="headerlink" title="(c) 友元函数"></a>(c) 友元函数</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="(1) 概述"></a>(1) 概述</h4><p>类的友元函数是定义在类外部，但有权访问类的所有 private 成员和 protected 成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。<br>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<h4 id="2-实例-1"><a href="#2-实例-1" class="headerlink" title="(2) 实例"></a>(2) 实例</h4><p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">double</span> <span class="built_in">width</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">double</span> length;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printWidth</span><span class="params">( Box box )</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">( <span class="keyword">double</span> wid )</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>声明 ClassTwo 的所有成员函数作为类 ClassOne 的友元，需要在类 ClassOne 的定义中放置如下声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTwo</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="C-构造与析构"><a href="#C-构造与析构" class="headerlink" title="(C) 构造与析构"></a>(C) 构造与析构</h2><h3 id="a-构造"><a href="#a-构造" class="headerlink" title="(a) 构造"></a>(a) 构造</h3><h4 id="1-类的构造函数"><a href="#1-类的构造函数" class="headerlink" title="(1) 类的构造函数"></a>(1) 类的构造函数</h4><p>类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。<br>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>下面的实例有助于更好地理解构造函数的概念：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line();  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Line <span class="built_in">line</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置长度</span></span><br><span class="line">   <span class="built_in">line</span>.setLength(<span class="number">6.0</span>); </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; <span class="built_in">line</span>.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object is being created</span><br><span class="line">Length of <span class="built_in">line</span> : <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="2-带参数的构造函数"><a href="#2-带参数的构造函数" class="headerlink" title="(2) 带参数的构造函数"></a>(2) 带参数的构造函数</h4><p>默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数，这样在创建对象时就会给对象赋初始值。如下面的例子所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line(<span class="keyword">double</span> len);  <span class="comment">// 这是构造函数</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line( <span class="keyword">double</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being created, length = &quot;</span> &lt;&lt; len &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10.0</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取默认设置的长度</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; <span class="built_in">line</span>.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">// 再次设置长度</span></span><br><span class="line">   <span class="built_in">line</span>.setLength(<span class="number">6.0</span>); </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; <span class="built_in">line</span>.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object is being created, length = <span class="number">10</span></span><br><span class="line">Length of <span class="built_in">line</span> : <span class="number">10</span></span><br><span class="line">Length of <span class="built_in">line</span> : <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h4 id="3-使用初始化列表来初始化"><a href="#3-使用初始化列表来初始化" class="headerlink" title="(3) 使用初始化列表来初始化"></a>(3) 使用初始化列表来初始化</h4><p>假设有一个类 C，具有多个字段 X，Y，Z 等需要进行初始化，可使用如下语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C::C(<span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c): X(a), Y(b), Z(c)</span><br><span class="line">&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="b-析构"><a href="#b-析构" class="headerlink" title="(b) 析构"></a>(b) 析构</h3><h4 id="1-类的析构函数"><a href="#1-类的析构函数" class="headerlink" title="(1) 类的析构函数"></a>(1) 类的析构函数</h4><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。<br>析构函数的名字与类的名称是完全相同的，只是在前面加了个波浪号 (~) 作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序(如关闭文件，释放内存等)前释放资源。<br>下面的实例有助于更好地理解析构函数的概念：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span>;</span><br><span class="line">      <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">( <span class="keyword">void</span> )</span></span>;</span><br><span class="line">      Line();   <span class="comment">// 这是构造函数声明</span></span><br><span class="line">      ~Line();  <span class="comment">// 这是析构函数声明</span></span><br><span class="line"> </span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being created&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Line::~Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Object is being deleted&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Line::setLength</span><span class="params">( <span class="keyword">double</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Line::getLength</span><span class="params">( <span class="keyword">void</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Line <span class="built_in">line</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置长度</span></span><br><span class="line">   <span class="built_in">line</span>.setLength(<span class="number">6.0</span>); </span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Length of line : &quot;</span> &lt;&lt; <span class="built_in">line</span>.getLength() &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object is being created</span><br><span class="line">Length of <span class="built_in">line</span> : <span class="number">6</span></span><br><span class="line">Object is being deleted</span><br></pre></td></tr></table></figure>

<h2 id="D-this-指针"><a href="#D-this-指针" class="headerlink" title="(D) this 指针"></a>(D) this 指针</h2><h3 id="a-如何理解"><a href="#a-如何理解" class="headerlink" title="(a) 如何理解"></a>(a) 如何理解</h3><ul>
<li>关于 this 指针的一个经典回答：<br>当你进入一个房子后，你可以看见桌子、椅子、地板等，但是房子你是看不到全貌了。<br>对于一个类的实例来说，你可以看到它的成员函数、成员变量，但是实例本身呢？this 是这样的一个指针，它时时刻刻指向实例本身。</li>
<li>class 类就好比这座房子，this 就好比一把钥匙，通过钥匙来打开了这座房子的门，那么里面的东西就随意你取用了。</li>
<li>this 是指向实例对象本身的地址，通过该地址可以访问内部的成员函数和成员变量。</li>
</ul>
<h3 id="b-为什么需要-this"><a href="#b-为什么需要-this" class="headerlink" title="(b) 为什么需要 this"></a>(b) 为什么需要 this</h3><p>因为 this 的作用域是在类的内部，自己声明一个类的时候，还不知道实例化对象的名字，所以用 this 来使用对象变量的自身。在非静态成员函数中，编译器在编译的时候加上 this 作为隐含形参，通过 this 来访问各个成员(即使你没有写上 this 指针)。<br>例如 a.fun(1) 等价于 fun(&amp;a,1)</p>
<h3 id="c-this-的使用"><a href="#c-this-的使用" class="headerlink" title="(c) this 的使用"></a>(c) this 的使用</h3><ul>
<li>在类的非静态成员函数中返回对象的本身的时候，直接用 return *this。这常用于操作符重载和赋值，拷贝等函数。</li>
<li>传入函数的形参与成员变量名相同时，例如：this-&gt;n=n (不能写成 n=n)。</li>
</ul>
<h3 id="d-实例说明"><a href="#d-实例说明" class="headerlink" title="(d) 实例说明"></a>(d) 实例说明</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; x=a; y=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MovePoint</span><span class="params">( <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123; x+=a; y+=b;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;x=&quot;</span>&lt; &#125;;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Point <span class="title">point1</span><span class="params">( <span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line">    point1.MovePoint(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">    point1.<span class="built_in">print</span>( );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注，<br>(1) 对象 <code>point1</code> 调用 <code>MovePoint(2 , 2)</code> 的时候，即将 <code>point1</code> 对象的地址传递给了 <code>this</code> 指针。<br>(2) 编译器编译后的原型应该是 <code>void MovePoint(Point *this, int a, int b)</code><br>(3) <code>&#123; x+=a; y+=b;&#125;</code> 在函数体中可以写成 <code>&#123;this-&gt;x += a;this-&gt;y += b;&#125;</code><br>(4) <code>&#123; x+=a; y+=b;&#125;</code> 也等价为 <code>point1.x += a;point1.y += b;</code></p>
<h1 id="二-继承"><a href="#二-继承" class="headerlink" title="二. 继承"></a>二. 继承</h1><p>继承指的是子类继承父类的特征和行为，使得子类对象(实例)具有父类的属性和方法。</p>
<h2 id="A-定义子类"><a href="#A-定义子类" class="headerlink" title="(A) 定义子类"></a>(A) 定义子类</h2><ul>
<li>语法为</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">derived</span>-<span class="title">class</span>:</span> access-specifier base-<span class="class"><span class="keyword">class</span></span></span><br></pre></td></tr></table></figure>

<p>其中 <code>derived-class</code> 为子类，<code>access-specifier</code> 是 <code>public,protected,privated</code> 中的一个，<code>base-class</code> 是基类。如果未使用访问修饰符 <code>access-specifier</code>，则默认为 <code>private</code>。    </p>
<ul>
<li>实例</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类(基类)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">width</span> = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子类(派生类)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="B-访问控制和继承"><a href="#B-访问控制和继承" class="headerlink" title="(B) 访问控制和继承"></a>(B) 访问控制和继承</h2><p>子类可以访问父类中所有的非私有成员。因此父类成员如果不想被子类的成员函数访问，则应在父类中声明为 private。<br>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table>
<thead>
<tr>
<th>访问</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>子类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>外部的类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>一个子类继承了所有的父类方法，但下列情况除外：<br>(1) 父类的构造函数，析构函数和拷贝构造函数；<br>(2) 父类的重载运算符；<br>(3) 父类的友元函数。</p>
<h2 id="C-访问属性继承类型"><a href="#C-访问属性继承类型" class="headerlink" title="(C) 访问属性继承类型"></a>(C) 访问属性继承类型</h2><ul>
<li>有 public，protected，private 三种继承方式，它们相应地改变了基类成员的访问属性。<ol>
<li>public 继承：基类 public，protected，private 成员的访问属性在派生类中分别变成：public，protected，private</li>
<li>protected 继承：基类 public，protected，private 成员的访问属性在派生类中分别变成：protected，protected，private</li>
<li>private 继承：基类 public，protected，private 成员的访问属性在派生类中分别变成：private，private，private</li>
</ol>
</li>
<li>下面两条恒成立：<ol>
<li>private 成员只能被本类成员(类内)和友元访问，不能被派生类访问</li>
<li>protected 成员可以被派生类访问</li>
</ol>
</li>
</ul>
<h2 id="D-多继承"><a href="#D-多继承" class="headerlink" title="(D) 多继承"></a>(D) 多继承</h2><p>多继承即一个子类可以有多个父类，它继承了多个父类的属性和方法。</p>
<h3 id="a-语法"><a href="#a-语法" class="headerlink" title="(a) 语法"></a>(a) 语法</h3><p>C++ 中多继承的语法为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类名：继承方式1 父类名1, 继承方式2 父类名2,····</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    子类函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="b-实例"><a href="#b-实例" class="headerlink" title="(b) 实例"></a>(b) 实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父类 Shape</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">width</span> = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="built_in">height</span> = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">      <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 父类 PaintCost</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaintCost</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getCost</span><span class="params">(<span class="keyword">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="c-虚继承"><a href="#c-虚继承" class="headerlink" title="(c) 虚继承"></a>(c) 虚继承</h3><h4 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="(1) 概述"></a>(1) 概述</h4><ul>
<li><p>多继承中，从不同路径继承来的同一父类，会在子类中存在多份拷贝。这将存在两个问题：<br>(1) 浪费存储空间；<br>(2) 存在二义性。具体来说是将子类对象的地址赋值给父类对象，实现的方式是将父类指针指向继承类(继承类有父类的拷贝)中的父类对象的地址，但是多继承可能存在一个父类的多份拷贝，这就出现了二义性。</p>
</li>
<li><p>虚继承可以解决多继承的这两个问题。<br>虚继承底层实现原理与编译器相关，一般通过虚基类指针和虚基类表实现，每个虚继承的子类都有一个虚基类指针(占用一个指针的存储空间，4 字节)和虚基类表(不占用类对象的存储空间)。这里需要强调的是，虚基类依旧会在子类里面存在拷贝，只是仅仅最多存在一份而已，并不是不在子类里面了。<br>当虚继承的子类被当作父类继承时，虚基类指针也会被继承。</p>
</li>
<li><p>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类。在虚继承机制下，不论虚基类在继承体系中出现了多少次，在子类中都只包含一份虚基类的成员。</p>
</li>
</ul>
<h4 id="2-语法"><a href="#2-语法" class="headerlink" title="(2) 语法"></a>(2) 语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 子类：<span class="title">virtual</span> 基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//子类函数体</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="三-方法相关操作"><a href="#三-方法相关操作" class="headerlink" title="三. 方法相关操作"></a>三. 方法相关操作</h1><h2 id="A-覆盖与重载方法"><a href="#A-覆盖与重载方法" class="headerlink" title="(A) 覆盖与重载方法"></a>(A) 覆盖与重载方法</h2><h3 id="a-覆盖方法"><a href="#a-覆盖方法" class="headerlink" title="(a) 覆盖方法"></a>(a) 覆盖方法</h3><h4 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="(1) 概述"></a>(1) 概述</h4><ul>
<li>子类可继承父类中的方法，而不需要重新编写相同的方法。但有时子类并不想原封不动地继承父类的方法，而是想做一定的修改，这种情况即是覆盖方法。</li>
<li>C++ 可以让我们实现这种既有共同特征又需要在不同的类里有不同实现的方法。简单地举个例子说就是，动物都知道用嘴吃，那么吃我们就可以说是动物的一个共同特征(相当于基类里面实现吃的方法)，但是我们知道不同的动物会有不同的吃法，这个就是不同的实现方法。</li>
</ul>
<h4 id="2-发生覆盖的条件"><a href="#2-发生覆盖的条件" class="headerlink" title="(2) 发生覆盖的条件"></a>(2) 发生覆盖的条件</h4><ol>
<li>“三同一不低”：子类和父类的方法名称，参数列表，返回类型必须完全相同，而且子类方法的访问修饰符的权限不能比父类低；</li>
<li>子类方法不能抛出比父类方法更多的异常。即子类方法所抛出的异常必须和父类方法所抛出的异常一致，或者是其子类，或者什么也不抛出；</li>
<li>被覆盖的方法不能是 final 类型的。因为 final 修饰的方法是无法覆盖的；</li>
<li>被覆盖的方法不能为 private。否则在其子类中只是新定义了一个方法，并没有对其进行覆盖；</li>
<li>被覆盖的方法不能为 static。所以如果父类中的方法为静态的，而子类中的方法不是静态的，但是两个方法除了这一点外其他都满足覆盖条件，那么会发生编译错误，反之亦然。即使父类和子类中的方法都是静态的，并且满足覆盖条件，但是仍然不会发生覆盖，因为静态方法是在编译的时候把静态方法和类的引用类型进行匹配。</li>
</ol>
<h4 id="3-实例"><a href="#3-实例" class="headerlink" title="(3) 实例"></a>(3) 实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//声明定义</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>  //定义一个类  基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> thename);  <span class="comment">//加构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:              <span class="comment">//这个类本身或者它的子类可以访问</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>:</span> <span class="keyword">public</span> Animal  <span class="comment">//定义子类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Pig(<span class="built_in">std</span>::<span class="built_in">string</span> thename);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">climb</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  <span class="comment">//实现覆盖，则在子类再一次的声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Turtle(<span class="built_in">std</span>::<span class="built_in">string</span> thename);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;  <span class="comment">//实现覆盖，则在子类再一次的声明</span></span><br><span class="line">&#125;;</span><br><span class="line">Animal::Animal(<span class="built_in">std</span>::<span class="built_in">string</span> thename)  <span class="comment">//Animal构造器</span></span><br><span class="line">&#123;</span><br><span class="line">    name=thename;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//基类方法(函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::eat</span><span class="params">()</span>  <span class="comment">//eat()方法(函数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Animal::eat  I&#x27;m eatting!&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::sleep</span><span class="params">()</span>  <span class="comment">//sleep()方法(函数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Animal::sleep  I&#x27;m sleeping!&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::drool</span><span class="params">()</span>  <span class="comment">//drool()方法(函数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; Animal::drool  我正在流口水&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类方法(函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::climb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Pig::climb    我是猪，我爬树&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Pig::Pig(<span class="built_in">std</span>::<span class="built_in">string</span> thename):Animal(thename)  <span class="comment">//Pig构造器继承Animal构造器</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turtle::swim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Turtle::swim  我在游泳&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Turtle::Turtle(<span class="built_in">std</span>::<span class="built_in">string</span> thename):Animal(thename)  <span class="comment">//Turtle构造器继承Animal构造器</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//覆盖方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::eat</span><span class="params">()</span><span class="comment">//子类覆盖了基类的方法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal::eat();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;name&lt;&lt; <span class="string">&quot;正在猪食！\n\n&quot;</span>;  <span class="comment">//由于访问控制protected的原因，所以只能在基类或者子类访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turtle::eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Animal::eat();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;name&lt;&lt; <span class="string">&quot;正在吃鱼！\n\n&quot;</span>;  <span class="comment">//由于访问控制protected的原因，所以只能在基类或者子类访问</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pig <span class="title">pig</span><span class="params">(<span class="string">&quot;小猪猪&quot;</span>)</span></span>;  <span class="comment">//定义一个pig    Pig类名  pig变量</span></span><br><span class="line">    <span class="function">Turtle <span class="title">turtle</span><span class="params">(<span class="string">&quot;小甲鱼&quot;</span>)</span></span>;  <span class="comment">//定义一个turtle  turtle类名 turtle变量</span></span><br><span class="line"> </span><br><span class="line">    pig.eat();  <span class="comment">//可以理解为函数的调用</span></span><br><span class="line">    turtle.eat();</span><br><span class="line"> </span><br><span class="line">    pig.sleep();</span><br><span class="line">    turtle.sleep();</span><br><span class="line"> </span><br><span class="line">    pig.climb();</span><br><span class="line">    turtle.swim();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Animal::eat  I<span class="number">&#x27;</span>m eatting!</span><br><span class="line">小猪猪正在猪食！</span><br><span class="line"></span><br><span class="line">Animal::eat  I<span class="number">&#x27;</span>m eatting!</span><br><span class="line">小甲鱼正在吃鱼！</span><br><span class="line"></span><br><span class="line">Animal::sleep  I<span class="number">&#x27;</span>m sleeping!</span><br><span class="line">Animal::sleep  I<span class="number">&#x27;</span>m sleeping!</span><br><span class="line">Pig::climb    我是猪，我爬树</span><br><span class="line">Turtle::swim  我在游泳</span><br></pre></td></tr></table></figure>

<h3 id="b-重载方法"><a href="#b-重载方法" class="headerlink" title="(b) 重载方法"></a>(b) 重载方法</h3><h4 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="(1) 概述"></a>(1) 概述</h4><ul>
<li>重载方法指的是在一个类中定义多个同名的方法，但要求每个方法具有不同的参数类型或参数个数。调用重载方法时，编译器能通过检查调用的方法的参数类型和个数选择一个恰当的方法。</li>
<li>注，对从基类继承来的方法进行重载，程序永远编译不过的。</li>
</ul>
<h4 id="2-实例-2"><a href="#2-实例-2" class="headerlink" title="(2) 实例"></a>(2) 实例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//声明定义</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>  //定义一个类  基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Animal(<span class="built_in">std</span>::<span class="built_in">string</span> thename);  <span class="comment">//加构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> eatcount)</span></span>;  <span class="comment">//方法重载</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">drool</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:                    <span class="comment">//这个类本身或者它的子类可以访问</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//定义子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span>:</span> <span class="keyword">public</span> Animal  <span class="comment">//定义子类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Pig(<span class="built_in">std</span>::<span class="built_in">string</span> thename);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">climb</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Turtle</span>:</span> <span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Turtle(<span class="built_in">std</span>::<span class="built_in">string</span> thename);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">swim</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">&#125;;</span><br><span class="line">Animal::Animal(<span class="built_in">std</span>::<span class="built_in">string</span> thename)  <span class="comment">//Animal构造器</span></span><br><span class="line">&#123;</span><br><span class="line">    name=thename;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//基类方法(函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::eat</span><span class="params">()</span>  <span class="comment">//eat()方法(函数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Animal::eat  I&#x27;m eatting!&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::sleep</span><span class="params">()</span>  <span class="comment">//sleep()方法(函数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;Animal::sleep  I&#x27;m sleeping!&quot;</span> &lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::drool</span><span class="params">()</span>  <span class="comment">//drool()方法(函数)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; Animal::drool  我正在流口水&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子类方法(函数)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pig::climb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Pig::climb    我是猪，我爬树&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Pig::Pig(<span class="built_in">std</span>::<span class="built_in">string</span> thename):Animal(thename)  <span class="comment">//Pig构造器继承Animal构造器</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Turtle::swim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Turtle::swim  我在游泳&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">Turtle::Turtle(<span class="built_in">std</span>::<span class="built_in">string</span> thename):Animal(thename)  <span class="comment">//Turtle构造器继承Animal构造器</span></span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Animal::eat</span><span class="params">(<span class="keyword">int</span> eatcount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;我吃了&quot;</span>&lt;&lt;eatcount&lt;&lt;<span class="string">&quot;碗饭\n\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Pig <span class="title">pig</span><span class="params">(<span class="string">&quot;小猪猪&quot;</span>)</span></span>;  <span class="comment">//定义一个pig    Pig类名  pig变量</span></span><br><span class="line">    <span class="function">Turtle <span class="title">turtle</span><span class="params">(<span class="string">&quot;小甲鱼&quot;</span>)</span></span>;  <span class="comment">//定义一个turtle  turtle类名 turtle变量</span></span><br><span class="line"> </span><br><span class="line">    pig.eat();  <span class="comment">//可以理解为函数的调用</span></span><br><span class="line">    turtle.eat();</span><br><span class="line"> </span><br><span class="line">    pig.eat(<span class="number">10</span>);  <span class="comment">//给一个参数传进去,会自动使用带有参数的方法</span></span><br><span class="line"> </span><br><span class="line">    pig.sleep();</span><br><span class="line">    turtle.sleep();</span><br><span class="line"> </span><br><span class="line">    pig.climb();</span><br><span class="line">    turtle.swim();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Animal::eat  I<span class="number">&#x27;</span>m eatting!</span><br><span class="line">Animal::eat  I<span class="number">&#x27;</span>m eatting!</span><br><span class="line">我吃了<span class="number">10</span>碗饭</span><br><span class="line"></span><br><span class="line">Animal::sleep  I<span class="number">&#x27;</span>m sleeping!</span><br><span class="line">Animal::sleep  I<span class="number">&#x27;</span>m sleeping!</span><br><span class="line">Pig::climb    我是猪，我爬树</span><br><span class="line">Turtle::swim  我在游泳</span><br></pre></td></tr></table></figure>

<h3 id="c-小结"><a href="#c-小结" class="headerlink" title="(c) 小结"></a>(c) 小结</h3><ul>
<li><p>方法的覆盖和重载具有以下相同点：</p>
<ol>
<li>都要求方法同名</li>
<li>都可以用于抽象方法和非抽象方法之间</li>
</ol>
</li>
<li><p>方法的覆盖和重载具有以下不同点：</p>
<ol>
<li>方法覆盖要求参数列表必须一致，而方法重载要求参数列表必须不一致</li>
<li>方法覆盖要求返回类型必须一致，方法重载对此没有要求</li>
<li>方法覆盖只能用于子类覆盖父类的方法，方法重载用于同一个类中的所有方法</li>
<li>方法覆盖对方法的访问权限和抛出异常有特殊的要求，而方法重载在这方面没有任何限制</li>
<li>父类的一个方法只能被子类覆盖一次，而一个方法可以在所有的类中被重载多次</li>
</ol>
</li>
</ul>
<h2 id="B-静态属性和静态方法"><a href="#B-静态属性和静态方法" class="headerlink" title="(B) 静态属性和静态方法"></a>(B) 静态属性和静态方法</h2><h3 id="a-静态"><a href="#a-静态" class="headerlink" title="(a) 静态"></a>(a) 静态</h3><p>静态成员是所有对象共享的，所以不能在静态方法里面访问非静态元素，但非静态方法可以访问类的静态成员及非静态成员。</p>
<h3 id="b-为什么需要静态属性和静态方法"><a href="#b-为什么需要静态属性和静态方法" class="headerlink" title="(b) 为什么需要静态属性和静态方法"></a>(b) 为什么需要静态属性和静态方法</h3><ul>
<li><p>当我们需要在每次创建对象时进行对象的计数，使用普通变量的话，由于普通变量为局部变量，也就是说，每建立一次对象，对象中的局部变量都会被初始化并重新写入。而有了静态变量，由于静态变量是类中的全局变量而且不可被类外的对象访问，全局变量值在每次对象构建时不会被初始化，而是在原值的基础上进行累计。使用静态属性和静态方法，保证了重要参数的安全性。</p>
</li>
<li><p>面向对象编程技术的一个重要特性是用一个对象把数据和对数据处理的方法封装在一起。实际编程时有时会遇到这样的问题：如果我们所需要的功能或者数据不属于某个特定的对象，而是属于整个类的，该怎么办？<br>比如我们不妨假设现在需要统计一下有多少只活的动物，那么我们需要一个计数器数量：每诞生一只宠物，就给宠物计数器加 1，每挂掉一只，就减去 1。<br>我们首先想到的是创建一个全局变量来充当这个计数器，但这么做的后果是程序中的任何代码都可以修改这个计数器，稍不小心就会在程序里留下一个难以查堵的漏洞。<br>所以坚决不建议在非必要的时候声明全局变量，我们真正需要的是一个只有在创建或删除对象的时候才允许访问的计数器。</p>
</li>
<li><p>这个问题必须使用 C++ 的静态属性和静态方法才能完善地得到解决，C++ 允许我们把一个或多个成员声明为属于某个类，而不是仅属于该类的对象。<br>这么做的好处在于程序员可以在没有创建任何对象的情况下调用有关的方法，而且有关数据仍能在该类的所有对象(静态和非静态皆可)之间共享。</p>
</li>
</ul>
<h3 id="c-静态数据成员"><a href="#c-静态数据成员" class="headerlink" title="(c) 静态数据成员"></a>(c) 静态数据成员</h3><ul>
<li><p>静态数据成员的声明<br>静态数据成员实际上是类域中的全局变量。类中的静态成员数据和函数都只是相当于声明的作用，而不是定义。声明不分配空间，在类里面需要使用 const static 进行数据定义(初始化)。</p>
</li>
<li><p>静态数据成员的作用域<br>静态数据成员被类的所有对象共享，包括该类的子类对象。静态数据成员可以视为类内的全局变量。</p>
</li>
<li><p>静态数据成员可以成为成员函数的可选参数，而普通数据成员不可以，举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla</span></span></span><br><span class="line"><span class="class">&#123;</span>   </span><br><span class="line"><span class="keyword">public</span> :   </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i1;   <span class="comment">//静态数据成员</span></span><br><span class="line">    <span class="keyword">int</span> i2;   <span class="comment">//普通数据成员</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> i = i1)</span></span>;</span><br><span class="line">         <span class="comment">//OK   允许作为此类内的成员函数的参数进行值传递(因为静态数据成员可看作全局变量)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> i = i2)</span></span>;  <span class="comment">//错误  不允许</span></span><br><span class="line">&#125;;   </span><br></pre></td></tr></table></figure>
</li>
<li><p>静态数据成员的类型可以为本类的类型，而普通数据成员不可以。</p>
</li>
</ul>
<h3 id="d-静态成员函数"><a href="#d-静态成员函数" class="headerlink" title="(d) 静态成员函数"></a>(d) 静态成员函数</h3><ul>
<li><p>可以在没有定义任何对象前使用，即无须创建任何对象实例就可以使用此成员函数，举例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cla</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>; <span class="comment">//建立一个静态成员函数</span></span><br><span class="line">&#125;;  </span><br><span class="line">cla::func();</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态成员函数不可调用类的非静态成员，静态成员函数不包含 this 指针，非静态成员必须与特定对象相对。</p>
</li>
</ul>
<h3 id="e-类内外声明静态成员格式"><a href="#e-类内外声明静态成员格式" class="headerlink" title="(e) 类内外声明静态成员格式"></a>(e) 类内外声明静态成员格式</h3><h4 id="1-类内声明静态成员"><a href="#1-类内声明静态成员" class="headerlink" title="(1) 类内声明静态成员"></a>(1) 类内声明静态成员</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getcount</span><span class="params">()</span></span>;  <span class="comment">//类内声明静态成员函数 正确</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> thename;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;  <span class="comment">//类内声明静态变量 正确</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count=<span class="number">10</span>;  <span class="comment">/* 类内声明静态变量 错误 声明时不可进行赋值操作</span></span><br><span class="line"><span class="comment">    (此时未分配内存 变量赋值需要分配内存) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-类外声明静态变量"><a href="#2-类外声明静态变量" class="headerlink" title="(2) 类外声明静态变量"></a>(2) 类外声明静态变量</h4><p>静态成员的值对所有的对象是一样的。静态成员可以被初始化，但只能在类体外进行初始化。<br>静态成员不可在类体内进行赋值，因为它是被所有该类的对象所共享的。你在一个对象里给它赋值，其他对象里的该成员也会发生变化。为了避免混乱，所以不可在类体内进行赋值，真正要为它们分配内存并进行初始化的时候，需要在类外进行声明，格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 类名::静态数据成员名=初值;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> Pet::count = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-类外实现静态成员"><a href="#3-类外实现静态成员" class="headerlink" title="(3) 类外实现静态成员"></a>(3) 类外实现静态成员</h4><p>静态成员函数在类外实现时候无须加 static 关键字，否则是错误的。若在类外实现上述的那个静态成员函数，是不能加上 static 关键字的，需要这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pet::getcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="f-实例"><a href="#f-实例" class="headerlink" title="(f) 实例"></a>(f) 实例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Pet(<span class="built_in">string</span> name);<span class="comment">//构造函数</span></span><br><span class="line">    ~Pet();<span class="comment">//析构函数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getcount</span><span class="params">()</span></span>;<span class="comment">/*访问权限为public的对象计数器函数</span></span><br><span class="line"><span class="comment">                (接口函数 对象可以访问 并可以不建立对象进行全局访问)*/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*定义类的静态成员函数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    测试 与项目无关----------------------------</span></span><br><span class="line"><span class="comment">    static int para;</span></span><br><span class="line"><span class="comment">    void fun(int i = para); //静态数据成员可以成为成员函数的可选参数，而普通成员不可以</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    static Pet type;//静态数据成员的类型可以是本类的类型，而普通数据成员则不可以</span></span><br><span class="line"><span class="comment">    Pet * a;//正确</span></span><br><span class="line"><span class="comment">    Pet&amp; b;//正确</span></span><br><span class="line"><span class="comment">    ---------------------------------------------------*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> thename;<span class="comment">/*建立存放宠物名的参数thename 访问权限为protected(对象不可访问) </span></span><br><span class="line"><span class="comment">    目的是防止用户不慎修改该参数 所以这个参数的赋值发生在本类的结构体中</span></span><br><span class="line"><span class="comment">    (即每次有对象建立便类内部进行赋值)*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count;<span class="comment">/*访问权限为private的计数值 只能本类中访问(对象不可访问)</span></span><br><span class="line"><span class="comment">    目的是防止用户不慎修改该参数 所以这个参数的赋值发生在本类的结构体中</span></span><br><span class="line"><span class="comment">    (即每次有对象建立便类内部进行赋值)*/</span></span><br><span class="line">    <span class="comment">//定义类的静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> :</span><span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Dog(<span class="built_in">string</span> name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> :</span><span class="keyword">public</span> Pet</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Cat(<span class="built_in">string</span> name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Pet::count = <span class="number">0</span>;<span class="comment">//类中的静态变量count 可以全局使用</span></span><br><span class="line"></span><br><span class="line">Pet::Pet(<span class="built_in">string</span> name)<span class="comment">//构造函数 用于宠物数量的计数和宠物信息的显示 每次为类建立实例后都将被调用一次</span></span><br><span class="line">&#123;</span><br><span class="line">    thename = name;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;一只小宠物出生啦！名字叫做:&quot;</span> &lt;&lt; thename &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pet::~Pet()<span class="comment">//析构函数 在程序尾部或对象寿命结束时被调用</span></span><br><span class="line">&#123;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; thename &lt;&lt; <span class="string">&quot;挂掉了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog::Dog(<span class="built_in">string</span> name) :Pet(name)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cat::Cat(<span class="built_in">string</span> name) : Pet(name)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pet::getcount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Dog <span class="title">dog</span><span class="params">(<span class="string">&quot;wangcai&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Cat <span class="title">cat</span><span class="params">(<span class="string">&quot;miaomiao&quot;</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n已经诞生了&quot;</span> &lt;&lt; Pet::getcount() &lt;&lt; <span class="string">&quot;只宠物\n\n&quot;</span>;</span><br><span class="line">    <span class="comment">/* 以上这个静态函数就可以在未声明任何对象的情况下 </span></span><br><span class="line"><span class="comment">    使用classname::staticfunname的格式进行 类内函数的调用</span></span><br><span class="line"><span class="comment">    最大程度上规避了用户不小心修改count这个宠物数量变量的漏洞 </span></span><br><span class="line"><span class="comment">    因为这个静态函数中的count变量为private私有 仅能被Pet类内函数调用 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//大括号建立区域  </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">Dog <span class="title">dog2</span><span class="params">(<span class="string">&quot;tom&quot;</span>)</span></span>;</span><br><span class="line">        <span class="function">Cat <span class="title">cat2</span><span class="params">(<span class="string">&quot;jerry&quot;</span>)</span></span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n现在呢，已经诞生了&quot;</span> &lt;&lt; Pet::getcount() &lt;&lt; <span class="string">&quot;只宠物!\n\n&quot;</span>;</span><br><span class="line">    &#125;<span class="comment">/* 大括号建立了区域后dog2和cat2的作用域仅存在于括号内 </span></span><br><span class="line"><span class="comment">    出了括号则进行析构也就是进行~pet() 从而导致宠物死亡 */</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\n现在还有&quot;</span> &lt;&lt; Pet::getcount() &lt;&lt; <span class="string">&quot;只宠物\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一只小宠物出生啦！名字叫做:wangcai</span><br><span class="line">一只小宠物出生啦！名字叫做:miaomiao</span><br><span class="line"></span><br><span class="line">已经诞生了<span class="number">2</span>只宠物</span><br><span class="line"></span><br><span class="line">一只小宠物出生啦！名字叫做:tom</span><br><span class="line">一只小宠物出生啦！名字叫做:jerry</span><br><span class="line"></span><br><span class="line">现在呢，已经诞生了<span class="number">4</span>只宠物!</span><br><span class="line"></span><br><span class="line">jerry挂掉了</span><br><span class="line">tom挂掉了</span><br><span class="line"></span><br><span class="line">现在还有<span class="number">2</span>只宠物</span><br><span class="line">miaomiao挂掉了</span><br><span class="line">wangcai挂掉了</span><br></pre></td></tr></table></figure>

<h2 id="C-虚函数和虚方法"><a href="#C-虚函数和虚方法" class="headerlink" title="(C) 虚函数和虚方法"></a>(C) 虚函数和虚方法</h2><h3 id="a-虚函数：实现类的多态性"><a href="#a-虚函数：实现类的多态性" class="headerlink" title="(a) 虚函数：实现类的多态性"></a>(a) 虚函数：实现类的多态性</h3><ul>
<li><p>C++ 中的虚函数的作用主要是实现了多态的机制。基类定义虚函数，子类可以重写该函数。在子类中对基类定义的虚函数进行重写时，需要在派生类中声明该方法为虚方法。<br>当子类重新定义了父类的虚函数后，当父类的指针指向子类对象的地址时，父类指针根据赋给它的不同子类指针，动态地调用子类的该函数，而不是父类的函数。且这样的函数调用发生在运行阶段，而不是发生在编译阶段，称为动态联编。而函数的重载可以认为是多态，只不过是静态的。<br>注意，非虚函数静态联编，效率要比虚函数高，但是不具备动态联编能力。</p>
</li>
<li><p>定义虚函数使用 virtual 关键字，程序将根据引用或指针指向的对象类型来选择方法，否则使用引用类型或指针类型来选择方法。</p>
</li>
<li><p>下面的例子解释动态联编性：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       A();</span><br><span class="line">       A(<span class="keyword">int</span> num) :i(num) &#123;&#125;;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A&#123;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">       <span class="keyword">int</span> j;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">       B(<span class="keyword">int</span> num) :j(num)&#123;&#125;;</span><br><span class="line">       <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>;<span class="comment">// 重写了基类的方法</span></span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 为方便解释思想，省略很多代码</span></span><br><span class="line"></span><br><span class="line">   <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">   <span class="function">B <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">   A *a1_ptr = &amp;a;</span><br><span class="line">   A *a2_ptr = &amp;b;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 当派生类“重写”了基类的虚方法，调用该方法时</span></span><br><span class="line">   <span class="comment">// 程序根据 指针或引用 指向的“对象的类型”来选择使用哪个方法</span></span><br><span class="line">   a1_ptr-&gt;fun2();<span class="comment">// call A::fun2();</span></span><br><span class="line">   a2_ptr-&gt;fun2();<span class="comment">// call B::fun1();</span></span><br><span class="line">   <span class="comment">// 否则</span></span><br><span class="line">   <span class="comment">// 程序根据“指针或引用的类型”来选择使用哪个方法</span></span><br><span class="line">   a1_ptr-&gt;fun1();<span class="comment">// call A::fun1();</span></span><br><span class="line">   a2_ptr-&gt;fun1();<span class="comment">// call A::fun1();</span></span><br></pre></td></tr></table></figure>

<h3 id="b-虚函数的底层实现机制"><a href="#b-虚函数的底层实现机制" class="headerlink" title="(b) 虚函数的底层实现机制"></a>(b) 虚函数的底层实现机制</h3><ul>
<li>编译器处理虚函数的方法是：为每个类对象添加一个隐藏成员，隐藏成员中保存了一个指向函数地址数组的指针，称为虚表指针 (vptr)，这种数组称为虚函数表 (virtual function table, vtbl)。即，每个类使用一个虚函数表，每个类对象用一个虚表指针。</li>
<li>举个例子：基类对象包含一个虚表指针，指向基类中所有虚函数的地址表。子类对象也将包含一个虚表指针，指向子类虚函数表。看下面两种情况：<ol>
<li>如果子类重写了基类的虚方法，该子类虚函数表将保存重写的虚函数的地址，而不是基类的虚函数地址。</li>
<li>如果基类中的虚方法没有在子类中重写，那么子类将继承基类中的虚方法，而且子类中虚函数表将保存基类中未被重写的虚函数地址。注意，如果子类中定义了新的虚方法，则该虚函数的地址也将被添加到子类虚函数表中。</li>
</ol>
</li>
</ul>
<h2 id="D-接口和抽象类"><a href="#D-接口和抽象类" class="headerlink" title="(D) 接口和抽象类"></a>(D) 接口和抽象类</h2><h3 id="a-概述"><a href="#a-概述" class="headerlink" title="(a) 概述"></a>(a) 概述</h3><ul>
<li><p>接口描述了类的行为和功能，而不需要完成类的特定实现。C++ 接口是通过抽象类来实现的。<br>如果类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类。纯虚函数是通过在声明中使用 “=0” 来指定的，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 纯虚函数</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">      <span class="keyword">double</span> length;      <span class="comment">// 长度</span></span><br><span class="line">      <span class="keyword">double</span> breadth;     <span class="comment">// 宽度</span></span><br><span class="line">      <span class="keyword">double</span> <span class="built_in">height</span>;      <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>设计抽象类(通常称为 ABC) 的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。<br>因此，如果一个 ABC 的子类需要被实例化，则必须实现每个虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在子类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。<br>可用于实例化对象的类被称为具体类。</p>
</li>
</ul>
<h3 id="b-实例-1"><a href="#b-实例-1" class="headerlink" title="(b) 实例"></a>(b) 实例</h3><p>下面的实例中，基类 Shape 提供了一个接口 getArea( )，在两个派生类 Rectangle 和 Triangle 中分别实现了 getArea( )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 提供接口框架的纯虚函数</span></span><br><span class="line">   <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="built_in">width</span> = w;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setHeight</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="built_in">height</span> = h;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">width</span>;</span><br><span class="line">   <span class="keyword">int</span> <span class="built_in">height</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>); </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span>:</span> <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">   </span>&#123; </span><br><span class="line">      <span class="keyword">return</span> (<span class="built_in">width</span> * <span class="built_in">height</span>)/<span class="number">2</span>; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   Triangle  Tri;</span><br><span class="line"> </span><br><span class="line">   Rect.setWidth(<span class="number">5</span>);</span><br><span class="line">   Rect.setHeight(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total Rectangle area: &quot;</span> &lt;&lt; Rect.getArea() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">   Tri.setWidth(<span class="number">5</span>);</span><br><span class="line">   Tri.setHeight(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Total Triangle area: &quot;</span> &lt;&lt; Tri.getArea() &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total Rectangle area: <span class="number">35</span></span><br><span class="line">Total Triangle area: <span class="number">17</span></span><br></pre></td></tr></table></figure>

<h2 id="E-多态"><a href="#E-多态" class="headerlink" title="(E) 多态"></a>(E) 多态</h2><h3 id="a-多态定义及构成条件"><a href="#a-多态定义及构成条件" class="headerlink" title="(a) 多态定义及构成条件"></a>(a) 多态定义及构成条件</h3><p>多态是在不同继承关系的类对象，去调同一函数，产生了不同的行为。<br>就是说，有一对继承关系的两个类，这两个类里面都有一个函数且名字，参数，返回值均相同，然后我们通过调用函数来实现不同类对象完成不同的事件。<br>但是构成多态还有两个条件：</p>
<ol>
<li>调用函数的对象必须是指针或者引用</li>
<li>被调用的函数必须是虚函数，且完成了虚函数的重写</li>
</ol>
<h3 id="b-实例-2"><a href="#b-实例-2" class="headerlink" title="(b) 实例"></a>(b) 实例</h3><p>以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Adult need Full Fare!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">BuyTicket</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child Free!&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Person&amp; obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.BuyTicket(<span class="number">1</span>);                                                                                                                             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    Child c;</span><br><span class="line"></span><br><span class="line">    fun(p);</span><br><span class="line">    fun(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果为</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Adult need Full Fare!</span><br><span class="line">Child Free!</span><br></pre></td></tr></table></figure>

<p>注，</p>
<ol>
<li>调用函数就是这里的 <code>fun</code>，参数 <code>int</code> 没有实际意义，就是为了体现函数重写必须要返回值一样，函数名一样及参数一样。</li>
<li>被调用的函数必须是虚函数，也就是说必须要在两个产生多态的函数前面加 <code>virtual</code> 关键字。</li>
<li>调用函数的形参对象必须是基类对象，这里是因为子类只能给基类赋值，会发生切片操作。基类不能给子类赋值。</li>
<li>调用函数的参数必须是指针或引用，因为子类改变了虚表，那么这个虚表就属于子类对象，赋值的时候只会把基类的成员给过去，虚表指针不会给。所以在调用函数的时候会发生语法检查，如果满足多态的条件，就会触发寻找虚表中虚函数地址。如果不满足条件，则会直接用基类对象调用基类函数。</li>
</ol>
<h3 id="c-析构函数重写问题"><a href="#c-析构函数重写问题" class="headerlink" title="(c) 析构函数重写问题"></a>(c) 析构函数重写问题</h3><ul>
<li>基类中的析构函数如果是虚函数，那么子类的析构函数就重写了基类的析构函数。这里他们的函数名不相同，看起来似乎违背了重写的规则，其实不然。这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成 destructor，这也说明了基类的析构函数最好写成虚函数。</li>
<li>因为基类指针可能指向子类，当 delete 的时候，如果不定为虚函数，系统会直接调用基类的析构函数，这个时候子类就有一部分没有被释放，就会造成可怕的内存泄漏问题。<br>若定义为虚函数构成多态，那么就会先调用子类的析构函数然后子类的析构函数就会自动调用基类的析构函数，这个结果满足我们的本意。</li>
<li>所以，在继承的时候，尽量把基类的析构函数定义为虚函数，这样继承下去的子类的析构函数也会被变成虚函数构成多态。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/01/24/Cpplus01/" rel="prev" title="C++笔记(零一)：C++与OO思想简介">
      <i class="fa fa-chevron-left"></i> C++笔记(零一)：C++与OO思想简介
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/02/02/Cpplus03/" rel="next" title="C++笔记(零三)：错误处理和动态管理">
      C++笔记(零三)：错误处理和动态管理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minwei Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
