<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  
  <link rel="stylesheet" href="/lib/animate-css/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Pisces","version":"8.0.0-rc.5","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false};
  </script>

  <meta name="description" content="又是一年公历生日，感谢小伙伴们的祝福。虽然以后的人生会一直为生存而战，直至最终战死，但能有幸遇到善良又努力的小伙伴们，我已知足。 人固有一死，希望阿伟最终的结局是为知遇之恩而死。 好了，言归正传。本篇是 MySQL 的终章，讲解的是 MySQL 的运行机制相关的知识，故称 MySQL 高级。内容包括数据库范式，逻辑架构，索引，查询截取分析，锁机制，主从复制，缓存与 MQ。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL笔记(零四)：MySQL高级">
<meta property="og:url" content="http://yoursite.com/2021/11/22/MySQL04/index.html">
<meta property="og:site_name" content="Cross Code">
<meta property="og:description" content="又是一年公历生日，感谢小伙伴们的祝福。虽然以后的人生会一直为生存而战，直至最终战死，但能有幸遇到善良又努力的小伙伴们，我已知足。 人固有一死，希望阿伟最终的结局是为知遇之恩而死。 好了，言归正传。本篇是 MySQL 的终章，讲解的是 MySQL 的运行机制相关的知识，故称 MySQL 高级。内容包括数据库范式，逻辑架构，索引，查询截取分析，锁机制，主从复制，缓存与 MQ。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4101.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4102.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4103.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4104.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4105.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4106.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4107.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4108.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4109.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4110.png">
<meta property="og:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4111.png">
<meta property="article:published_time" content="2021-11-22T03:10:03.000Z">
<meta property="article:modified_time" content="2021-12-22T06:22:36.000Z">
<meta property="article:author" content="Minwei Chen">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4101.png">

<link rel="canonical" href="http://yoursite.com/2021/11/22/MySQL04/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>MySQL笔记(零四)：MySQL高级 | Cross Code</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

  <script type="text/javascript" src="/js/my_js/clicklove.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Cross Code</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">There is only one heroism in the world: to see the world as it is and to love it</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%8C%83%E5%BC%8F"><span class="nav-text">一. 数据库范式</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C-%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="nav-text">二. 逻辑架构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89-%E7%B4%A2%E5%BC%95"><span class="nav-text">三. 索引</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-join-%E5%88%86%E7%B1%BB"><span class="nav-text">(A) join 分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E7%B4%A2%E5%BC%95%E7%9A%84%E8%AE%A4%E8%AF%86"><span class="nav-text">(B) 索引的认识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="nav-text">(C) 索引的优势与劣势</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-MySQL-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="nav-text">(D) MySQL 索引分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#E-%E5%AF%86%E9%9B%86%E7%B4%A2%E5%BC%95%E4%B8%8E%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95"><span class="nav-text">(E) 密集索引与稀疏索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#F-%E7%B4%A2%E5%BC%95%E8%AF%AD%E6%B3%95"><span class="nav-text">(F) 索引语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%88%9B%E5%BB%BA"><span class="nav-text">(a) 创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%88%A0%E9%99%A4"><span class="nav-text">(b) 删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E6%9F%A5%E7%9C%8B"><span class="nav-text">(c) 查看</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E8%AF%A6%E7%BB%86%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95"><span class="nav-text">(d) 详细添加索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#G-MySQL-%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84"><span class="nav-text">(G) MySQL 索引结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-B-%E6%A0%91%E8%80%8C%E4%B8%8D%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="nav-text">(a) 为什么用 B+ 树而不用红黑树</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-B-%E6%A0%91%E4%B8%8E-B-%E6%A0%91%E5%8C%BA%E5%88%AB"><span class="nav-text">(b) B 树与 B+ 树区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%9B%9E%E8%A1%A8"><span class="nav-text">(c) 回表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#H-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5"><span class="nav-text">(H) 建立索引情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5"><span class="nav-text">(a) 建立索引情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%B8%8D%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95%E6%83%85%E5%86%B5"><span class="nav-text">(b) 不建立索引情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E4%B8%8D%E4%BD%BF%E7%94%A8-UUID-%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE"><span class="nav-text">(c) 不使用 UUID 作为主键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90"><span class="nav-text">(I) 性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-Mysql-Query-Optimizer"><span class="nav-text">(a) Mysql Query Optimizer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-Mysql-%E5%B8%B8%E8%A7%81%E7%93%B6%E9%A2%88"><span class="nav-text">(b) Mysql 常见瓶颈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-explain"><span class="nav-text">(c) explain</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#J-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="nav-text">(J) 索引优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E7%B4%A2%E5%BC%95%E5%88%86%E6%9E%90"><span class="nav-text">(a) 索引分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%8D%95%E8%A1%A8"><span class="nav-text">(1) 单表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E4%B8%A4%E8%A1%A8"><span class="nav-text">(2) 两表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="nav-text">(b) 索引失效</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="nav-text">(c) 索引下推</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-MRR"><span class="nav-text">(d) MRR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99"><span class="nav-text">(e) 优化原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#f-order-by-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96"><span class="nav-text">(f) order by 关键字优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#g-group-by-%E5%85%B3%E9%94%AE%E5%AD%97%E4%BC%98%E5%8C%96"><span class="nav-text">(g) group by 关键字优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B-%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90"><span class="nav-text">四. 查询截取分析</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E5%88%86%E6%9E%90"><span class="nav-text">(A) 分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-text">(B) 慢查询日志</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-Show-Profile"><span class="nav-text">(C) Show Profile</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#D-%E5%85%A8%E5%B1%80%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97"><span class="nav-text">(D) 全局查询日志</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E9%94%81%E6%9C%BA%E5%88%B6"><span class="nav-text">五. 锁机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E6%A6%82%E8%BF%B0"><span class="nav-text">(A) 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E5%9C%BA%E6%99%AF"><span class="nav-text">(a) 场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="nav-text">(b) 锁的分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-%E4%B8%89%E7%A7%8D%E9%94%81"><span class="nav-text">(B) 三种锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E8%A1%A8%E9%94%81-%E5%81%8F%E8%AF%BB"><span class="nav-text">(a) 表锁(偏读)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E7%89%B9%E7%82%B9"><span class="nav-text">(1) 特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%BB%BA%E8%A1%A8"><span class="nav-text">(2) 建表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%89%8B%E5%8A%A8%E5%A2%9E%E5%8A%A0%E8%A1%A8%E9%94%81"><span class="nav-text">(3) 手动增加表锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E8%AF%BB%E9%94%81"><span class="nav-text">(4) 读锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%86%99%E9%94%81"><span class="nav-text">(5) 写锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%80%BB%E7%BB%93"><span class="nav-text">(6) 总结</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E8%A1%A8%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-text">(7) 表锁分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E8%A1%8C%E9%94%81-%E5%81%8F%E5%86%99"><span class="nav-text">(b) 行锁(偏写)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%BB%BA%E8%A1%A8"><span class="nav-text">(1) 建表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%A1%8C%E9%94%81%E6%BC%94%E7%A4%BA"><span class="nav-text">(2) 行锁演示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%97%A0%E7%B4%A2%E5%BC%95%E8%A1%8C%E9%94%81%E5%8D%87%E7%BA%A7%E4%B8%BA%E8%A1%A8%E9%94%81"><span class="nav-text">(3) 无索引行锁升级为表锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E9%97%B4%E9%9A%99%E9%94%81%E5%8D%B1%E5%AE%B3"><span class="nav-text">(4) 间隙锁危害</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%A6%82%E4%BD%95%E9%94%81%E5%AE%9A%E4%B8%80%E8%A1%8C"><span class="nav-text">(5) 如何锁定一行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E8%A1%8C%E9%94%81%E5%88%86%E6%9E%90"><span class="nav-text">(6) 行锁分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE"><span class="nav-text">(7) 优化建议</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E9%A1%B5%E9%94%81"><span class="nav-text">(c) 页锁</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%85%B1%E4%BA%AB%E9%94%81%C2%B7%E6%8E%92%E5%AE%83%E9%94%81%C2%B7%E6%84%8F%E5%90%91%E9%94%81"><span class="nav-text">(C) 共享锁·排它锁·意向锁</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%85%AD-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-text">六. 主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#A-%E6%A6%82%E8%BF%B0-1"><span class="nav-text">(A) 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E4%BC%98%E7%82%B9"><span class="nav-text">(a) 主从复制优点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E5%A4%8D%E5%88%B6%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98"><span class="nav-text">(b) 复制解决问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#B-MySQL-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="nav-text">(B) MySQL 主从复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#a-%E6%A6%82%E5%BF%B5"><span class="nav-text">(a) 概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#b-%E4%B8%BB%E8%A6%81%E7%94%A8%E9%80%94"><span class="nav-text">(b) 主要用途</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB"><span class="nav-text">(1) 读写分离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%A4%87%E4%BB%BD"><span class="nav-text">(2) 数据备份</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="nav-text">(3) 高可用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#c-%E5%A4%8D%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-text">(c) 复制基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#d-%E5%A4%8D%E5%88%B6%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99"><span class="nav-text">(d) 复制基本原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#e-%E4%B8%80%E4%B8%BB%E4%B8%80%E4%BB%8E%E5%B8%B8%E8%A7%81%E9%85%8D%E7%BD%AE"><span class="nav-text">(e) 一主一从常见配置</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%83-%E7%BC%93%E5%AD%98%E4%B8%8E-MQ"><span class="nav-text">七. 缓存与 MQ</span></a></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Minwei Chen"
      src="/images/tuoqi.jpg">
  <p class="site-author-name" itemprop="name">Minwei Chen</p>
  <div class="site-description" itemprop="description">Cross the surface, get to the reality. Welcome to Cross Code!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/AltriaChen" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;AltriaChen" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:mwchennju@foxmail.com" title="E-Mail → mailto:mwchennju@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/11/22/MySQL04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/tuoqi.jpg">
      <meta itemprop="name" content="Minwei Chen">
      <meta itemprop="description" content="Cross the surface, get to the reality. Welcome to Cross Code!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Cross Code">
    </span>

    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL笔记(零四)：MySQL高级
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-11-22 11:10:03" itemprop="dateCreated datePublished" datetime="2021-11-22T11:10:03+08:00">2021-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-12-22 14:22:36" itemprop="dateModified" datetime="2021-12-22T14:22:36+08:00">2021-12-22</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>又是一年公历生日，感谢小伙伴们的祝福。虽然以后的人生会一直为生存而战，直至最终战死，但能有幸遇到善良又努力的小伙伴们，我已知足。</p>
<p>人固有一死，希望阿伟最终的结局是为知遇之恩而死。</p>
<p>好了，言归正传。本篇是 MySQL 的终章，讲解的是 MySQL 的运行机制相关的知识，故称 MySQL 高级。内容包括数据库范式，逻辑架构，索引，查询截取分析，锁机制，主从复制，缓存与 MQ。</p>
<a id="more"></a>

<h1 id="一-数据库范式"><a href="#一-数据库范式" class="headerlink" title="一. 数据库范式"></a>一. 数据库范式</h1><p>有点类似设计模式中设计原则，即如何设计设计模式，而数据库范式就是如何设计数据库，即设计数据库需要满足的规范。</p>
<p>有第一范式，第二范式，第三范式，BC范式，第四范式和第五范式</p>
<p>范式并不是越高越好，范式越高，数据库冗余越小，查询性能越低。一般满足第三范式即可。</p>
<ul>
<li><p><strong>第一范式</strong></p>
<p>数据库的每一列是原子性的，不可再分。即一个列中不应该还能再拆分为多个属性。</p>
</li>
<li><p><strong>第二范式</strong></p>
<p>要满足第一范式，属于完全依赖于主键，不能部分依赖。如果有 2 个主键，有个属性只依赖于其中一个主键，就不满足第二范式。</p>
</li>
<li><p><strong>第三范式</strong></p>
<p>要满足第二范式，属性不能依赖于其他非主键属性，只依赖于主键。</p>
<p>简单来说，就是拆表。</p>
</li>
</ul>
<h1 id="二-逻辑架构"><a href="#二-逻辑架构" class="headerlink" title="二. 逻辑架构"></a>二. 逻辑架构</h1><ol>
<li><p>连接层</p>
<p>客户端与连接服务，主要完成类似于连接处理，授权认证及相关的安全方案。该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。可实现基于 SSL 的安全链接。</p>
</li>
<li><p>服务层</p>
<p>完成大多数的核心服务功能，如 SQL 接口，完成缓存的查询，SQL 的分析和优化及部分内置函数执行。</p>
</li>
<li><p>引擎层</p>
<p>存储引擎层，存储引擎真正负责 MySQL 中数据的存储和提取，服务器通过 API 与存储引擎通信。</p>
</li>
<li><p>存储层</p>
<p>数据存储层，将数据存储在运行与裸设备文件系统之上，并完成与存储引擎的交互。</p>
</li>
</ol>
<p><strong>存储引擎</strong></p>
<p>插件式存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。</p>
<p>存储引擎是针对表而生效的，而不是数据库。</p>
<p>查看存储引擎</p>
<p>show engines;</p>
<p>show variables like ‘%storage_engine%’;</p>
<p>MySQL 默认 InnoDB</p>
<p><strong>MyISAM 与 InnoDB</strong></p>
<table>
<thead>
<tr>
<th>对比</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td>主外键</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>行表锁</td>
<td>表锁，操作一条数据锁整个表，不适合高并发</td>
<td>行锁，操作只锁一行，不对其他行有影响，适合<strong>高并发</strong></td>
</tr>
<tr>
<td>缓存</td>
<td>只缓存索引，不缓存真实数据</td>
<td>缓存锁引与真实数据，对内存要求高，而且内存大小对性能有决定性影响</td>
</tr>
<tr>
<td>表空间</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>关注点</td>
<td><strong>性能</strong></td>
<td><strong>事务</strong></td>
</tr>
<tr>
<td>默认安装</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>表文件</td>
<td>3个，frm存放表结构信息，MYD存放数据，MYI存放表索引</td>
<td>2个，frm存放表结构信息</td>
</tr>
</tbody></table>
<p>因为 myisam 的索引文件和数据文件分开，因此内存中可以存放更多数据，适用于查询较多的场景，比较经典的使用场景是早期大数据下做报表。</p>
<p>InnoDB 支持事务，有聚簇索引，强制要求有主键，支持外键约束，可以有分库分表，读写分离，主备切换来做大数据量，高并发和高可用。技术方案成熟。</p>
<p>阿里巴巴大部分 mysql 数据库使用的为 percona 的原型加以修改，percona 提升了高负载下 InnoDB 性能，更多的诊断与控制行为。</p>
<h1 id="三-索引"><a href="#三-索引" class="headerlink" title="三. 索引"></a>三. 索引</h1><p>性能下降 SQL 慢，如果执行时间长或者等待时间长</p>
<ul>
<li>查询语句写得烂</li>
<li>索引失败</li>
<li>关联查询太多 join (设计缺陷或不得已的需求)</li>
<li>服务器调优及各个参数设置 (缓冲，线程数等)</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4101.png"></p>
<p>sql 的执行顺序为</p>
<ol>
<li>from</li>
<li>join</li>
<li>where</li>
<li>group by</li>
<li>having</li>
<li>select</li>
<li>order by</li>
<li>limit</li>
</ol>
<h2 id="A-join-分类"><a href="#A-join-分类" class="headerlink" title="(A) join 分类"></a>(A) join 分类</h2><p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4102.png"></p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4103.png"></p>
<p>在左外，右外，全连接上加筛选得到。</p>
<h2 id="B-索引的认识"><a href="#B-索引的认识" class="headerlink" title="(B) 索引的认识"></a>(B) 索引的认识</h2><p>索引 Index 是帮助 MySQL 高效获取数据的数据结构，即索引的本质是<strong>数据结构</strong>。</p>
<p>索引的目的是提高查询效率，可以类比字典。直观理解为<strong>排好序</strong>的<strong>快速查找</strong>数据结构。影响 where 的查找与 order 后的排序。</p>
<p>数据库分别维护着索引与数据，索引指向数据。</p>
<p>二叉查找树，左子树所有结点值比当前值小，右子树所有结点值比当前值大，左右子树分别为二叉查找树。为了检验，可以用中序遍历，得到为递增序列就是二叉查找树。这样用二叉查找树，每次可以过滤一半数据，而树的结点指向了数据。</p>
<p>因为索引本身也很大，一半以索引<strong>文件</strong>的形式存在于<strong>磁盘</strong>上。(索引存在于文件系统中)</p>
<p>索引的文件存储形式与<strong>存储引擎</strong>有关 (InnoDB 将索引与数据存在一起，MyISAM 将索引与数据分开存放)</p>
<p>放在磁盘中，就会存在 IO，需要减少 IO 的时间</p>
<ul>
<li>减少 IO 的量</li>
<li>减少 IO 的次数</li>
</ul>
<p>平常说的索引，一般默认指 B 树(多路搜索树，不一定为二叉)结构组织的索引。</p>
<h2 id="C-索引的优势与劣势"><a href="#C-索引的优势与劣势" class="headerlink" title="(C) 索引的优势与劣势"></a>(C) 索引的优势与劣势</h2><p>优势</p>
<ul>
<li>提高数据<strong>检索的效率</strong>，降低数据库的 IO 成本</li>
<li>通过索引对数据<strong>排序</strong>，降低数据排序的成本，降低 CPU 消耗</li>
</ul>
<p>劣势</p>
<ul>
<li>索引列占据空间</li>
<li>索引虽然提高了查询速度，但会降低更新表的速度，因为索引需要更新</li>
<li>索引只是提高效率的一个因素，还需要优化索引建立或优化查询</li>
</ul>
<h2 id="D-MySQL-索引分类"><a href="#D-MySQL-索引分类" class="headerlink" title="(D) MySQL 索引分类"></a>(D) MySQL 索引分类</h2><ol>
<li><p>单值索引</p>
<p>一个索引只包含单个列，一个表可以有多个单列索引</p>
</li>
<li><p>唯一索引</p>
<p>索引值必须要唯一，但允许有空值</p>
</li>
<li><p>复合索引</p>
<p>一个索引包含多个列</p>
</li>
</ol>
<h2 id="E-密集索引与稀疏索引"><a href="#E-密集索引与稀疏索引" class="headerlink" title="(E) 密集索引与稀疏索引"></a>(E) 密集索引与稀疏索引</h2><ul>
<li>密集索引文件中每个搜索码值对应一个索引值</li>
<li>稀疏索引只为索引码的某些值建立索引项(需要找到对应地址，再继续搜索)</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4104.png"></p>
<p>而下图展示了 InnoDB 和 MyISAM 的索引图</p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4105.png"></p>
<p>对于 Innodb</p>
<ul>
<li>主键为密集索引，叶子结点存储了索引和行数据，主键检索可以直接查找</li>
<li>对于非主键索引，其为稀疏索引，需要先在稀疏索引的 B+ 树中检索定位主键信息，在主键中进行第二次寻找，在叶子结点中获取数据</li>
</ul>
<p>对 MyISAM</p>
<ul>
<li>主键索引与非主键索引均为稀疏索引，即索引的叶子结点中不存储数据，索引与数据分开存储</li>
<li>对表来说这两个索引没有区别，非主键索引不用访问主键索引来获取数据</li>
</ul>
<h2 id="F-索引语法"><a href="#F-索引语法" class="headerlink" title="(F) 索引语法"></a>(F) 索引语法</h2><h3 id="a-创建"><a href="#a-创建" class="headerlink" title="(a) 创建"></a>(a) 创建</h3><p>create [unique] index indexName on mytable(columnname(length));</p>
<p>alter table mytable add [unique] index [indexName] on (columnname(length));</p>
<h3 id="b-删除"><a href="#b-删除" class="headerlink" title="(b) 删除"></a>(b) 删除</h3><p>drop index [indexName] on mytable;</p>
<h3 id="c-查看"><a href="#c-查看" class="headerlink" title="(c) 查看"></a>(c) 查看</h3><p>show index from table_name\G</p>
<h3 id="d-详细添加索引"><a href="#d-详细添加索引" class="headerlink" title="(d) 详细添加索引"></a>(d) 详细添加索引</h3><p>alter table tbl_name add primary key(column_list): 添加一个主键，索引必须唯一，且不能为空</p>
<p>alter table tbl_name add unique index_name(column_list): 创建索引值必须唯一(除了 null，null 可能出现多次)</p>
<p>alter table tbl_name add index index_name (column_list): 添加普通索引，索引值可出现多次</p>
<p>alter table tbl_name add fulltext index_name (column_list): 该语句指定了索引为 fulltext，用于全文索引</p>
<h2 id="G-MySQL-索引结构"><a href="#G-MySQL-索引结构" class="headerlink" title="(G) MySQL 索引结构"></a>(G) MySQL 索引结构</h2><ol>
<li><p>BTree 索引</p>
<p>B 树与 B+ 树</p>
<p>对 B+ 树，<strong>真实数据只存在于叶子结点，非叶子结点不存储真实的数据</strong>，只存储指引搜索方向的数据项。树中每一层都是不同的磁盘块，读取算一次 IO，树的高度越高，IO 次数越多。</p>
</li>
<li><p>Hash 索引</p>
<p>只有 memory 才显式支持 hash</p>
<p>InnoDB 支持哈希索引，自适应的，人为不可控制</p>
</li>
<li><p>full-text 全文索引</p>
</li>
<li><p>R-Tree 索引</p>
</li>
</ol>
<h3 id="a-为什么用-B-树而不用红黑树"><a href="#a-为什么用-B-树而不用红黑树" class="headerlink" title="(a) 为什么用 B+ 树而不用红黑树"></a>(a) 为什么用 B+ 树而不用红黑树</h3><p>常见的树</p>
<p>BST：Binary Search Tree，二分查找树。左子树小，右子树大，极端情况下会退换成链表。</p>
<p>AVL：二叉平衡查找树，二叉树，结点有大小要求，左右子树高度差不超过 1，让树更平衡。用低的插入性能换高的查询性能。适用于查询更多，但若插入更多，不适合。</p>
<p>红黑树：也是二叉平衡查找树，最长路径不超过最短路径 2 倍即可。数据多时，树的高度会比较高。</p>
<p>红黑树的旋转涉及到整棵树，因此需要将全部数据加载进内存，而且树的高度较高，而索引结构通常很大，一般以索引文件存在于硬盘中，使用红黑树 IO 次数多，因此红黑树不太适合索引的设计，而 B 树 (B 与 B+) 分块从磁盘中读取文件，只读取需要的块，树的高度更低，IO 次数更少，适用于外部数据的读取，更适合索引的结构设计。</p>
<p>B+ 树结点数据存储一般应该为页的整数倍，MySQL 在读取时候，默认一页为 16k。</p>
<h3 id="b-B-树与-B-树区别"><a href="#b-B-树与-B-树区别" class="headerlink" title="(b) B 树与 B+ 树区别"></a>(b) B 树与 B+ 树区别</h3><p>B 树与 B+ 树均为平衡多路查找树，避免了二叉查找树树高度过高 IO 频繁的问题，所有叶结点高度相同，因此树是平衡的。</p>
<p>B 树在所有结点上既存储数据又存储索引。如果一个结点为 16k，而因为数据放在每一个结点中，数据需要占据一定的内存，因此每个结点存放数据大小有限。</p>
<p>而 B+ 树在 B 树的基础之上，仅用叶子结点存储数据或指向数据的指针 (InnoDB 中主键索引中叶子结点有数据，非主键索引存放主键索引地址；MyISAM 中主键与非主键索引均存放数据地址)，非叶子结点的关键字个数与指针相同，可存储更多关键字，非叶子结点不存放数据，是从叶子结点中提取出的冗余索引，便于去查找数据，所有结点索引从左至右递增。所有的<strong>叶子结点</strong>有指针指向下一个结点。</p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4106.png"></p>
<p>每个结点如果设置太大，那么单次 IO 时间太长；如果设置太小，则树的高度不可控。Mysql 默认设置一个结点 16kb (一页)，如果索引设置 bigint 为 8 字节，存储地址的字符大小为 6 字节，这样单个索引+指针占用 14 字节，这样可以存储 1170 个索引。若叶子结点存放数据，单个索引+数据大小假设为 16kb，则一个叶子结点可放 16 个索引+数据，则总的为 1170×1170×16 约等于 2.2kw。因此 B+ 树可以存储更多数据，一般 3 层可以支持千万级别的数据量查询。而根结点一般常驻内存，3 层的 B+ 树一次查询的 IO 次数为 2。</p>
<p>这样，B+ 树的优势为：更有利于对数据库的<strong>扫描</strong>与<strong>范围查询</strong>(叶子结点存在指针)。</p>
<p>B 树的优势为：在某些查询条件下，查询效率更高，为 O(1)。</p>
<p>数据结构没有好坏之分，只有合不合适。</p>
<p>因此，对于 MySQL 这种关系型数据库，表与表之间的关联性很强，利用一个表的字段去遍历另一个表的数据是非常常见的操作，因此使用 B+ 树方便去遍历与范围查找，比较符合关系型数据库的应用场景。</p>
<p>而对于 MongoDB，其为 NoSQL 数据库的一种，文档型数据库，用类似 JSON 的方式存储数据，用键的形式去获取数据效率较高，数据量很大而且注重效率。B 树的 key 与 data 有对应关系，且单次查询效率更高，因此可以使用 B 树更符合这种非关系型数据库的应用场景。</p>
<p>而 hash 索引的效率理论上要更高，hash 索引只支持 IN 或者 = 的查询，无法支持范围查询，因此在等值查询较少，范围查询更多的情况下，hash 索引不太适合。hash 表中需要将数据放入内存，适合 memory。</p>
<p>而 B* 树在 B+ 树的基础之上，非叶子结点之间也存在指针。</p>
<h3 id="c-回表"><a href="#c-回表" class="headerlink" title="(c) 回表"></a>(c) 回表</h3><p>InnoDB 与 MyISAM 索引均为红黑树，但前者为聚焦索引和密集索引，后者为非聚集索引和稀疏索引。InnoDB 为聚集索引，将索引与数据存放在一起，主键索引可通过叶子结点访问数据，而非主键索引需要先找到对应主键再获取数据(需要 2 棵 B+ 树查找)，因此数据量较少的时候建立索引效率不一定会更高，这就是<strong>回表</strong>。</p>
<p>对比以下两个语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from 表名 where name&#x3D;&quot;zs&quot;;</span><br><span class="line">select * from 表名 where name&#x3D;&quot;zs&quot;;</span><br></pre></td></tr></table></figure>

<p>如果对 id 为主键索引，name 也建立了索引，第一条语句在 name 索引的 B+ 树叶子结点可以直接找到需要的 id，而第二条数据，就必须用 name 索引树中获取的 id 在主键索引中回表，再次查找获取数据。不需要经过回表过程的叫做索引覆盖(查询的字段与建立索引相同)</p>
<p>而 MyISAM 索引与数据分开，为非聚集索引，叶子结点上存储的指向数据的指针，非主键索引不需要先找到主键索引再获取数据。</p>
<p>此聚集索引，如果在指定了主键情况下，为主键；如果有非空唯一键，为唯一键；如果均为没有，会自动生成一个隐藏的 rowID 作为聚集索引。</p>
<h2 id="H-建立索引情况"><a href="#H-建立索引情况" class="headerlink" title="(H) 建立索引情况"></a>(H) 建立索引情况</h2><h3 id="a-建立索引情况"><a href="#a-建立索引情况" class="headerlink" title="(a) 建立索引情况"></a>(a) 建立索引情况</h3><ol>
<li><strong>主键</strong>自动建立唯一索引</li>
<li><strong>频繁</strong>作为<strong>查询</strong>条件的字段应该创建索引</li>
<li>查询中与其他表相关联的字段，<strong>外键</strong>关系创立索引</li>
<li>在高并发下倾向于创建<strong>组合索引</strong></li>
<li>查询中<strong>排序</strong>的字段，排序字段若通过索引访问将大大提高排序速度</li>
<li>查询中统计或者分组字段</li>
</ol>
<h3 id="b-不建立索引情况"><a href="#b-不建立索引情况" class="headerlink" title="(b) 不建立索引情况"></a>(b) 不建立索引情况</h3><ol>
<li><p><strong>where条件里用不到</strong>的字段不要创建索引</p>
</li>
<li><p>表<strong>记录太少</strong></p>
</li>
<li><p>经常增删改的表</p>
</li>
<li><p>若某个数据列包括太多重复内容，建立索引无太大效果</p>
<p>数据重复且平均分配的值建索引效果不大</p>
</li>
</ol>
<h3 id="c-不使用-UUID-作为主键"><a href="#c-不使用-UUID-作为主键" class="headerlink" title="(c) 不使用 UUID 作为主键"></a>(c) 不使用 UUID 作为主键</h3><p>导致索引的 data 都是主键值，索引变得过大，占据磁盘空间。UUID 并不是顺序的，随机的插入可能导致树的分裂从而重新组织，浪费时间，因此一般在 innodb 表里，建议用统一的自增值作为主键，这样保持聚簇索引直接在树中进行添加即可。</p>
<h2 id="I-性能分析"><a href="#I-性能分析" class="headerlink" title="(I) 性能分析"></a>(I) 性能分析</h2><h3 id="a-Mysql-Query-Optimizer"><a href="#a-Mysql-Query-Optimizer" class="headerlink" title="(a) Mysql Query Optimizer"></a>(a) Mysql Query Optimizer</h3><p>Mysql 中有专门负责优化 SELECT 语句的优化器模块，主要功能：通过计算分析系统中收集到的统计信息，为客户端请求的 Query 提供他认为最有的执行计划</p>
<h3 id="b-Mysql-常见瓶颈"><a href="#b-Mysql-常见瓶颈" class="headerlink" title="(b) Mysql 常见瓶颈"></a>(b) Mysql 常见瓶颈</h3><ul>
<li>CPU：CPU 在饱和的时候一般发生在数据装入内存或从磁盘读取数据的时候</li>
<li>IO：磁盘 I/O 瓶颈发生在装入数据远大于内容容量的时候</li>
<li>服务器硬件性能瓶颈：top，free，iostat 与 vmstat 来查看系统性能状态</li>
</ul>
<h3 id="c-explain"><a href="#c-explain" class="headerlink" title="(c) explain"></a>(c) explain</h3><p>是什么？(查看执行计划)</p>
<p>使用 explain 关键字可以模拟优化器执行 SQL 查询语句，从而知道 Mysql 如何处理你的 SQL 语句，分析你的查询语句或是表结构的性能瓶颈。</p>
<p>能干嘛？</p>
<ul>
<li>表的读取顺序：id</li>
<li>数据读取操作的操作类型：select_type</li>
<li>哪些索引可以使用</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被优化器查询</li>
</ul>
<p>怎么用？</p>
<p><strong>explain+SQL语句</strong></p>
<p>表头信息</p>
<p>id|select_type|table|type|possible_keys|key|key_len|ref|rows|Extra</p>
<p><strong>id</strong></p>
<p>select 查询的序列号，包含一组数字，表示查询中执行的 select 子句或操作表的顺序</p>
<p>三种情况</p>
<ul>
<li>id<strong>相同，执行顺序由上至下</strong></li>
<li>id<strong>不同</strong>，如果是子查询，id的序号会递增，<strong>id值越大优先级越高</strong></li>
<li>id不同，同时存在 (大的先行，相同的从上至下)</li>
</ul>
<p>衍生=derived</p>
<p><strong>select_type</strong></p>
<ol>
<li>simple：简单的 select 查询，不包括子查询或者 union</li>
<li>primary：查询中若包含复杂的子部分，最外层查询被标记</li>
<li>subquery：在 select 或 where 列表包含了子查询</li>
<li>derived：在 from 列表中包含的子查询被标记为 derived (衍生)，Mysql 会递归执行这些子查询，将结果放在<strong>临时表</strong>中</li>
<li>union：若第二个 select 出现在 union 之后，将标记为 union；若 union 包含在 from 子句的子查询中，外层 select 将被标记为 derived</li>
<li>union result：从 union 表获取结果的 select</li>
</ol>
<p>table：这行数据关于哪张表</p>
<p><strong>type</strong></p>
<p>访问类型排列</p>
<p>显示<strong>查询</strong>使用了何种类型，从最好到最差依次是</p>
<p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;All</p>
<p>一般得保证查询至少达到 <strong>range</strong> 级别，<strong>最好能到 ref</strong></p>
<p>system：表只有一行记录(等于系统表)，为 const 类型的特例，平时不会出现</p>
<p>const：通过索引一次就找到了，const 用于比较 primary_key 或者 unique 索引。因为只匹配一行数据，所以很快。如将索引置于 where 列表中，Mysql 就能将该查询优化为常量</p>
<p>eq_ref：唯一性<strong>索引扫描</strong>，对于每个索引键，<strong>表中只有一条记录与之匹配</strong>，常见于主键或唯一索引扫描</p>
<p>ref：<strong>非唯一性索引扫描</strong>，返回匹配某个单独值的所有行。本质上也是一种<strong>索引访问</strong>，它返回所有匹配某个单独值的行，然而，可能会找到<strong>多个符合条件的行</strong>，应属于查找与扫描的混合体。</p>
<p>range：只检索给定范围的行，使用一个索引来选择行。一般为出现了 between，and，&lt;，&gt;，in 等的查询</p>
<p>index：full index scan，index 与 all 区别为 index 类型只遍历索引树，通常比 all 快。(index 从索引中读，all 从硬盘中读)</p>
<p>all：全表扫描</p>
<p><strong>possible_keys 与 key</strong></p>
<ul>
<li>是否使用到索引</li>
<li>索引竞争时，最后用到哪个索引</li>
</ul>
<p>possible_key：显示可能应用在这个表上的索引，<strong>不一定被实际使用</strong></p>
<p>key：实际使用的索引，如果没 null，没有使用到索引。查询中若使用了<strong>覆盖索引</strong>，该索引仅出现在 key 列表中。(<strong>查询的字段与建立的复合索引匹配</strong>)</p>
<p><strong>key_len</strong></p>
<p>表示索引中使用的字节数，可通过该列计算查询中使用的索引长度。在不损失精度下，越短越好。索引字段的最大可能长度，<strong>并非实际使用长度</strong>。根据表定义计算而得，不是通过表内检索出的。</p>
<p><strong>ref</strong></p>
<p>显示索引的哪一列被使用，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。</p>
<p><strong>rows</strong></p>
<p>根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数(越小越好)</p>
<p><strong>Extra</strong></p>
<p>包含不适合在其他列中显示但十分重要的信息</p>
<ul>
<li><p><strong>Using filesort</strong>：说明 mysql 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序读取。Mysql 无法使用索引完成的排序操作称为“文件排序”。出现了<strong>不好</strong>！如索引顺序为 col1，col2，col3，排序时从 col3 开始</p>
</li>
<li><p><strong>Using temporary</strong>：使用了临时表保存中间结果，Mysql 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。出现了<strong>很不好！group by 的个数和顺序最好和索引相同！</strong></p>
</li>
<li><p><strong>Using index</strong>：相应的 select 操作中使用了覆盖索引，避免访问了表的数据行，<strong>效率不错</strong>！如果同时出现 using where，说明索引被用来执行索引键值的查找；如果没有，说明索引用来读取数据而非执行查找动作。</p>
<p>覆盖索引：建立了索引，且查询的列与索引的顺序与个数正好匹配。如果要使用覆盖索引，select 列表中只取出所需要的列，不可 select *。</p>
</li>
<li><p>Using where：使用了 where</p>
</li>
<li><p>using join buffer：使用了连接缓存</p>
</li>
<li><p>impossible where：where 子句的值为 false</p>
</li>
<li><p>select tables optimized away：优化索引操作</p>
</li>
<li><p>distinct：优化 distinct 操作</p>
</li>
</ul>
<h2 id="J-索引优化"><a href="#J-索引优化" class="headerlink" title="(J) 索引优化"></a>(J) 索引优化</h2><h3 id="a-索引分析"><a href="#a-索引分析" class="headerlink" title="(a) 索引分析"></a>(a) 索引分析</h3><h4 id="1-单表"><a href="#1-单表" class="headerlink" title="(1) 单表"></a>(1) 单表</h4><p>先检验是否能查询出结果，再看如何优化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists &#96;article&#96;(</span><br><span class="line">        id int(10) not null primary key auto_increment,</span><br><span class="line">        author_id int(10) not null,</span><br><span class="line">        category_id int(10) not null,</span><br><span class="line">        views int(10) not null,</span><br><span class="line">        comments int(10) not null,</span><br><span class="line">        title varbinary(255) not null,</span><br><span class="line">        content text not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into article(&#96;author_id&#96;,&#96;category_id&#96;,&#96;views&#96;,&#96;comments&#96;,&#96;titles&#96;,&#96;content&#96;)</span><br><span class="line">values(1,1,1,1,&#39;1&#39;,&#39;1&#39;),(2,2,2,2,&#39;2&#39;,&#39;2&#39;),(1,1,3,3,&#39;3&#39;,&#39;3&#39;);</span><br></pre></td></tr></table></figure>

<p>查询的为 category_id 为 1，评论数 &gt;1，views 最多的作者 id</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain select id,&#96;author_id&#96; from &#96;article&#96; where &#96;category_id&#96;&#x3D;1 and &#96;comments&#96;&gt;1 order by views desc limit 1;</span><br></pre></td></tr></table></figure>

<p>查询结果为</p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4107.png"></p>
<p>可以看出 type 为最差的 AII 即全表扫描，Extra 中有 Using filesort，最坏的情况，需要优化。</p>
<p>因此需要建立索引，在 where 后面出现的可以建立索引。</p>
<p>尝试 1：给 where 和 order by 后的 category_id，comments，views 建立符合索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_article_ccv on article(category_id,comments,views);</span><br></pre></td></tr></table></figure>

<p>这时候 type 为 range，不是全表扫描了，但是 Using filesort。因为是 comment&gt;1，范围会导致索引失效，Mysql 无法利用索引对 views 部分进行检索，后面的索引用不上。如果此时 comment 为 =1，便可以用上。</p>
<p>将当前索引删除</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop index idx_article_ccv on article;</span><br></pre></td></tr></table></figure>

<p>尝试 2：不将 comment 作为索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create index idx_article_cv on article(category_id,views);</span><br></pre></td></tr></table></figure>

<p>这时候，再次查看 explain 结果</p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4108.png"></p>
<p>发现 type 为 ref，用到了索引，而且没有全文扫描，达到效果。</p>
<h4 id="2-两表"><a href="#2-两表" class="headerlink" title="(2) 两表"></a>(2) 两表</h4><p>两表连接时，当两个 join 时，索引该如何建立呢？</p>
<p>当有两个表，使用 left join 的时候，连接条件为，发现两个表的 type 都为 all，因此可以建立索引。</p>
<p>左连接，索引加在右表，右表此时为 ref，使用到了索引。</p>
<p>左连接，索引加在左表，左表为 index，效果没有加在右表上好。</p>
<p>因为左连接的特性：左边一定有。left join 条件用于确定如何从右边搜索行，左边一定都有。<strong>右边为关键点，一定要建立索引</strong>。</p>
<p>因此，左连接，给右表建立索引；右连接，给左表建立索引。换而言之，有索引的表作为从表。</p>
<p>join语句的优化：</p>
<ul>
<li>尽可能减少 join 语句中的循环次数，<strong>用小表驱动大表</strong>。</li>
<li>优先优化 NestedLoop 的内层循环</li>
<li>保证 join 语句中被驱动表上 join 条件字段已经被索引</li>
<li>当无法保证被驱动表的 join 字段被索引且内存资源充足的情况下，不要太吝惜 JoinBuffer 的设置</li>
</ul>
<h3 id="b-索引失效"><a href="#b-索引失效" class="headerlink" title="(b) 索引失效"></a>(b) 索引失效</h3><ol>
<li><p>全值匹配最好 (where 查询为全部索引)</p>
</li>
<li><p><strong>最佳左前缀法则</strong>(火车头不能丢，中间车厢不能断)</p>
<p>如果索引了多列，要遵循最佳左前缀法则，查询从索引的<strong>最左前列开始</strong>并且<strong>不跳过索引中的列</strong></p>
<p>如果索引顺序为 i1，i2，i3，查询时候为 i3，i2，i1，会被 Mysql <strong>优化</strong>，仍然可以用复合索引查询</p>
</li>
<li><p><strong>不要在索引列上做任何操作</strong>(计算，函数，(自动或手动)<strong>类型转换</strong>) (<strong>索引操作就失效</strong>)</p>
</li>
<li><p>存储引擎不能使用索引中范围条件右边的列(<strong>范围之后全失效！</strong>)</p>
</li>
<li><p>尽量使用覆盖索引(只访问索引的查询，索引列和查询列一致)，减少 select*</p>
</li>
<li><p>mysql 在使用<strong>不等于</strong> (!= 或 &lt;&gt;) 的时候无法使用索引会导致全表扫描(少用不等)</p>
</li>
<li><p>is null，is not null 也无法使用索引</p>
</li>
<li><p>like 以<strong>通配符开头</strong> (%abc)，mysql 索引失效(最好只在右边写 %)</p>
<p>如果需要用到左边 %，用<strong>覆盖索引</strong>避免全表扫描(查询字段为索引中的一些或全部，不能超过)</p>
</li>
<li><p>字符串不加单引号索引失效(隐式类型转换)</p>
</li>
<li><p>用 or 连接时<strong>索引失效，少用 or</strong></p>
</li>
</ol>
<p>如果 order by 中用到的字段与前面用于筛选的不连续，会有 filesort。核心就在于索引是否能被连贯的使用到。</p>
<p>如索引为 c1，c2，c3，c4</p>
<p>查询为 where c1 order by c3, c2 会有 filesort</p>
<p>查询为 where c1 c2 order by c3, c2 不会有，因为 c2 被筛选了是连贯的</p>
<p>定值是常量，范围之后是失效，最终看排序，一般 order by 给个范围</p>
<p>group by 基本需要排序，会有临时表产生</p>
<p>一般建议</p>
<ul>
<li>对于单键索引，尽量选择针对当前 query 过滤性更好的选择</li>
<li>选择组合索引时，当前 Query 过滤性最好的字段在索引字段顺序中，位置越靠前越好</li>
<li>选择组合索引时，尽量选择可以能够包含当前 query 中的 where 字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整 query 的写法来达到选择合适索引的目的</li>
</ul>
<p>最好的是全值匹配，要遵守最左前缀；索引上不要计算，范围之后会失效，like 百分放右边，不等空值还有 or，索引失效</p>
<h3 id="c-索引下推"><a href="#c-索引下推" class="headerlink" title="(c) 索引下推"></a>(c) 索引下推</h3><p>先介绍谓词下推</p>
<p>如果有如下的 sql 语句</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select t1.name, t2.name from t1 inner join t2 on t1.id&#x3D;t2.id;</span><br></pre></td></tr></table></figure>

<p>这条语句的执行顺序有两种</p>
<ol>
<li>先执行表的 join，再筛选需要的数据</li>
<li>先将所需要的列拿出，再执行表的 join</li>
</ol>
<p>后执行 join 操作 (join 为动词) 可被理解为谓词下推，减少了表连接前的数据量。</p>
<p>而索引下推</p>
<p>如果筛选条件有 name，age</p>
<p>不使用索引下推</p>
<ul>
<li>先根据 name 列的值将所有数据拉到 server 层，在 server 层对 age 做过滤</li>
</ul>
<p>使用索引下推</p>
<ul>
<li>根据 name，age 两个字段把满足要求的数据拉到 server 层，取出对应的数据</li>
</ul>
<h3 id="d-MRR"><a href="#d-MRR" class="headerlink" title="(d) MRR"></a>(d) MRR</h3><p>Multi-Range Read，多范围查询</p>
<p>当使用非主键索引查询数据时，没有索引覆盖需要进行回表，即先查询主键值，再到主键索引中查询整行数据。</p>
<p>场景：主键为 id，非主键索引为 name，根据 name 去查询，得到的 id 是无序的(相对于物理顺序)，这样根据无序的列表去主键 B+ 树上进行的是随机查找。而如果在 name 索引树上得到无序的 id 后，先将 id 进行排序，当排序完成后在主键索引中查找就不是随机了。</p>
<h3 id="e-优化原则"><a href="#e-优化原则" class="headerlink" title="(e) 优化原则"></a>(e) 优化原则</h3><p>小表驱动大表，小的数据库驱动大的数据集。</p>
<p>EXISTS</p>
<ul>
<li>SELECT ··· FROM table WHERE EXISTS(subquery)</li>
</ul>
<p>语法可理解为：<strong>将主查询的数据，放到子查询中做条件验证，根据验证结果 (true 或 false) 来决定主查询数据是都得以保留</strong>，当主查询的表比子查询中表更小时效率高，若主查询中数据多，用 IN 效率更高。即小表驱动大表。相当于 IN 查询的变种。</p>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4109.png"></p>
<h3 id="f-order-by-关键字优化"><a href="#f-order-by-关键字优化" class="headerlink" title="(f) order by 关键字优化"></a>(f) order by 关键字优化</h3><p>(1) 尽量使用 index 方式排序，避免使用 filesort</p>
<ul>
<li><p>Mysql 支持两种方式的排序，Filesort 和 Index，Index 效率高，指 Mysql 扫描索引本身完成排序，Filesort 效率较低</p>
</li>
<li><p>两种情况使用 Index 排序</p>
<p>order by 语句使用索引最左前列</p>
<p>使用 where 子句与 order by 子句条件组合满足索引最左前列</p>
</li>
</ul>
<p>(2) 尽可能在索引数据列上完成排序，按照索引建的最佳左前缀</p>
<ul>
<li><p>若不在索引上，filesort 存在双路排序和单路排序</p>
<p>双路排序：Mysql 4.1 之前采用，扫描<strong>两次</strong>磁盘</p>
<p>单路排序：读取后，在 buffer 排序，避免第二次读取数据，使用更多空间，将每一行保存进内存单路总体比双路好，但存在问题，即如果 sort_buffer 数据比要全部取的数据小，需要多次 IO</p>
</li>
</ul>
<p>(3) 调优策略</p>
<ul>
<li>不使用 select *，排序顺序最好与索引一致</li>
<li>增大 sort_buffer_size</li>
<li>提高 max_length_for_sort_data (提高排序查询效率)</li>
</ul>
<p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4110.png"></p>
<h3 id="g-group-by-关键字优化"><a href="#g-group-by-关键字优化" class="headerlink" title="(g) group by 关键字优化"></a>(g) group by 关键字优化</h3><ul>
<li>group by 实质为先排序后分组，按照索引的最佳左前缀原则</li>
<li>当无法使用索引列，增大 sort_buffer_size + max_length_for_sort_data</li>
<li>where 高于 having，能写在 where 限定条件的不要写在 having</li>
</ul>
<h1 id="四-查询截取分析"><a href="#四-查询截取分析" class="headerlink" title="四. 查询截取分析"></a>四. 查询截取分析</h1><h2 id="A-分析"><a href="#A-分析" class="headerlink" title="(A) 分析"></a>(A) 分析</h2><ol>
<li>观察，至少跑一天，看看生产的慢 sql 情况</li>
<li>开启慢查询日志，设置阈值，如超过 5 秒钟就为慢 sql，将其抓取</li>
<li>explain + 慢 sql 分析</li>
<li>show profile</li>
<li>运维经理 orDBA，进行 sql 数据库服务器的参数调优</li>
</ol>
<p>总结</p>
<ol>
<li>慢查询的开启并捕获</li>
<li>explain + 慢 sql 分析</li>
<li>show profile 查询 sql 在 Mysql 服务器中的执行细节和生命周期情况</li>
<li>SQL 数据库服务器参数调优</li>
</ol>
<h2 id="B-慢查询日志"><a href="#B-慢查询日志" class="headerlink" title="(B) 慢查询日志"></a>(B) 慢查询日志</h2><ul>
<li>是一种日志记录，用来记录 Mysql 中响应时间超过阈值的语句，具体为运行时间超过 long_query_time 值(默认为 10 秒) 的 sql，记录到慢查询日志中</li>
<li>默认没有开启，需要手动开启；若不是调优需要，不建议启动，造成性能影响</li>
</ul>
<p>查看开启</p>
<p>show variables like ‘%slow_query_log%’</p>
<p>设置 slow_query_log 的值来开启，只对当前数据库生效，Mysql 重启后失效；若要用久，需要修改配置文件 my.cnf</p>
<ul>
<li>set global slow_query_log = 1;</li>
</ul>
<p>查看设定时间</p>
<p>show variables like ‘long_query_time%’, 判断为<strong>大于</strong>的语句，而不是大于等于</p>
<p>设置阈值时间</p>
<p>set global long_query_time = 3; 设置 3 秒</p>
<p>需要重新连接或新开会话才能看到修改值</p>
<p>检验</p>
<p>可以让其休眠等待 4s，这样看到效果</p>
<p>select sleep(4);</p>
<p>在慢日志中可以具体看出那条 sql 语句超出了阈值时间。</p>
<p>查询当前系统中有多少条慢查询记录</p>
<p>show global status like ‘%Slow_queries’;</p>
<h2 id="C-Show-Profile"><a href="#C-Show-Profile" class="headerlink" title="(C) Show Profile"></a>(C) Show Profile</h2><p>mysql 提供的用来分析当前会话中语句执行的<strong>资源消耗</strong>情况，可以用于 SQL 的调优的测量。</p>
<p>默认情况下，参数处于关闭状态，并保存 15 次的运行结果。</p>
<ol>
<li><p>看当前是否支持</p>
<p>show variables like ‘profiling’; 默认为关闭，使用前需要开启</p>
</li>
<li><p>设置开启</p>
<p>set profiling=on;</p>
</li>
<li><p>运行 sql</p>
</li>
<li><p>查看结果</p>
<p>show profiles</p>
<p>包括 Query_ID，Duration，Query</p>
</li>
<li><p>诊断 sql</p>
<p>show profile cpu, block io for query 上一步问题 sql 号码</p>
</li>
<li><p>日常开发需要注意的结论</p>
<p>(1) converting HEAP to MyISAM 查询结果太大，内存不够用往磁盘上搬</p>
<p>(2) Creating tmp table 创建临时表</p>
<p>​          拷贝数据至临时表</p>
<p>​          用完再删除</p>
<p>(3) <strong>Copying to tmp table on disk</strong> 把内存中临时表复制到磁盘，危险！！！</p>
<p>(4) locked</p>
</li>
</ol>
<h2 id="D-全局查询日志"><a href="#D-全局查询日志" class="headerlink" title="(D) 全局查询日志"></a>(D) 全局查询日志</h2><p>永远不要在生产环境开启此功能</p>
<p>编码启动</p>
<ul>
<li><p>set global general_log=1;</p>
</li>
<li><p>set global log_output=’TABLE’;</p>
<p>在编写的所有 sql 语句，会被记录到 mysql 库里的 general_log 表，用以下命令查看</p>
</li>
<li><p>select * from mysql.general_log;</p>
</li>
</ul>
<h1 id="五-锁机制"><a href="#五-锁机制" class="headerlink" title="五. 锁机制"></a>五. 锁机制</h1><h2 id="A-概述"><a href="#A-概述" class="headerlink" title="(A) 概述"></a>(A) 概述</h2><p>锁是协调计算机多个进程或线程并发访问某一资源的机制</p>
<h3 id="a-场景"><a href="#a-场景" class="headerlink" title="(a) 场景"></a>(a) 场景</h3><p>场景：商品一件库存，两个人同时买，谁买到</p>
<p>一定要用到<strong>事务</strong>，从库存表中取出物品数量，插入订单，付款后插入付款表信息，更新商品数量，用锁可以对有限资源进行保护，解决隔离和并发的矛盾。</p>
<h3 id="b-锁的分类"><a href="#b-锁的分类" class="headerlink" title="(b) 锁的分类"></a>(b) 锁的分类</h3><ul>
<li><p>对数据操作类型分类</p>
<p>(1) 读锁(共享锁)：针对同一份数据，多个读操作可以同时进行而不会相互影响</p>
<p>(2) 写锁(排它锁)：当前写操作没有完成前，会阻断其他写锁和读锁</p>
</li>
<li><p>对数据操作粒度分类</p>
<p>(1) 表锁 (MyISAM)</p>
<p>(2) 行锁 (InnoDB)</p>
<p>(3) 页锁</p>
</li>
</ul>
<h2 id="B-三种锁"><a href="#B-三种锁" class="headerlink" title="(B) 三种锁"></a>(B) 三种锁</h2><p>表级锁，行级锁与页锁</p>
<ul>
<li>表级锁：开销小，加锁快；不出现死锁；锁定粒度大，发生锁冲突概率最高，并发度最低</li>
<li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突概率最低，并发度最高</li>
<li>页面锁 (cap 锁，间隙锁)：开销和加锁时间介于表锁与行锁之间；会出现死锁；锁定粒度介于表锁与行锁之间，并发度一般</li>
</ul>
<p>仅从锁的角度，表级锁更适合查询为主的业务，只有少量按照索引条件更新数据的应用</p>
<p>行级锁适合大量按照索引条件并发更新少量不同数据，同时有并发查询的应用</p>
<h3 id="a-表锁-偏读"><a href="#a-表锁-偏读" class="headerlink" title="(a) 表锁(偏读)"></a>(a) 表锁(偏读)</h3><p>表锁可分为意向共享锁，意向排它锁与自增锁</p>
<ul>
<li>意向共享锁 (IS)：事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。</li>
<li>意向排他锁 (IX)：事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。</li>
<li>自增锁 (AUTO-INC Locks)：特殊表锁，自增长计数器通过该“锁”来获得自增长计数器最大的计数值。加行锁行，需要先获取表锁。</li>
</ul>
<h4 id="1-特点"><a href="#1-特点" class="headerlink" title="(1) 特点"></a>(1) 特点</h4><ul>
<li>偏向 MyISAM 存储引擎，开销小，加锁快；</li>
<li>无死锁；</li>
<li>锁定粒度大，发生锁冲突的概率最高，并发度最低</li>
</ul>
<h4 id="2-建表"><a href="#2-建表" class="headerlink" title="(2) 建表"></a>(2) 建表</h4><p>create table 表名(</p>
<p>列</p>
<p>)engine myisam;</p>
<p>需要指定执行引擎为 myisam</p>
<h4 id="3-手动增加表锁"><a href="#3-手动增加表锁" class="headerlink" title="(3) 手动增加表锁"></a>(3) 手动增加表锁</h4><p>lock table 表名字 read(write)，表名字2 read(write)，其他；</p>
<p>show open tables; 看哪些有锁</p>
<p>unlock tables; 释放表锁</p>
<h4 id="4-读锁"><a href="#4-读锁" class="headerlink" title="(4) 读锁"></a>(4) 读锁</h4><p>加锁方</p>
<ul>
<li>可以读自己锁的表</li>
<li>不能插入或更新自己锁的表</li>
<li>不能读其他表</li>
</ul>
<p>其他方</p>
<ul>
<li>可以读被锁的表</li>
<li>修改被读锁的表，<strong>一直等待</strong>直到获得锁</li>
<li>可以读和写其他被锁的表</li>
</ul>
<h4 id="5-写锁"><a href="#5-写锁" class="headerlink" title="(5) 写锁"></a>(5) 写锁</h4><p>加锁方</p>
<ul>
<li>可以读自己锁的表</li>
<li>可以改自己锁的表</li>
<li>不能读其他表</li>
</ul>
<p>其他方</p>
<ul>
<li>可以看和修改其他表</li>
<li>查看，修改被写锁的表，<strong>一直等待</strong>直到获得锁</li>
</ul>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="(6) 总结"></a>(6) 总结</h4><p>MyISAM 执行查询语句前，自动给涉及的所有表加读锁，在执行增删改操作前，自动给涉及的表加写锁</p>
<p>MySQL 表级锁有两种模式</p>
<ul>
<li>表共享读锁 (Table Read Lock)</li>
<li>表独占写锁 (Table Write Lock)</li>
</ul>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>可否兼容</th>
<th>读锁</th>
<th>写锁</th>
</tr>
</thead>
<tbody><tr>
<td>读锁</td>
<td>是</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>写锁</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
</tbody></table>
<ol>
<li>对 MyISAM 表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其他进程的写操作。</li>
<li>对 MyISAM 表的写操作(加写锁)，会阻塞其他进程对同一表的读和写操作，只有当写锁释放后，才会执行其他进程的读写操作</li>
</ol>
<p>即，<strong>读锁会阻塞写，但不会阻塞其他进程读，写锁会把其他进程读和写都阻塞</strong>。</p>
<h4 id="7-表锁分析"><a href="#7-表锁分析" class="headerlink" title="(7) 表锁分析"></a>(7) 表锁分析</h4><p>show open tables; 看哪些表被锁，为 1 的是被锁了。</p>
<p>show status like ‘tables%’;</p>
<ul>
<li>table_locks_waited：出现表级锁争用而发生等待的次数(不能立即获取锁的次数，等待一次加一)，较高说明存在<strong>较严重的表级锁争用</strong>情况</li>
<li>table_locks_immediate：产生表级锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加一</li>
</ul>
<p><strong>MyISAM</strong>读写锁的调度是<strong>写优先，不适合做写为主表的引擎。写锁后，其他线程不能做任何操作，大量更新会使查询很难得到锁，从而造成永远阻塞</strong>。</p>
<h3 id="b-行锁-偏写"><a href="#b-行锁-偏写" class="headerlink" title="(b) 行锁(偏写)"></a>(b) 行锁(偏写)</h3><p>主要实现算法有 Record Lock，Gap Lock 和 Next-key Lock</p>
<ul>
<li>Record Lock：锁单行记录(锁数据，不锁 Gap)</li>
<li>Gap Lock：间隙锁，锁一定范围，不包括记录本身(不锁记录，锁数据的 Gap)</li>
<li>Next-key Lock：同时锁住数据，并且锁住数据前面的 Gap</li>
</ul>
<p>行锁的特点如下</p>
<ul>
<li>偏向 InnoDB 引擎，开销大，加锁慢；</li>
<li>会出现死锁</li>
<li>锁定粒度最小，发生锁冲突的概率最低，并发度也最高</li>
</ul>
<p>InnoDB 与 MyISAM 最大不同有两点</p>
<ol>
<li>支持事务 (TRANSACTION)</li>
<li>采用了行级锁</li>
</ol>
<h4 id="1-建表"><a href="#1-建表" class="headerlink" title="(1) 建表"></a>(1) 建表</h4><p>create table 表名(</p>
<p>)engine=innodb;</p>
<h4 id="2-行锁演示"><a href="#2-行锁演示" class="headerlink" title="(2) 行锁演示"></a>(2) 行锁演示</h4><p>如果两个事务对同一行数据进行更新，则后更新的数据会被阻塞直到第一个事务提交，这时候更新的值为第二个事务的值。如果两个事务对不同行数据进行更新，则不会受到影响。</p>
<h4 id="3-无索引行锁升级为表锁"><a href="#3-无索引行锁升级为表锁" class="headerlink" title="(3) 无索引行锁升级为表锁"></a>(3) 无索引行锁升级为表锁</h4><p>若 varchar 类型的索引，更新数据时，没加单引号将索引做了类型转换，会造成索引失效，从行锁变成表锁。</p>
<p>varchar 类型数据一定要加单引号！！！</p>
<h4 id="4-间隙锁危害"><a href="#4-间隙锁危害" class="headerlink" title="(4) 间隙锁危害"></a>(4) 间隙锁危害</h4><p>innodb 使用间隙锁条件为在可重复读下，检索条件要有索引。</p>
<p>表中的 id 为 1,3,4，如果行锁的条件为 where id&gt;1 and id&lt;5，则应该锁的数据是 id 为 3,4 的数据，如果此时事务 2 要插入 id=2 的数据，按理不应该被锁住，但是会被锁</p>
<p>当用<strong>范围条件</strong>而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条件的已有数据记录的索引项加锁；对于<strong>键值在条件范围内但并不存在的记录</strong>，叫做“间隙 (GAP)”，InnoDB 会对这个间隙加锁，锁机制就是间隙锁 (Next-Key 锁)。</p>
<p>间隙锁的范围是当前查询的条件向左找最靠近检索条件的值，向右找最靠近检索条件的值。不在此范围的数据不会被锁定。</p>
<p>危害</p>
<p>因为 Query 执行过程中通过范围查找，会锁定整个范围内所有的索引键值，即使这个键值并不存在。</p>
<p>间隙锁有比较致命的弱点，即当锁定一个范围键值后，即使某些不存在的键值也会被无辜的锁定，而造成<strong>在锁定的时候无法插入锁定键值范围内的任何数据</strong>。在某些场景可能对性能造成很大的危害。</p>
<h4 id="5-如何锁定一行"><a href="#5-如何锁定一行" class="headerlink" title="(5) 如何锁定一行"></a>(5) 如何锁定一行</h4><p>select xxx for update 锁定某一行后，其他的操作会被阻塞，直到锁定行的会话提交 commit</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">begin;</span><br><span class="line">select * from 表名 where 条件 for update;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure>

<p>begin 开始，语句后加 <code>for update</code>，最后加 commit。</p>
<p>InnoDB 存储引擎由于实现了行级锁定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定要高，但是在整体并发处理能力方面要远远优于 MyISAM 表级锁定。当系统并发量较高时，InnoDB 的整体性和 MyISAM 相比会有比较明显的优势；但 InnoDB 行级锁定使用不当时，可能会让 InnoDB 整体性能还比 MyISAM 更差。</p>
<h4 id="6-行锁分析"><a href="#6-行锁分析" class="headerlink" title="(6) 行锁分析"></a>(6) 行锁分析</h4><p>show status like ‘innodb_row_lock%’;</p>
<ul>
<li>InnoDB_row_lock_current_waits; 当前正在等待锁定的数量</li>
<li>InnoDB_row_lock_waits：系统启动后到现在总共等待的次数</li>
</ul>
<p>如等待次数很高，等待时间不少，用 <strong>show profile</strong> 分析每一步消耗资源及时间</p>
<h4 id="7-优化建议"><a href="#7-优化建议" class="headerlink" title="(7) 优化建议"></a>(7) 优化建议</h4><ul>
<li>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁</li>
<li>合理设计索引，尽量减少锁的范围</li>
<li>尽可能减少检索条件，减少间隙锁</li>
<li>尽量控制事务大小，减少锁定资源量和时间长度</li>
<li>尽可能低级别事务隔离</li>
</ul>
<h3 id="c-页锁"><a href="#c-页锁" class="headerlink" title="(c) 页锁"></a>(c) 页锁</h3><ul>
<li>开销和加锁时间界于表锁和行锁之间</li>
<li>会出现死锁</li>
<li>锁定粒度介于表锁和行锁之间，并发度一般</li>
</ul>
<h2 id="C-共享锁·排它锁·意向锁"><a href="#C-共享锁·排它锁·意向锁" class="headerlink" title="(C) 共享锁·排它锁·意向锁"></a>(C) 共享锁·排它锁·意向锁</h2><p>上面提到，锁按照粒度可分为表锁，行锁及页锁，而按照是否共享的思想，在 InnoDB 中，行锁可分为共享锁 (S) 与排它锁 (X)。</p>
<p>共享锁：其他事务可以读不可以写，<strong>lock in share mode</strong></p>
<p>排它锁：其他事务无法获取到此行 <strong>for update</strong> <strong>慎用</strong>！！！</p>
<p><strong>insert, update, delete, innodb 会自动给这一行加行级排它锁，select 不加锁，因为有 mvcc 机制进行快照读</strong></p>
<p>为了实现多粒度的锁机制，让行锁与表锁共存，InnoDB 中还有两种意向锁，两种意向锁均为表锁。</p>
<ul>
<li>意向共享锁：事务在给数据行加共享锁前，需要取得意向共享锁</li>
<li>意向排它锁：事务在给数据航加排它锁前，需要取得意向排它锁</li>
</ul>
<p>加行锁前，必须取得表级的意向锁。</p>
<p>对一行数据，若有人在修改，会加上排它锁，当前事务不能修改，只能等待获取此排它锁，但这时候可以 select，查询事务开始前此行数据谋划个版本，如果修改某行数据，会同时拿到此表的排它锁，如果不同数据修改不同行，会拿到不同行的行级排它锁，拿同一个表的排它锁，因此 innodb 表级排它锁不冲突。</p>
<h1 id="六-主从复制"><a href="#六-主从复制" class="headerlink" title="六. 主从复制"></a>六. 主从复制</h1><h2 id="A-概述-1"><a href="#A-概述-1" class="headerlink" title="(A) 概述"></a>(A) 概述</h2><p>复制为将主库的 DDL 和 DML 操作通过二进制日志传递到复制服务器(从库)上，然后从库对这些日志重新执行，从而使得主库和从库数据一致。</p>
<h3 id="a-主从复制优点"><a href="#a-主从复制优点" class="headerlink" title="(a) 主从复制优点"></a>(a) 主从复制优点</h3><ul>
<li>若主库出现问题，可以快速切换到从库提供服务</li>
<li>可以在从库执行操作，降低主库的访问压力</li>
<li>可以在从库进行备份，以免备份期间影响主库的服务</li>
</ul>
<h3 id="b-复制解决问题"><a href="#b-复制解决问题" class="headerlink" title="(b) 复制解决问题"></a>(b) 复制解决问题</h3><ul>
<li><p>数据分布</p>
</li>
<li><p>负载平衡</p>
</li>
<li><p>数据备份</p>
</li>
<li><p>高可用性和容错性</p>
</li>
<li><p>实现读写分离，缓解数据库压力</p>
<p>一般只对更新不频繁和对实时性要求不高的数据可以通过从库查询，实时性要求高的仍要从主库查询</p>
</li>
</ul>
<h2 id="B-MySQL-主从复制"><a href="#B-MySQL-主从复制" class="headerlink" title="(B) MySQL 主从复制"></a>(B) MySQL 主从复制</h2><h3 id="a-概念"><a href="#a-概念" class="headerlink" title="(a) 概念"></a>(a) 概念</h3><p>数据可以从一个 MySQL 数据库服务器主节点复制到一个或多个从节点。默认采用异步复制方式，数据的更新可以在远程连接上执行，不用一直访问主服务器来更新数据。</p>
<h3 id="b-主要用途"><a href="#b-主要用途" class="headerlink" title="(b) 主要用途"></a>(b) 主要用途</h3><h4 id="1-读写分离"><a href="#1-读写分离" class="headerlink" title="(1) 读写分离"></a>(1) 读写分离</h4><p>主库负责写，从库负责读，即使主库出现了锁表的情况，通过从库可以保证业务的正常进行</p>
<h4 id="2-数据备份"><a href="#2-数据备份" class="headerlink" title="(2) 数据备份"></a>(2) 数据备份</h4><p>数据实时备份，当系统中某个节点发生故障时，可以方便故障切换(主从切换)</p>
<h4 id="3-高可用"><a href="#3-高可用" class="headerlink" title="(3) 高可用"></a>(3) 高可用</h4><p>在主服务器上生成实时数据，在从服务器上分析数据，提高主服务器的性能</p>
<h3 id="c-复制基本原理"><a href="#c-复制基本原理" class="headerlink" title="(c) 复制基本原理"></a>(c) 复制基本原理</h3><p><img src="https://mwchen.oss-cn-hangzhou.aliyuncs.com/Blog/A4111.png"></p>
<ul>
<li>slave 会从 master 读取 binblog 来进行数据同步</li>
<li>三个步骤<ol>
<li>master 将改变记录到二进制日志 (binary log)。记录过程叫做二进制日志文件，binary log events</li>
<li>slave 将 master 的 binary log events 拷贝到其中继日志 (relay log)</li>
<li>slave 重做中继日志中的事件，将改变应用到自己的数据库，MySQL 复制是异步且串行化的</li>
</ol>
</li>
</ul>
<h3 id="d-复制基本原则"><a href="#d-复制基本原则" class="headerlink" title="(d) 复制基本原则"></a>(d) 复制基本原则</h3><ul>
<li>每个 slave 只有一个 master</li>
<li>每个 slave 只能有一个唯一的服务器 ID</li>
<li>每个 master 可以有多个 slave</li>
</ul>
<h3 id="e-一主一从常见配置"><a href="#e-一主一从常见配置" class="headerlink" title="(e) 一主一从常见配置"></a>(e) 一主一从常见配置</h3><p>保证主从机可以 ping 通，windows 看 ipconfig，linux 看 ifconfig。</p>
<ul>
<li><p>mysql 版本一致且后台以服务运行</p>
</li>
<li><p>主从都配置在【mysqld】节点下，都是小写</p>
</li>
<li><p>主机修改 my.ini 配置文件 (windows)</p>
<ol>
<li><p>【必须】主服务器唯一 id server-id=1</p>
</li>
<li><p>【必须】启用二进制日志</p>
<p>log-bin=自己本地路径/mysqlbin</p>
</li>
<li><p>【可选】启用错误日志</p>
<p>log-err=自己本地路径/mysqlerr</p>
</li>
<li><p>【可选】根目录</p>
<p>basedir=“自己本地路径”</p>
</li>
<li><p>【可选】临时目录</p>
<p>tmpdir=“自己的本地路径”</p>
</li>
<li><p>【可选】数据目录</p>
<p>datadir=“自己的本地路径/Data/”</p>
</li>
<li><p>read-only=0</p>
<p>主机，读写都可以</p>
</li>
<li><p>【可选】设置不要复制的数据库</p>
<p>binlog-ignore-db=mysql</p>
</li>
<li><p>【可选】设置需要复制的数据库</p>
<p>bonlog-do-db=需要复制的主数据库名字</p>
</li>
</ol>
</li>
<li><p>从机修改 my.cnf 配置文件</p>
<ol>
<li><p>【必须】从服务器唯一 ID</p>
</li>
<li><p>【可选】启动二进制日志</p>
</li>
</ol>
</li>
<li><p>主机+从机重启后台 mysql 服务</p>
</li>
<li><p>主机从机关闭防火墙</p>
</li>
<li><p>在 windows 主机上建立账户并授权 slave</p>
</li>
<li><p>在 linux 从机上配置需要复制的主机</p>
</li>
<li><p>主机新建库，新建表，insert 记录，从机复制</p>
</li>
<li><p>停止服务复制</p>
<p>stop slave</p>
</li>
</ul>
<h1 id="七-缓存与-MQ"><a href="#七-缓存与-MQ" class="headerlink" title="七. 缓存与 MQ"></a>七. 缓存与 MQ</h1><p>在提升数据库的垂直性能时，当 QPS 很大，不能让其直接打到数据库上，这样会直接导致数据库挂掉，而万能的解决方法是，遇事不决加一层，如果一层解决不了问题，那就两层。</p>
<p>如果是读多写少的场合，就用缓存，如 Redis，Memcached。</p>
<p>如果是读少写多的场合，就用消息队列 MQ，如 Kafka，RabbitMQ，RocketMQ。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/11/16/MySQL03/" rel="prev" title="MySQL笔记(零三)：视图·变量·函数·流程控制">
      <i class="fa fa-chevron-left"></i> MySQL笔记(零三)：视图·变量·函数·流程控制
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/23/hello-world/" rel="next" title="Hello World">
      Hello World <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Minwei Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/next-boot.js"></script>


  















  

  

  

</body>
</html>
